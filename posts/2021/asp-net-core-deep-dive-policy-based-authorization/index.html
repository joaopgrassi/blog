<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Deep dive into policy-based authorization in ASP.NET Core | Joao Grassi's blog</title>
<meta name=keywords content="asp.net-core,authorization,security,middleware,role-based,claims-based">
<meta name=description content="In this post, I'll take you on a deep dive into the waters of policy-based authorization in ASP.NET Core. Grab your gear!">
<meta name=author content="Joao Grassi">
<link rel=canonical href=https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/>
<link href=https://blog.joaograssi.com/assets/css/stylesheet.min.5df15aa0fa69a07f461d7f7c1614ad5deed5c58a9894e3e7595bf68d9e7d3414.css integrity="sha256-XfFaoPppoH9GHX98FhStXe7VxYqYlOPnWVv2jZ59NBQ=" rel="preload stylesheet" as=style>
<link rel=icon href=https://blog.joaograssi.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.0">
<meta property="og:title" content="Deep dive into policy-based authorization in ASP.NET Core">
<meta property="og:description" content="In this post, I'll take you on a deep dive into the waters of policy-based authorization in ASP.NET Core. Grab your gear!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/">
<meta property="og:image" content="https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/post-cover.png"><meta property="article:published_time" content="2021-03-15T22:30:00+00:00">
<meta property="article:modified_time" content="2021-03-15T22:30:00+00:00"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/post-cover.png">
<meta name=twitter:title content="Deep dive into policy-based authorization in ASP.NET Core">
<meta name=twitter:description content="In this post, I'll take you on a deep dive into the waters of policy-based authorization in ASP.NET Core. Grab your gear!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deep dive into policy-based authorization in ASP.NET Core","name":"Deep dive into policy-based authorization in ASP.NET Core","description":"This is the second post in the Authorization in ASP.NET Core series.\n  Part 1: Using a middleware to build a permission-based identity in ASP.NET Core\n  Part 2: Deep dive into …","keywords":["asp.net-core","authorization","security","middleware","role-based","claims-based"],"articleBody":"This is the second post in the Authorization in ASP.NET Core series.\n  Part 1: Using a middleware to build a permission-based identity in ASP.NET Core\n  Part 2: Deep dive into policy-based authorization in ASP.NET Core (this post)\n  Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core\n  Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core\n  In the previous post, we set the foundation by creating a ClaimsIdentity containing all the logged-in user permissions with the help of a custom middleware.\nBefore we start using the permissions we built in the last post, I believe it makes sense to review the authorization options the framework provides us and understand how things work under the hood.\nSo, in this post, we’ll start by reviewing the “out-of-the-box” authorization options in ASP.NET Core. Next, I’ll take you on a deep dive on the core components that, together, make up the Policy-based authorization in ASP.NET Core.\n Note: My original intention with this post was to show you how to create dynamic policies by using a custom policy provider. But as I was writing it, I found the need to step back a little and go through the core types/concepts first. It’s a setback from the original plan, but I believe it will pay off.\n TL;DR In this post, I dug deep into the classes/types/services that compose policy-based authorization in ASP.NET Core. I showed each authorization option starting from the most basic and landed on examining step-by-step the work done to authorize a request.\nIf you are just interested in the deep-dive, skip to the Tying everything together section.\nAuthorization in ASP.NET Core ASP.NET Core has several built-in options for authorizing our APIs. They vary in level of complexity/requirements.\nEverything starts with the famous AddAuthorization and UseAuthorization methods we see often in ConfigureServices and Configure, all inside our Startup.cs. Let’s briefly look at them:\nAddAuthorization and UseAuthorization: What for? ConfigureServices: Mostly everything we do inside ConfigureServices has to do with dependency injection. There we have the opportunity to register all the things we will be using across our application via DI. So, what does it mean to call AddAuthorization?\nCalling AddAuthorization() will end up calling AddAuthorizationCore. This method will add to DI all the core and default implementations of several interfaces that comprise the authorization system in ASP.NET Core. We’ll take a closer look at them later on this post.\nConfigure Inside Configure is where we configure the pipeline of our application (AKA middleware). By using UseAuthorization() we are effectively adding the AuthorizationMiddleware to the pipeline. (We’ll also talk about it later).\nThe most important thing from Configure is order matters. Why so, you ask?\nWhen a request arrives, each middleware is invoked in the order they were added inside Configure. When the request is returning, it then passes back again in reverse (stack). The official docs explain it way better than me, so definitely check it out: Middleware order\nWith this information, it should make more sense why our Configure method looked like this in the last post:\n// the rest is omitted for brevity app.UseAuthentication(); app.UseMiddleware(); // our custom permission middleware app.UseAuthorization(); Because our PermissionsMiddleware needs the logged-in user, it has to be added after UseAuthentication. If not, we wouldn’t have the user inside our middleware as authentication would happen later. Similarly, we can’t add UseAuthorization before any of those for similar reasons.\nSimple authorization The simplest way you can authorize your endpoints is by using the [Authorize] attribute. In its basic form, it enforces the request to be at least authenticated. For example: In an API configured to use Bearer token authentication if a request arrives without the token in the header (or an invalid one), it will fail with a 401 Unauthorized.\nHow does this work: Calling AddAuthorization() will register the services we saw earlier. One of them is the AuthorizationOptions which contains a default/fallback policy. If no policy for the endpoint is found, the default one is used in this simple authorization case.\nSummary:\n Pros: It’s simple (if you only need to ensure the request is authenticated) Cons: Pretty much only covers the scenario above.  Read more on the official docs: Simple authorization in ASP.NET Core.\nRole-based authorization The next way we can authorize our endpoints is by using role-based authorization. With role-based, we still use the [Authorize] attribute, but we specify which role(s) are required.\nIn the last post, we created our ClaimsIdentity containing claims with type: permission and the values being the actual permission. With role-based authorization the process is the same. Instead of using permission as the claim type, if we changed it to role we would have something like this:\n// rest omitted for brevity  { \"type\": \"role\", // - changed type to role  \"value\": \"Manager\" } Then we can use the Authorize attribute in our endpoint to allow access only for users in the Manager role:\n[HttpGet(\"secret\")] [Authorize(Roles = \"Manager\")] public IActionResult GetSecretData() { return Ok(\"This is secret data - For managers only!\"); } Again, how this work by just adding the attribute? The AuthorizationMiddleware is invoked and it obtains the endpoint metadata, e.g our Authorize attribute. The middleware then gets a policy by calling the CombineAsync static method in the AuthorizationPolicy class. (Don’t worry too much, we’ll see this in more detail later).\n Tip: Follow the link to the source code above to see how the Role string is extracted and how the policy is created.\n With this, our secret endpoint can only be accessed by users that are in the role Manager.\nSummary:\n Pros: Also simple. If you work with roles already (or intend to, maybe with ASP.NET Identity) this would be a no-brainer. Cons: Not granular enough depending on your use case. Maybe you want only some users in a role to access an endpoint. You would need to create another role just for this case, potentially ending up with a lot of them.  Read more on the official docs: Role-based authorization in ASP.NET Core.\nClaims-based authorization In claims-based authorization, we still use the [Authorize] attribute. The difference now is that we provide a Policy name/string to it. The policy is statically configured and, at the minimum, it verifies if the logged-in user has a claim of the required type. Optionally it can also check the claim’s value.\nFor example: Let’s say you have a store that sells alcoholic beverages. In many countries, it’s common to allow selling alcoholic beverages to people only above a certain age.\n Info: This example is pretty much similar to what they show in the official docs.\n Transporting this requirement to claims-based authorization: We need a claim of type DateOfBirth with its value being the person’s birth date. With this information, we can decide if we can sell or not to this person. In code this means:\n// Startup.cs services.AddAuthorization(options = { options.AddPolicy(\"Over18YearsOld\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"DateOfBirth\" \u0026\u0026 // some custom function to calculate the years  DiffInYears(DateTime.Today, DateTime.Parse(c.Value)) = 18 ))); }) // controller [HttpGet(\"cannot-buy-this\")] [Authorize(Policy = \"Over18YearsOld\")] public IActionResult GetAlhocolicBeverage() { return Ok(\"Bob is enjoying some whisky now!\"); } How does this work? Pretty much the same as in role-based authorization. The AuthorizationMiddleware gets invoked and it obtains the endpoint metadata, e.g our Authorize attribute. But this time, the middleware gets a policy using the name we provided in the attribute, instead of the role.\nWith this, our secret endpoint can only be accessed by users that have the DateOfBirth claim AND are 18+ years old.\nSummary:\n  Pros: More powerful than roles. With the RequireAssertion function you can do a lot and achieve more granular levels of authorization.\n  Cons: IMHO only checking if a claim exists in the Identity is pretty much useless. To make sense of it, you also need to check the value (like we did in the example). That requires you to write the code to check it. That’s not going to scale well even with just a handful of policies.\n  Read more on the official docs: Claims-based authorization in ASP.NET Core.\nQuick recap At this point, we reviewed the “out-of-the-box” authorization options in ASP.NET Core. For me, the key thing about them is that they are simple to use. I mentioned a lot of code and this and that, but to use it, you only need the [Authorize] attribute.\nYou don’t need to know which class calls what and where a policy gets created. You add the attribute, and the framework does all the rest, hiding all that complexity from us.\nBut: When you need to achieve more complex authorization requirements, my experience is that they are not enough.\nIn the next section, I want to dig deeper into things with you. It might seem unnecessary, but it’s crucial for understanding what we’ll be doing in the following posts on the series.\nIt’s also an interesting exercise (at least I think so!) to look into the framework code and understand how things work. It gives you much more confidence in building things.\nSo let’s talk about policies, shall we?\nPolicy based authorization Everything related to authorization in ASP.NET Core orbits around Policies. All the options we discussed so far use the same base types and concepts. In the end, a policy is always involved. Be either by us creating it or the framework doing it for us. To understand how everything works together (and later how we can do more complex things with it), we need to dig deeper.\nThe following are the most relevant types involved in the whole process of authorizing a request:\n AuthorizationPolicy Requirements (IAuthorizationRequirement) Authorization Handlers (IAuthorizationHandler) DefaultAuthorizationService AuthorizationMiddleware PolicyEvaluator  It’s a lot of stuff. Let’s break it down and start with the simpler ones.\nPolicies, requirements and handlers In the last section, we explicitly added a policy Over18YearsOld and configured how it would be evaluated using the RequireAssertion. We also saw an example with role-based authorization, but in that case, a policy was created implicitly by the framework.\nBoth approaches use a AuthorizationPolicy, IAuthorizationRequirement and a IAuthorizationHandler.\nHere is a diagram I made as an attempt to show how these three relate to each other\nPolicies, requirements and handlers  IAuthorizationRequirement A requirement is something (a class/type) a policy and handler(s) can use to authorize the request. A requirement can also contain data.\nFor example: We could create a CanBuyAlcoholicDrinkRequirement which would contain the minimum age required to buy alcoholic beverages as a property. Requirements must implement the IAuthorizationRequirement marker interface. You can create as many requirements as you want in your app.\nAuthorizationPolicy A policy contains one or more requirements. In the case above, we added a requirement via the RequireAssertion method. In the end, calling it will add an AssertionRequirement to the policy for us.\nAnother important point about policies is that they must have a name. The policy name is what the framework uses to locate them later.\nIAuthorizationHandler So far, we know: Policies have requirements. But where are those requirements checked? Where do I put my authorization logic? The answer is Handlers!\nWe create Handlers defining which requirement type it will handle (as the generic arg ). Following the CanBuyAlcoholicDrinkRequirement above, we would have a handler like so:\npublic class BuyAlcoholicDrinkHandler : AuthorizationHandler { protected override Task HandleRequirementAsync( AuthorizationHandlerContext context, CanBuyAlcoholicDrinkRequirement requirement) { // here we would:  // 1 - check if the user has the DateOfBirth claim  // 2 - Check if the user has the minimum required age, using the requirement  } }  We can have more than one handler for the same requirement. This is explained better in the docs: Why would I want multiple handlers for a requirement?.\n The handler needs to implement/override the HandleRequirementAsync method. The method receives two parameters:\n The AuthorizationHandlerContext which contains the User and the requirements needed for the policy to succeed The Requirement instance the handler handles  If our validation check is ok, the handler needs to call context.Succeed(requirement) passing the requirement instance it received as a param. By doing so, the requirement is removed from the AuthorizationHandlerContext.\nIf all requirements are fulfilled, the AuthorizationHandlerContext should have 0 requirements left in the end. That’s how the framework later checks to see if the request is authorized or not.\n The handler can also call context.Fail() to guarantee failure, even if other requirement handlers succeed.\n Another important thing about handlers is that you need to add your custom ones to DI. This is because they are later obtained by the DefaultAuthorizationService. If they are not registered, things will not work as expected. Like so:\nservices.AddSingleton(); Tying everything together Now that we understand better policies, requirements, and handlers, we need to see how they are used. The three “main” services involved in the authorization process are:\n  AuthorizationMiddleware\n  PolicyEvaluator\n  DefaultAuthorizationService\n  I’ll now lay out step-by-step what all these services do. Hang on, it’s going to be looooooong.\n  Everything starts in the AuthorizationMiddleware. First, it finds the endpoint\n  Then it gets the endpoint’s authorization metadata (the Authorize attribute and its data)\n  Then it tries to obtain the Policy by using the authorization data + IAuthorizationPolicyProvider.\n  The CombineAsync method in the AuthorizationPolicy is called. There it tries to find the policy by its name and by the role name. If nothing is found, it checks if it needs to return the default policy. (the case for just using the plain Authorize attribute)\n  Back to the AuthorizationMiddleware, it gets the PolicyEvaluator from DI\n  It invokes the AuthenticateAsync method in the evaluator. This is done to set the ClaimsPrincipal to the User property in the context.\n  If we are still good, the middleware invokes the AuthorizeAsync in the PolicyEvaluator.\n  The PolicyEvaluator then calls the AuthorizeAsync on the DefaultAuthorizationService.\n  The AuthorizeAsync is an ext method inside AuthorizationServiceExtensions. In the end, it will call this overload AuthorizeAsync which receives the user and the policy requirements.\n  Inside AuthorizeAsync an AuthorizationHandlerContext is created\n  Then it gets all the IAuthorizationHandlers from DI and start calling one by one passing the AuthorizationHandlerContext\n  Each IAuthorizationHandler is invoked, and it does the work we described before, either calling Succeed or Fail in the AuthorizationHandlerContext.\n  Once all handlers are invoked, the DefaultAuthorizationService calls the Evaluate method inside the DefaultAuthorizationEvaluator.\n  The DefaultAuthorizationEvaluator returns the appropriate AuthorizationResult depending on properties set in the AuthorizationHandlerContext by the handlers.\n  The DefaultAuthorizationService returns the response to the PolicyEvaluator which then returns either a success or forbid/challenge PolicyAuthorizationResult.\n  The PolicyAuthorizationResult is finally then passed to IAuthorizationMiddlewareResultHandler.\n  Phew! That was a lot wasn’t it? it. I tried many formats to describe the steps, but this was what made the most sense to me when I was trying to understand it. Hopefully, it makes sense to you as well.\nConclusion Let’s recap what we learned in this post.\nI started by explaining the purpose behind the AddAuthorization and UseAuthorization methods we often see in ASP.NET Core apps.\nNext, I introduced the most common (I think?) authorization options in ASP.NET Core. We saw the basic usage of the [Authorize] attribute, then role-based with [Authorize(Roles = \"Manager\")] and finally claims-based [Authorize(Policy = \"Over18YearsOld\")].\nIn the end, we took a deep dive into all the moving parts that compose the architecture of policy-based authorization in ASP.NET Core. In this section, we saw what a request goes through inside the framework to determine if it’s authorized or not.\nI know, it’s a lot to absorb. It took me some time to wrap my head around all of it, so by all means don’t feel bad if none of this makes sense immediately.\nIn my view, the best way to absorb it is by trying it out. Use the branch for this post on GitHub. Check out the UserController to see the types of authorization we discussed here (Swagger should tell you which user to use for each).\nAnother useful tip is to debug the framework code by using Source Link. Check out this post by Steve Gordon to see how: Debugging ASP.NET Core 2.0 Source Code\nAs I mentioned earlier, the original idea with this post was to show how to create policies dynamically by implementing a custom policy provider. But as I was writing it, I realized that there were so many concepts that I didn’t explain before, so I decided to write this deep dive instead. The goal was to give you a good understanding of how everything works, so later when building our custom stuff things are less convoluted.\nIf you feel lost by reading this, feel free to reach out to me on Twitter.\nIn the next post (now for real), we will use all the knowledge acquired here and build our custom policy provider, solving more complex authorization requirements you might face in your real-world apps.\nSee you next time!\nPhoto by mikita amialkovič on Unsplash\n","wordCount":"2788","inLanguage":"en","image":"https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/post-cover.png","datePublished":"2021-03-15T22:30:00Z","dateModified":"2021-03-15T22:30:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>.theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches>
<span class=theme-toggle title="(Alt + T)">
<a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a>
</span>
</span>
</div>
<ul class=menu id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://blog.joaograssi.com/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://blog.joaograssi.com/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://blog.joaograssi.com/series/ title=Series>
<span>Series</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Deep dive into policy-based authorization in ASP.NET Core
</h1>
</header>
<figure class=entry-cover>
<img src=https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/post-cover.png alt="Blue jelly fishes in deep ocean">
</figure>
<div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<blockquote><ul><li>
<a href=#tldr aria-label=TL;DR>TL;DR</a></li><li>
<a href=#authorization-in-aspnet-core aria-label="Authorization in ASP.NET Core">Authorization in ASP.NET Core</a><ul>
<li>
<a href=#addauthorization-and-useauthorization-what-for aria-label="AddAuthorization and UseAuthorization: What for?">AddAuthorization and UseAuthorization: What for?</a><ul>
<li>
<a href=#configureservices aria-label=ConfigureServices:>ConfigureServices:</a></li><li>
<a href=#configure aria-label=Configure>Configure</a></li></ul>
</li><li>
<a href=#simple-authorization aria-label="Simple authorization">Simple authorization</a></li><li>
<a href=#role-based-authorization aria-label="Role-based authorization">Role-based authorization</a></li><li>
<a href=#claims-based-authorization aria-label="Claims-based authorization">Claims-based authorization</a></li></ul>
</li><li>
<a href=#quick-recap aria-label="Quick recap">Quick recap</a></li><li>
<a href=#policy-based-authorization aria-label="Policy based authorization">Policy based authorization</a><ul>
<li>
<a href=#policies-requirements-and-handlers aria-label="Policies, requirements and handlers">Policies, requirements and handlers</a><ul>
<li>
<a href=#iauthorizationrequirement aria-label=IAuthorizationRequirement>IAuthorizationRequirement</a></li><li>
<a href=#authorizationpolicy aria-label=AuthorizationPolicy>AuthorizationPolicy</a></li><li>
<a href=#iauthorizationhandler aria-label=IAuthorizationHandler>IAuthorizationHandler</a></li></ul>
</li><li>
<a href=#tying-everything-together aria-label="Tying everything together">Tying everything together</a></li></ul>
</li><li>
<a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul>
</blockquote>
</details>
</div>
<div class=post-content>
<p>This is the second post in the <a href=/series/authorization-in-asp.net-core>Authorization in ASP.NET Core</a> series.</p>
<ul>
<li>
<p><a href=/posts/2021/asp-net-core-permission-based-authorization-middleware>Part 1: Using a middleware to build a permission-based identity in ASP.NET Core</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-deep-dive-policy-based-authorization>Part 2: Deep dive into policy-based authorization in ASP.NET Core (this post)</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies>Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-testing-permission-protected-api-endpoints>Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core</a></p>
</li>
</ul>
<p>In the previous post, we set the foundation by creating a <code>ClaimsIdentity</code> containing all the logged-in user permissions with the help of a custom middleware.</p>
<p>Before we start using the permissions we built in the last post, I believe it makes sense to review the authorization options the framework provides us and understand how things work under the hood.</p>
<p>So, in this post, we&rsquo;ll start by reviewing the &ldquo;out-of-the-box&rdquo; authorization options in ASP.NET Core. Next, I&rsquo;ll take you on a deep dive on the core components that, together, make up the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-5.0">Policy-based authorization in ASP.NET Core</a>.</p>
<blockquote>
<p>Note: My original intention with this post was to show you how to create dynamic policies by using a custom policy provider. But as I was writing it, I found the need to step back a little and go through the core types/concepts first. It&rsquo;s a setback from the original plan, but I believe it will pay off.</p>
</blockquote>
<h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2>
<p>In this post, I dug deep into the classes/types/services that compose policy-based authorization in ASP.NET Core. I showed each authorization option starting from the most basic and landed on examining step-by-step the work done to authorize a request.</p>
<p>If you are just interested in the deep-dive, skip to the <a href=#tying-everything-together>Tying everything together</a> section.</p>
<h2 id=authorization-in-aspnet-core>Authorization in ASP.NET Core<a hidden class=anchor aria-hidden=true href=#authorization-in-aspnet-core>#</a></h2>
<p>ASP.NET Core has several built-in options for authorizing our APIs. They vary in level of complexity/requirements.</p>
<p>Everything starts with the famous <code>AddAuthorization</code> and <code>UseAuthorization</code> methods we see often in <code>ConfigureServices</code> and <code>Configure</code>, all inside our <code>Startup.cs</code>. Let&rsquo;s briefly look at them:</p>
<h3 id=addauthorization-and-useauthorization-what-for>AddAuthorization and UseAuthorization: What for?<a hidden class=anchor aria-hidden=true href=#addauthorization-and-useauthorization-what-for>#</a></h3>
<h4 id=configureservices>ConfigureServices:<a hidden class=anchor aria-hidden=true href=#configureservices>#</a></h4>
<p>Mostly everything we do inside <code>ConfigureServices</code> has to do with dependency injection. There we have the opportunity to register all the things we will be using across our application via DI. So, what does it mean to call <code>AddAuthorization</code>?</p>
<p>Calling <code>AddAuthorization()</code> will end up calling <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationServiceCollectionExtensions.cs#L21>AddAuthorizationCore</a>. This method will add to DI all the core and default implementations of several interfaces that comprise the authorization system in ASP.NET Core. We&rsquo;ll take a closer look at them later on this post.</p>
<h4 id=configure>Configure<a hidden class=anchor aria-hidden=true href=#configure>#</a></h4>
<p>Inside <code>Configure</code> is where we configure the pipeline of our application (AKA middleware). By using <code>UseAuthorization()</code> we are effectively adding the <code>AuthorizationMiddleware</code> to the pipeline. (We&rsquo;ll also talk about it later).</p>
<p>The most important thing from <code>Configure</code> is <strong>order matters</strong>. Why so, you ask?</p>
<p>When a request arrives, each middleware is invoked in the order they were added inside <code>Configure</code>. When the request is returning, it then passes back again in reverse (stack). The official docs explain it way better than me, so definitely check it out: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#middleware-order">Middleware order</a></p>
<p>With this information, it should make more sense why our <code>Configure</code> method looked like this in the last post:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// the rest is omitted for brevity
</span><span style=color:#75715e></span>app.UseAuthentication();
app.UseMiddleware&lt;PermissionsMiddleware&gt;(); <span style=color:#75715e>// our custom permission middleware
</span><span style=color:#75715e></span>app.UseAuthorization();
</code></pre></div><p>Because our <code>PermissionsMiddleware</code> needs the logged-in user, it has to be added <strong>after</strong> <code>UseAuthentication</code>. If not, we wouldn&rsquo;t have the user inside our middleware as authentication would happen later. Similarly, we can&rsquo;t add <code>UseAuthorization</code> before any of those for similar reasons.</p>
<h3 id=simple-authorization>Simple authorization<a hidden class=anchor aria-hidden=true href=#simple-authorization>#</a></h3>
<p>The simplest way you can authorize your endpoints is by using the <code>[Authorize]</code> attribute. In its basic form, it enforces the request to be <em>at least authenticated</em>. For example: In an API configured to use <code>Bearer token authentication</code> if a request arrives without the token in the header (or an invalid one), it will fail with a <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401>401 Unauthorized</a>.</p>
<p>How does this work: Calling <code>AddAuthorization()</code> will register the services we saw earlier. One of them is the <code>AuthorizationOptions</code> which contains a <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Core/src/AuthorizationOptions.cs#L28>default/fallback policy</a>. If no policy for the endpoint is found, the default one is used in this simple authorization case.</p>
<p>Summary:</p>
<ul>
<li>Pros: It&rsquo;s simple (if you only need to ensure the request is authenticated)</li>
<li>Cons: Pretty much only covers the scenario above.</li>
</ul>
<p>Read more on the official docs: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-5.0">Simple authorization in ASP.NET Core</a>.</p>
<h3 id=role-based-authorization>Role-based authorization<a hidden class=anchor aria-hidden=true href=#role-based-authorization>#</a></h3>
<p>The next way we can authorize our endpoints is by using role-based authorization. With role-based, we still use the <code>[Authorize]</code> attribute, but we specify which role(s) are required.</p>
<p>In the last post, <a href=https://github.com/joaopgrassi/authz-custom-middleware/blob/46ac786a3230b028306140077ffc52b5ca8bb039/src/API/Authorization/UserPermissionService.cs#L41>we created our ClaimsIdentity</a> containing claims with type: <code>permission</code> and the values being the actual permission. With role-based authorization the process is the same. Instead of using <code>permission</code> as the claim type, if we changed it to <code>role</code> we would have something like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#75715e>// rest omitted for brevity
</span><span style=color:#75715e></span>  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;role&#34;</span>, <span style=color:#75715e>// -&gt; changed type to role
</span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;Manager&#34;</span>
  }
</code></pre></div><p>Then we can use the <code>Authorize</code> attribute in our endpoint to allow access only for users in the <code>Manager</code> role:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[HttpGet(&#34;secret&#34;)]</span>
<span style=color:#a6e22e>[Authorize(Roles = &#34;Manager&#34;)]</span>
<span style=color:#66d9ef>public</span> IActionResult GetSecretData()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;This is secret data - For managers only!&#34;</span>);
}
</code></pre></div><p>Again, how this work by just adding the attribute? The <code>AuthorizationMiddleware</code> is invoked and it obtains the endpoint metadata, e.g our <code>Authorize</code> attribute. The middleware then <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L60>gets a policy</a> by calling the CombineAsync static method in the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationPolicy.cs#L156>AuthorizationPolicy</a> class. (Don&rsquo;t worry too much, we&rsquo;ll see this in more detail later).</p>
<blockquote>
<p>Tip: Follow the link to the source code above to see how the <code>Role</code> string is extracted and how the policy is created.</p>
</blockquote>
<p>With this, our <code>secret</code> endpoint can only be accessed by users that are in the role <code>Manager</code>.</p>
<p>Summary:</p>
<ul>
<li>Pros: Also simple. If you work with roles already (or intend to, maybe with ASP.NET Identity) this would be a no-brainer.</li>
<li>Cons: Not granular enough depending on your use case. Maybe you want only <em>some users</em> in a role to access an endpoint. You would need to create another role just for this case, potentially ending up with a lot of them.</li>
</ul>
<p>Read more on the official docs: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/roles?view=aspnetcore-5.0#policy-based-role-checks">Role-based authorization in ASP.NET Core</a>.</p>
<h3 id=claims-based-authorization>Claims-based authorization<a hidden class=anchor aria-hidden=true href=#claims-based-authorization>#</a></h3>
<p>In claims-based authorization, we still use the <code>[Authorize]</code> attribute. The difference now is that we provide a <code>Policy</code> name/string to it. The policy is statically configured and, at the minimum, it verifies if the logged-in user has a claim of the required type. Optionally it can also check the claim&rsquo;s value.</p>
<p>For example: Let&rsquo;s say you have a store that sells alcoholic beverages. In many countries, it&rsquo;s common to allow selling alcoholic beverages to people only above a certain age.</p>
<blockquote>
<p>Info: This example is pretty much similar to what they show in the official docs.</p>
</blockquote>
<p>Transporting this requirement to claims-based authorization: We need a claim of type <code>DateOfBirth</code> with its value being the person&rsquo;s birth date. With this information, we can decide if we can sell or not to this person. In code this means:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Startup.cs
</span><span style=color:#75715e></span>services.AddAuthorization(options =&gt;
{
    options.AddPolicy(<span style=color:#e6db74>&#34;Over18YearsOld&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; 
            c.Type == <span style=color:#e6db74>&#34;DateOfBirth&#34;</span> &amp;&amp;
            <span style=color:#75715e>// some custom function to calculate the years
</span><span style=color:#75715e></span>            DiffInYears(DateTime.Today, DateTime.Parse(c.Value)) &gt;= <span style=color:#ae81ff>18</span>
        )));
})

<span style=color:#75715e>// controller
</span><span style=color:#75715e></span><span style=color:#a6e22e>[HttpGet(&#34;cannot-buy-this&#34;)]</span>
<span style=color:#a6e22e>[Authorize(Policy = &#34;Over18YearsOld&#34;)]</span> 
<span style=color:#66d9ef>public</span> IActionResult GetAlhocolicBeverage()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;Bob is enjoying some whisky now!&#34;</span>);
}
</code></pre></div><p>How does this work? Pretty much the same as in role-based authorization. The <code>AuthorizationMiddleware</code> gets invoked and it obtains the endpoint metadata, e.g our <code>Authorize</code> attribute. But this time, the middleware <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationPolicy.cs#L143>gets a policy using the name we provided in the attribute</a>, instead of the role.</p>
<p>With this, our <code>secret</code> endpoint can only be accessed by users that have the <code>DateOfBirth</code> claim AND are 18+ years old.</p>
<p>Summary:</p>
<ul>
<li>
<p>Pros: More powerful than roles. With the <code>RequireAssertion</code> function you can do a lot and achieve more granular levels of authorization.</p>
</li>
<li>
<p>Cons: IMHO only checking if a claim exists in the Identity is pretty much useless. To make sense of it, you also need to check the value (like we did in the example). That requires you to write the code to check it. That&rsquo;s not going to scale well even with just a handful of policies.</p>
</li>
</ul>
<p>Read more on the official docs: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims?view=aspnetcore-5.0">Claims-based authorization in ASP.NET Core</a>.</p>
<h2 id=quick-recap>Quick recap<a hidden class=anchor aria-hidden=true href=#quick-recap>#</a></h2>
<p>At this point, we reviewed the &ldquo;out-of-the-box&rdquo; authorization options in ASP.NET Core. For me, the key thing about them is that <strong>they are simple to use</strong>. I mentioned a lot of code and this and that, but to use it, you only need the <code>[Authorize]</code> attribute.</p>
<p>You don&rsquo;t need to know which class calls what and where a policy gets created. You add the attribute, and the framework does all the rest, hiding all that complexity from us.</p>
<p><strong>But</strong>: When you need to achieve more complex authorization requirements, my experience is that they are not enough.</p>
<p>In the next section, I want to dig deeper into things with you. It might seem unnecessary, but it&rsquo;s crucial for understanding what we&rsquo;ll be doing in the following posts on the series.</p>
<p>It&rsquo;s also an interesting exercise (at least I think so!) to look into the framework code and understand how things work. It gives you much more confidence in building things.</p>
<p>So let&rsquo;s talk about policies, shall we?</p>
<h2 id=policy-based-authorization>Policy based authorization<a hidden class=anchor aria-hidden=true href=#policy-based-authorization>#</a></h2>
<p>Everything related to authorization in ASP.NET Core orbits around <em>Policies</em>. All the options we discussed so far use the same base types and concepts. In the end, a policy is <strong>always involved</strong>. Be either by us creating it or the framework doing it for us. To understand how everything works together (and later how we can do more complex things with it), we need to dig deeper.</p>
<p>The following are the most relevant types involved in the whole process of authorizing a request:</p>
<ul>
<li><a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationPolicy.cs>AuthorizationPolicy</a></li>
<li>Requirements (<code>IAuthorizationRequirement</code>)</li>
<li>Authorization Handlers (<code>IAuthorizationHandler</code>)</li>
<li><a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs>DefaultAuthorizationService</a></li>
<li><a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs>AuthorizationMiddleware</a></li>
<li><a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/PolicyEvaluator.cs>PolicyEvaluator</a></li>
</ul>
<p>It&rsquo;s a lot of stuff. Let&rsquo;s break it down and start with the simpler ones.</p>
<h3 id=policies-requirements-and-handlers>Policies, requirements and handlers<a hidden class=anchor aria-hidden=true href=#policies-requirements-and-handlers>#</a></h3>
<p>In the last section, we explicitly added a policy <code>Over18YearsOld</code> and configured how it would be evaluated using the <code>RequireAssertion</code>. We also saw an example with role-based authorization, but in that case, a policy was created implicitly by the framework.</p>
<p>Both approaches use a <code>AuthorizationPolicy</code>, <code>IAuthorizationRequirement</code> and a <code>IAuthorizationHandler</code>.</p>
<p>Here is a diagram I made as an attempt to show how these three relate to each other</p>
<figure class=figure-border>
<img class=img-center src=/posts/2021/asp-net-core-deep-dive-policy-based-authorization/policies_requirements.png alt="Policies, requirements and handlers" loading=lazy>
<figcaption class=img-caption>Policies, requirements and handlers</figcaption>
</figure>
<h4 id=iauthorizationrequirement>IAuthorizationRequirement<a hidden class=anchor aria-hidden=true href=#iauthorizationrequirement>#</a></h4>
<p>A requirement is something (a class/type) a policy and handler(s) can use to authorize the request. A requirement can also contain data.</p>
<p>For example: We could create a <code>CanBuyAlcoholicDrinkRequirement</code> which would contain the minimum age required to buy alcoholic beverages as a property. Requirements must implement the <code>IAuthorizationRequirement</code> marker interface. You can create as many requirements as you want in your app.</p>
<h4 id=authorizationpolicy>AuthorizationPolicy<a hidden class=anchor aria-hidden=true href=#authorizationpolicy>#</a></h4>
<p>A policy contains one or more requirements. In the case above, we added a requirement via the <code>RequireAssertion</code> method. In the end, calling it will add an <a href=https://github.com/dotnet/aspnetcore/blob/56e839fb4c8fdf582baf2ce34cde834cae977d1c/src/Security/Authorization/Core/src/AssertionRequirement.cs>AssertionRequirement</a> to the policy for us.</p>
<p>Another important point about policies is that they <strong>must have a name</strong>. The policy name is what the framework uses to locate them later.</p>
<h4 id=iauthorizationhandler>IAuthorizationHandler<a hidden class=anchor aria-hidden=true href=#iauthorizationhandler>#</a></h4>
<p>So far, we know: Policies have requirements. But where are those requirements checked? Where do I put my authorization logic? The answer is <strong>Handlers</strong>!</p>
<p>We create Handlers defining which requirement type it will handle (as the generic arg &lt;>). Following the <code>CanBuyAlcoholicDrinkRequirement</code> above, we would have a handler like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BuyAlcoholicDrinkHandler</span> : AuthorizationHandler&lt;CanBuyAlcoholicDrinkRequirement&gt;
{
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        CanBuyAlcoholicDrinkRequirement requirement)
    {
        <span style=color:#75715e>// here we would:
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 1 - check if the user has the DateOfBirth claim
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 2 - Check if the user has the minimum required age, using the requirement
</span><span style=color:#75715e></span>    }
}

</code></pre></div><blockquote>
<p>We can have more than one handler for the same requirement. This is explained better in the docs: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-5.0#why-would-i-want-multiple-handlers-for-a-requirement">Why would I want multiple handlers for a requirement?</a>.</p>
</blockquote>
<p>The handler needs to implement/override the <code>HandleRequirementAsync</code> method. The method receives two parameters:</p>
<ul>
<li>The <code>AuthorizationHandlerContext</code> which contains the <code>User</code> and the requirements needed for the policy to succeed</li>
<li>The Requirement instance the handler <em>handles</em></li>
</ul>
<p>If our validation check is ok, the handler needs to call <a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/AuthorizationHandlerContext.cs#L95>context.Succeed(requirement)</a> passing the <code>requirement</code> instance it received as a param. By doing so, the requirement is removed from the <code>AuthorizationHandlerContext</code>.</p>
<p>If all requirements are fulfilled, the <code>AuthorizationHandlerContext</code> <a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/DefaultAuthorizationEvaluator.cs#L17><strong>should have 0 requirements left</strong></a> in the end. That&rsquo;s how the framework later checks to see if the request is authorized or not.</p>
<blockquote>
<p>The handler can also call <a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/AuthorizationHandlerContext.cs#L82>context.Fail()</a> to guarantee failure, even if other requirement handlers succeed.</p>
</blockquote>
<p>Another important thing about handlers is that you need to add your custom ones to DI. This is because they are later obtained by the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs#L88>DefaultAuthorizationService</a>. If they are not registered, things will not work as expected. Like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>services.AddSingleton&lt;IAuthorizationHandler, BuyAlcoholicDrinkHandler&gt;();
</code></pre></div><h3 id=tying-everything-together>Tying everything together<a hidden class=anchor aria-hidden=true href=#tying-everything-together>#</a></h3>
<p>Now that we understand better policies, requirements, and handlers, we need to see how they are used. The three &ldquo;main&rdquo; services involved in the authorization process are:</p>
<ul>
<li>
<p><a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs>AuthorizationMiddleware</a></p>
</li>
<li>
<p><a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/PolicyEvaluator.cs>PolicyEvaluator</a></p>
</li>
<li>
<p><a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs>DefaultAuthorizationService</a></p>
</li>
</ul>
<p>I&rsquo;ll now lay out step-by-step what all these services do. Hang on, it&rsquo;s going to be looooooong.</p>
<ol>
<li>
<p>Everything starts in the <code>AuthorizationMiddleware</code>. First, it <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L49>finds the endpoint</a></p>
</li>
<li>
<p>Then it gets the <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L59>endpoint&rsquo;s authorization metadata</a> (the <code>Authorize</code> attribute and its data)</p>
</li>
<li>
<p>Then it <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L60>tries to obtain the Policy</a> by using the authorization data + <code>IAuthorizationPolicyProvider</code>.</p>
</li>
<li>
<p>The <code>CombineAsync</code> method in the <code>AuthorizationPolicy</code> is called. There it tries to find the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationPolicy.cs#L143>policy by its name</a> and <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/AuthorizationPolicy.cs#L152>by the role name</a>. If nothing is found, it checks if it needs to return the default policy. (the case for just using the plain <code>Authorize</code> attribute)</p>
</li>
<li>
<p>Back to the <code>AuthorizationMiddleware</code>, it gets the <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L68>PolicyEvaluator</a> from DI</p>
</li>
<li>
<p>It invokes the <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L70>AuthenticateAsync</a> method in the evaluator. This is done to set the <code>ClaimsPrincipal</code> to the <code>User</code> property in the context.</p>
</li>
<li>
<p>If we are still good, the middleware invokes the <a href=https://github.com/dotnet/aspnetcore/blob/dd7e32a95782401ec22b52f31344e42174cdd538/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L89>AuthorizeAsync</a> in the <code>PolicyEvaluator</code>.</p>
</li>
<li>
<p>The <code>PolicyEvaluator</code> then calls the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/PolicyEvaluator.cs#L87>AuthorizeAsync</a> on the <code>DefaultAuthorizationService</code>.</p>
</li>
<li>
<p>The <code>AuthorizeAsync</code> is an ext method inside <code>AuthorizationServiceExtensions</code>. In the end, it will call this overload <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs#L80>AuthorizeAsync</a> which receives the user and the policy requirements.</p>
</li>
<li>
<p>Inside <code>AuthorizeAsync</code> an <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs#L87>AuthorizationHandlerContext is created</a></p>
</li>
<li>
<p>Then it <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs#L88>gets all the IAuthorizationHandlers</a> from DI and start calling one by one passing the <code>AuthorizationHandlerContext</code></p>
</li>
<li>
<p>Each <code>IAuthorizationHandler</code> is invoked, and it does the work we described before, either calling <code>Succeed</code> or <code>Fail</code> in the <code>AuthorizationHandlerContext</code>.</p>
</li>
<li>
<p>Once all handlers are invoked, the <code>DefaultAuthorizationService</code> calls the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationService.cs#L98>Evaluate method</a> inside the <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Core/src/DefaultAuthorizationEvaluator.cs#L16>DefaultAuthorizationEvaluator</a>.</p>
</li>
<li>
<p>The <code>DefaultAuthorizationEvaluator</code> returns the appropriate <code>AuthorizationResult</code> depending on properties set in the <code>AuthorizationHandlerContext</code> by the handlers.</p>
</li>
<li>
<p>The <code>DefaultAuthorizationService</code> returns the response to the <code>PolicyEvaluator</code> which then returns either a success or forbid/challenge <a href=https://github.com/dotnet/aspnetcore/blob/c925f99cddac0df90ed0bc4a07ecda6b054a0b02/src/Security/Authorization/Policy/src/PolicyEvaluator.cs#L94>PolicyAuthorizationResult</a>.</p>
</li>
<li>
<p>The <code>PolicyAuthorizationResult</code> is finally then passed to <code>IAuthorizationMiddlewareResultHandler</code>.</p>
</li>
</ol>
<p>Phew! That <strong>was a lot</strong> wasn&rsquo;t it? it. I tried many formats to describe the steps, but this was what made the most sense to me when I was trying to understand it. Hopefully, it makes sense to you as well.</p>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Let&rsquo;s recap what we learned in this post.</p>
<p>I started by explaining the purpose behind the <code>AddAuthorization</code> and <code>UseAuthorization</code> methods we often see in ASP.NET Core apps.</p>
<p>Next, I introduced the most common (I think?) authorization options in ASP.NET Core. We saw the basic usage of the <code>[Authorize]</code> attribute, then role-based with <code>[Authorize(Roles = "Manager")]</code> and finally claims-based <code>[Authorize(Policy = "Over18YearsOld")]</code>.</p>
<p>In the end, we took a deep dive into all the moving parts that compose the architecture of policy-based authorization in ASP.NET Core. In this section, we saw what a request goes through inside the framework to determine if it&rsquo;s authorized or not.</p>
<p>I know, it&rsquo;s a lot to absorb. It took me some time to wrap my head around all of it, so by all means don&rsquo;t feel bad if none of this makes sense immediately.</p>
<p>In my view, the best way to absorb it is by trying it out. Use the <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/posts/policy-based-deep-dive>branch for this post on GitHub</a>. Check out the <code>UserController</code> to see the types of authorization we discussed here (Swagger should tell you which user to use for each).</p>
<p>Another useful tip is to debug the framework code by using Source Link. Check out this post by Steve Gordon to see how: <a href=https://www.stevejgordon.co.uk/debugging-asp-net-core-2-source>Debugging ASP.NET Core 2.0 Source Code</a></p>
<p>As I mentioned earlier, the original idea with this post was to show how to create policies dynamically by implementing a custom policy provider. But as I was writing it, I realized that there were so many concepts that I didn&rsquo;t explain before, so I decided to write this deep dive instead. The goal was to give you a good understanding of how everything works, so later when building our custom stuff things are less convoluted.</p>
<p>If you feel lost by reading this, feel free to reach out to me on Twitter.</p>
<p>In the next post (now for real), we will use all the knowledge acquired here and build our custom policy provider, solving more complex authorization requirements you might face in your real-world apps.</p>
<p>See you next time!</p>
<p><a href="https://unsplash.com/@nicita13?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Photo by mikita amialkovič</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li>
<li><a href=https://blog.joaograssi.com/tags/authorization/>authorization</a></li>
<li><a href=https://blog.joaograssi.com/tags/security/>security</a></li>
<li><a href=https://blog.joaograssi.com/tags/middleware/>middleware</a></li>
<li><a href=https://blog.joaograssi.com/tags/role-based/>role-based</a></li>
<li><a href=https://blog.joaograssi.com/tags/claims-based/>claims-based</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>