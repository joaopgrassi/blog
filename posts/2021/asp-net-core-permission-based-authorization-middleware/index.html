<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using a middleware to build a permission-based identity in ASP.NET Core | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,identityserver,authorization,security,permissions"><meta name=description content="In this post I'll demonstrate how to use a custom middleware to create a ClaimsIdentity containing the logged-in user permissions. Later, the identity is used for endpoint authorization."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.ad3c9feff2635cbeec1afaf551499579aea970ed57152b4b8eb70d9e0c002bbd.css integrity="sha256-rTyf7/JjXL7sGvr1UUmVea6pcO1XFStLjrcNngwAK70=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><meta property="og:title" content="Using a middleware to build a permission-based identity in ASP.NET Core"><meta property="og:description" content="In this post I'll demonstrate how to use a custom middleware to create a ClaimsIdentity containing the logged-in user permissions. Later, the identity is used for endpoint authorization."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/"><meta property="og:image" content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/post-cover.png"><meta property="article:published_time" content="2021-03-06T16:30:00+00:00"><meta property="article:modified_time" content="2021-03-06T16:30:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/post-cover.png"><meta name=twitter:title content="Using a middleware to build a permission-based identity in ASP.NET Core"><meta name=twitter:description content="In this post I'll demonstrate how to use a custom middleware to create a ClaimsIdentity containing the logged-in user permissions. Later, the identity is used for endpoint authorization."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using a middleware to build a permission-based identity in ASP.NET Core","name":"Using a middleware to build a permission-based identity in ASP.NET Core","description":"This post is the first in a series about Authorization in ASP.NET Core. I\u0026amp;rsquo;ll guide you through a series of approaches you can use to implement authorization in your ASP.NET ‚Ä¶","keywords":["asp.net-core","identityserver","authorization","security","permissions"],"articleBody":"This post is the first in a series about Authorization in ASP.NET Core. I‚Äôll guide you through a series of approaches you can use to implement authorization in your ASP.NET Core APIs, focusing on advanced/real-world scenarios. Here‚Äôs a sneak peek for what I plan to show you:\n Where to store and resolve authorization-like data How to protect your API endpoints using permission-based authorization using the built-in types in the framework Reduce duplication and make things smarter by implementing a custom Authentication Handler. Mocking authentication/authorization during your integration tests  In this first post, I‚Äôll demonstrate how can we use a middleware to build a ClaimsIdentity which contains all the permissions of the logged-in user. This is the foundation for the next posts where we will use the permissions to authorize the endpoints. I‚Äôll also talk a bit about JWT tokens and if it‚Äôs a good idea to include authorization-related claims in them.\n Note: The words Authentication and Authorization are very similar and long to type, so I‚Äôll refer to them in the post using their abbreviations: authn and authz. It‚Äôs also common to see these abbreviations when researching around this topic.\n TL;DR (show me the code) Using a middleware to build a ClaimsIdentity containing all the user permissions read from the database. No authz data present in the JWT token.\nThe code on GitHub - PermissionsMiddleware.cs.\nYou can check this branch to see the repo in the state when this post was published.\nShould I include ‚Äúauthz like‚Äù claims in my JWT Tokens? Short answer: Probably not.\nLong version: JWT authn is very common these days and also relatively easy to implement if you already have a security token service in place (STS, E.g. Identity Server). When talking about this topic, very often there‚Äôs some confusion between Authentication and Authorization, so let‚Äôs clear that a bit:\nAuthentication (authn) is the process of validating that a user is, in fact, who they claim to be. Authorization (authz) is the process of validating what the user is allowed to do in the system. Follow up this article if you want to dig more into this.\nIn token-based authn, the user gets a token which is the proof that they are who they claim to be (assuming the STS is doing its job well). Inside the token, you can find things like the user e-mail, their names, some id (sub), and more. But here is where things get a bit complicated though.\nBasically, with a JWT token, you have everything you need 1. to process and authenticate the request, no need to communicate with any other service. This is, of course, very convenient, and it‚Äôs mostly the reason why it‚Äôs common to see authz-like data in the token. Take this token for example:\n{ \"sub\": \"abc-123\", \"name\": \"John\", \"role\": \"developer\", \"exp\": \"1606595460\", } See the role claim there? That is what we could identify as authorization data. Other examples might be individual permissions like: Create and Delete. So you might be asking yourself now: why is this not recommended?\nWhy not include authz data in JWT tokens   Size: a Token takes space like everything. If we add authz claims there, it could easily get big and cause all sorts of problems. One example is that JWT tokens are sent in HTTP headers and some servers have limits on the size.\n  Context: Each app has its requirements: As we saw, a token proves the user identity. The same token could be used to communicate with different applications. If we have authz claims in the token it might make sense for one app, but not for the other. The context in which the token is used might be different, but the user behind it is the same.\n  Security: Permissions can change quickly but tokens live for a while (usually 1 hour): If we put authz data in the token, we are risking letting the user access things that they shouldn‚Äôt. A common example is: Imagine someone is fired and they have a token with sys_admin permission which is valid for one hour. They could do anything with it in the system. Not very secure, I‚Äôd say üòÖ.\n  Ok - so hopefully that cleared things a bit and we know why it‚Äôs not a good idea to store authz data in JWT tokens. Let‚Äôs move on!\nWhere should I put my authz data then? Short answer: As close as possible to your app. See the next session for an example.\nLong answer:\nWe discussed above the word Context and it‚Äôs a very important word in this topic. Permissions/Roles, etc should be as close as possible to each application. It‚Äôs part of the domain of your app.\nThe app should know how to authorize things, so it‚Äôs only logical that the permission/role ‚Äúlookup‚Äù for the individual user happens in the context of the app, not someplace else.\nTake this example: You probably used an app that offered an option to sign in with Google or Facebook. Do you think Facebook/Google or any other OpenId/OAuth provider will know (or care) about your app‚Äôs authorization? I don‚Äôt think so. Makes no sense, right?\n ‚Äúapp‚Äù here is a generic term. It could be your API, a process, a mobile app or a website. It doesn‚Äôt matter. The concept is still the same for all.\n So, where should we put the authorization data? As close as possible to our app!\nSimple model for authorization We will be using a simple model to keep things straightforward, yet you can achieve a lot. Plus, you can extend it to accommodate more complex scenarios. The entities below are the foundation for the authorization of our API.\nEntities for a simple permission-based authorization  The idea is that our API has the concept of Users, Permissions, and the User permissions.\n User: The users in the system Permission: All the permissions present in the system. Here you can define the granularity you want UserPermission: The mapping which tells us what permissions a given user has   This post assumes the users are created and their permissions are configured in the system. Since this can be done in several ways it‚Äôs not the focus of this series.\n Let‚Äôs see now how these entities are used.\nBuilding a permissions identity With the entities in place, we have all we need to create the middleware that will construct the ClaimsIdentity. But first, let me explain briefly what a ClaimsIdentity is. (if you know already, you can skip to the next session).\nClaims identity - what?? In ASP.NET we have the famous HttpContext. The HttpContext is where we can find everything related to the request/response, including, of course, the logged-in user in the property User (type of ClaimsPrincipal).\nIn this series we‚Äôll be using an API that is protected by JWT Bearer authentication. By configuring JWT Bearer authentication, the framework does all the work of validating the incoming JWT tokens for us.\nThe token validation happens in the JwtBearerHandler. If the token is valid, a ClaimsPrincipal is created and added to the context. The principal contains a lot of information, but the relevant part for us here is the Claims list property. In the claims list we will find all the data that was in the JWT token (email, name, etc).\nReading the Claims property in the ClaimsPrincipal will ultimately iterate through all the ClaimsIdentity, producing a ‚Äúflat‚Äù list with all the Claims combined. This is the important part for us. We will create a new ClaimsIdentity that will contain all the user permissions as Claims.\nYou can see it like a 1:N relationship between a ClaimsPrincipal and ClaimsIdentity. The principal can have many identities and that‚Äôs exactly what we will be doing next.\nDon‚Äôt feel bad if all this seems complicated. Hopefully, the next section will clear things up.\nThe permissions middleware The goal of our middleware is to create a ClaimsIdentity containing all the user permissions as Claim. With this built and added to the HttpContext we can use the built-in policy-based authorization the ASP.NET Core framework gives us.\nIf you look closer to the source code for ClaimsPrincipal we can see that the Claims is an IEnumerable and its getter just iterates through all the ClaimsIdentity claims, and that is also an IEnumerable with no setter. All this means we can‚Äôt add new Claims to identity after it‚Äôs created. Immutability ftw!\nAnother benefit from this design is Separation of concerns. Having a separate identity to hold the permissions gives us a clear separation between their identity (who they are) and their permissions (what they can do).\nI think it‚Äôs enough talking. Let‚Äôs see the code:\nusing AuthUtils; using Microsoft.AspNetCore.Http; using Microsoft.Extensions.Logging; using System.Threading.Tasks; namespace API.Authorization { public class PermissionsMiddleware { private readonly RequestDelegate _next; private readonly ILogger _logger; public PermissionsMiddleware( RequestDelegate next, ILogger logger) { _next = next; _logger = logger; } public async Task InvokeAsync( HttpContext context, IUserPermissionService permissionService) { // 1 - if the request is not authenticated, nothing to do  if (context.User.Identity == null || !context.User.Identity.IsAuthenticated) { await _next(context); return; } var cancellationToken = context.RequestAborted; // 2. The 'sub' claim is how we find the user in our system  var userSub = context.User.FindFirst(StandardJwtClaimTypes.Subject)?.Value; if (string.IsNullOrEmpty(userSub)) { await context.WriteAccessDeniedResponse( \"User 'sub' claim is required\", cancellationToken: cancellationToken); return; } // 3 - Now we try to get the user permissions (as ClaimsIdentity)  var permissionsIdentity = await permissionService .GetUserPermissionsIdentity(userSub, cancellationToken); if (permissionsIdentity == null) { _logger.LogWarning(\"User {sub} does not have permissions\", userSub); await context.WriteAccessDeniedResponse(cancellationToken: cancellationToken); return; } // 4 - User has permissions  // so we add the extra identity to the ClaimsPrincipal  context.User.AddIdentity(permissionsIdentity); await _next(context); } } } Let‚Äôs break it down:\n If the request is not authenticated there‚Äôs nothing we can do, so just continue.   The request can be unauthenticated. For example, if you have a Swagger UI for your API. When you first browse it you are not logged in.\n Try to find the sub claim in the Claims list we talked before. The sub is used here to find the user in our Users table. If it‚Äôs not there, we return a 403 status.   I used the sub to find the user here, but you can use other values in your app.\n  With the sub in hand, we then join our tables Users, Permissions, UserPermissions to find the user permissions. If we find any, a ClaimsIdentity is built by the GetUserPermissionsIdentity method I created. All the permissions are now Claims inside.\n  If we reach this far, the user has at least 1 permission. So we add the extra ClaimsIdentity to the ClaimsPrincipal, using the AddIdentity method.\n  Let‚Äôs test it! Given this data in our database\n To keep things easy to read, I used ints here. In the GitHub repo you‚Äôll see Guids.\n Permissions\n   Id Name     1 Create   2 Update   3 Delete    Users\n   Id ExternalId Email     1 88421113 bobsmith@email.com    UserPermissions\n   Id UserId PermissionId     1 1 1   2 1 2    And a controller with the following code:\nusing System.Linq; using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Mvc; namespace API.Controllers { [Authorize] [ApiController] [Route(\"users\")] public class UserController : ControllerBase { [HttpGet(\"me\")] public IActionResult Get() { // return all the user claims in all identities  return Ok(User.Claims.Select(c = new {c.Type, c.Value})); } } } We get this response: (some values were removed for brevity)\n[ { \"type\": \"sub\", \"value\": \"88421113\" }, { \"type\": \"name\", \"value\": \"Bob Smith\" }, { \"type\": \"email\", \"value\": \"BobSmith@email.com\" }, { \"type\": \"permissions\", \"value\": \"Update\" }, { \"type\": \"permissions\", \"value\": \"Create\" } ] See the last two permissions values: Create and Update? Those were added by our middleware! Cool, huh?\n You can also check the integration I created. I‚Äôll explain testing in later posts but it‚Äôs a good point to debug and see how things work.\n Conclusion We started the post by discussing the differences between Authentication \u0026 Authorization and why it‚Äôs considered a bad idea to include authorization-like data in JWT tokens.\nNext, I showed you a simple model for permission-based authorization, and a custom middleware responsible for creating a ClaimsIdentity containing all the user permissions.\nComing up next, we‚Äôll see how we can use the built-in policy authorization in ASP.NET Core to protect our endpoints with the permissions we prepared in this post.\nSome of the topics here might be new to you (or not so clear?), so I encourage you to clone the project on GitHub and debug it to see how things work. The most important part for this post is the Middleware: PermissionsMiddleware.cs. Pay attention to where we fetch the permissions. Inspect the context.User property to see all the stuff inside.\n Check the README.md for instructions on how to run the project locally* üòâ\n See you next time. Stay safe! ‚úã\nPhoto by Dimitri Houtteman on Unsplash\n  You app still needs to fetch the public keys from the STS to validate the signature of the tokens. Libraries do that for you in the background so you don‚Äôt have to worry. In some other cases you might need/want to validate the token everytime. See Reference Tokens ‚Ü©Ô∏é\n   ","wordCount":"2161","inLanguage":"en","image":"https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/post-cover.png","datePublished":"2021-03-06T16:30:00Z","dateModified":"2021-03-06T16:30:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Using a middleware to build a permission-based identity in ASP.NET Core</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/post-cover.png alt="No trespassing sign"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#tldr-show-me-the-code aria-label="TL;DR (show me the code)">TL;DR (show me the code)</a></li><li><a href=#should-i-include-authz-like-claims-in-my-jwt-tokens aria-label="Should I include &amp;ldquo;authz like&amp;rdquo; claims in my JWT Tokens?">Should I include &ldquo;authz like&rdquo; claims in my JWT Tokens?</a><ul><li><a href=#why-not-include-authz-data-in-jwt-tokens aria-label="Why not include authz data in JWT tokens">Why not include authz data in JWT tokens</a></li><li><a href=#where-should-i-put-my-authz-data-then aria-label="Where should I put my authz data then?">Where should I put my authz data then?</a></li></ul></li><li><a href=#simple-model-for-authorization aria-label="Simple model for authorization">Simple model for authorization</a></li><li><a href=#building-a-permissions-identity aria-label="Building a permissions identity">Building a permissions identity</a><ul><li><a href=#claims-identity---what aria-label="Claims identity - what??">Claims identity - what??</a></li><li><a href=#the-permissions-middleware aria-label="The permissions middleware">The permissions middleware</a></li><li><a href=#lets-test-it aria-label="Let&amp;rsquo;s test it!">Let&rsquo;s test it!</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></blockquote></details></div><div class=post-content><p>This post is the first in a series about <a href=/series/authorization-in-asp.net-core>Authorization in ASP.NET Core</a>. I&rsquo;ll guide you through a series of approaches you can use to implement authorization in your ASP.NET Core APIs, focusing on advanced/real-world scenarios. Here&rsquo;s a sneak peek for what I plan to show you:</p><ul><li>Where to store and resolve authorization-like data</li><li>How to protect your API endpoints using permission-based authorization using the built-in types in the framework</li><li>Reduce duplication and make things smarter by implementing a custom Authentication Handler.</li><li>Mocking authentication/authorization during your integration tests</li></ul><p>In this first post, I&rsquo;ll demonstrate how can we use a middleware to build a <code>ClaimsIdentity</code> which contains all the permissions of the logged-in user. This is the foundation for the next posts where we will use the permissions to authorize the endpoints. I&rsquo;ll also talk a bit about JWT tokens and if it&rsquo;s a good idea to include authorization-related claims in them.</p><blockquote><p>Note: The words <code>Authentication</code> and <code>Authorization</code> are very similar and long to type, so I&rsquo;ll refer to them in the post using their abbreviations: <code>authn</code> and <code>authz</code>. It&rsquo;s also common to see these abbreviations when researching around this topic.</p></blockquote><h2 id=tldr-show-me-the-code>TL;DR (show me the code)<a hidden class=anchor aria-hidden=true href=#tldr-show-me-the-code>#</a></h2><p>Using a middleware to build a <code>ClaimsIdentity</code> containing all the user permissions read from the database. No authz data present in the JWT token.</p><p>The code on <a href=https://github.com/joaopgrassi/authz-custom-middleware/blob/posts/asp-net-core-permissions-authorization-middleware/src/API/Authorization/PermissionsMiddleware.cs>GitHub - PermissionsMiddleware.cs</a>.</p><p>You can check this <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/posts/asp-net-core-permissions-authorization-middleware>branch</a> to see the repo in the state when this post was published.</p><h2 id=should-i-include-authz-like-claims-in-my-jwt-tokens>Should I include &ldquo;authz like&rdquo; claims in my JWT Tokens?<a hidden class=anchor aria-hidden=true href=#should-i-include-authz-like-claims-in-my-jwt-tokens>#</a></h2><p><strong>Short answer</strong>: Probably not.</p><p><strong>Long version</strong>: JWT authn is very common these days and also relatively easy to implement if you already have a security token service in place (STS, E.g. Identity Server). When talking about this topic, very often there&rsquo;s some confusion between <em>Authentication</em> and <em>Authorization</em>, so let&rsquo;s clear that a bit:</p><p><strong>Authentication (authn)</strong> is the process of validating that a user is, in fact, <em>who they claim to be</em>. <strong>Authorization (authz)</strong> is the process of validating what the user is <em>allowed to do</em> in the system. Follow up <a href=https://www.okta.com/identity-101/authentication-vs-authorization/>this article</a> if you want to dig more into this.</p><p>In token-based authn, the user gets a token which is the proof that they are who they claim to be (assuming the STS is doing its job well). Inside the token, you can find things like the user e-mail, their names, some id (sub), and more. But here is where things get a bit complicated though.</p><p>Basically, with a JWT token, you have everything you need <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. to process and <em>authenticate</em> the request, no need to communicate with any other service. This is, of course, very convenient, and it&rsquo;s mostly the reason why it&rsquo;s common to see <strong>authz-like</strong> data in the token.
Take this token for example:</p><pre><code>{
  &quot;sub&quot;: &quot;abc-123&quot;,
  &quot;name&quot;: &quot;John&quot;,
  &quot;role&quot;: &quot;developer&quot;,
  &quot;exp&quot;: &quot;1606595460&quot;,
}
</code></pre><p>See the <code>role</code> claim there? That is what we could identify as authorization data. Other examples might be individual permissions like: <code>Create</code> and <code>Delete</code>. So you might be asking yourself now: why is this not recommended?</p><h3 id=why-not-include-authz-data-in-jwt-tokens>Why not include authz data in JWT tokens<a hidden class=anchor aria-hidden=true href=#why-not-include-authz-data-in-jwt-tokens>#</a></h3><ul><li><p><strong>Size</strong>: a Token takes space like everything. If we add authz claims there, it could easily get big and cause all sorts of problems. One example is that JWT tokens are sent in HTTP headers and some servers have limits on the size.</p></li><li><p><strong>Context</strong>: Each app has its requirements: As we saw, a token proves the user identity. The same token <em>could</em> be used to communicate with different applications. If we have authz claims in the token it might make sense for one app, but not for the other. The context in which the token is used might be different, but the user behind it is the same.</p></li><li><p><strong>Security</strong>: Permissions can change quickly but tokens live for a while (usually 1 hour): If we put authz data in the token, we are risking letting the user access things that they shouldn&rsquo;t. A common example is: Imagine someone is fired and they have a token with <code>sys_admin</code> permission which is valid for one hour. They could do anything with it in the system. Not very secure, I&rsquo;d say üòÖ.</p></li></ul><p>Ok - so hopefully that cleared things a bit and we know why it&rsquo;s not a good idea to store authz data in JWT tokens. Let&rsquo;s move on!</p><h3 id=where-should-i-put-my-authz-data-then>Where should I put my authz data then?<a hidden class=anchor aria-hidden=true href=#where-should-i-put-my-authz-data-then>#</a></h3><p><strong>Short answer</strong>: As close as possible to your app. See the next session for an example.</p><p><strong>Long answer</strong>:</p><p>We discussed above the word <strong>Context</strong> and it&rsquo;s a very important word in this topic. Permissions/Roles, etc <em>should</em> be as close as possible to each application. It&rsquo;s part of the domain of your app.</p><p>The app should know how to authorize things, so it&rsquo;s only logical that the permission/role &ldquo;lookup&rdquo; for the individual user happens in the <em>context</em> of the app, not someplace else.</p><p>Take this example: You probably used an app that offered an option to sign in with Google or Facebook. Do you think Facebook/Google or any other OpenId/OAuth provider will know (or care) about your app&rsquo;s authorization? I don&rsquo;t think so. Makes no sense, right?</p><blockquote><p>&ldquo;app&rdquo; here is a generic term. It could be your API, a process, a mobile app or a website. It doesn&rsquo;t matter. The concept is still the same for all.</p></blockquote><p>So, where should we put the authorization data? As close as possible to our app!</p><h2 id=simple-model-for-authorization>Simple model for authorization<a hidden class=anchor aria-hidden=true href=#simple-model-for-authorization>#</a></h2><p>We will be using a simple model to keep things straightforward, yet you can achieve a lot. Plus, you can extend it to accommodate more complex scenarios. The entities below are the foundation for the authorization of our API.</p><figure class=figure-border><img class=img-center src=/posts/2021/asp-net-core-permission-based-authorization-middleware/class_diagram.png alt="Entities for a simple permission-based authorization" loading=lazy><figcaption class=img-caption>Entities for a simple permission-based authorization</figcaption></figure><p>The idea is that our API has the concept of <code>Users</code>, <code>Permissions</code>, and the <code>User permissions</code>.</p><ul><li><strong>User</strong>: The users in the system</li><li><strong>Permission</strong>: All the permissions present in the system. Here you can define the granularity you want</li><li><strong>UserPermission</strong>: The mapping which tells us what permissions a given user has</li></ul><blockquote><p>This post assumes the users are created and their permissions are configured in the system. Since this can be done in several ways it&rsquo;s not the focus of this series.</p></blockquote><p>Let&rsquo;s see now how these entities are used.</p><h2 id=building-a-permissions-identity>Building a permissions identity<a hidden class=anchor aria-hidden=true href=#building-a-permissions-identity>#</a></h2><p>With the entities in place, we have all we need to create the middleware that will construct the <code>ClaimsIdentity</code>. But first, let me explain briefly what a <code>ClaimsIdentity</code> is. (if you know already, you can skip to the next session).</p><h3 id=claims-identity---what>Claims identity - what??<a hidden class=anchor aria-hidden=true href=#claims-identity---what>#</a></h3><p>In ASP.NET we have the famous <code>HttpContext</code>. The <code>HttpContext</code> is where we can find everything related to the request/response, including, of course, the logged-in user in the property <code>User</code> (type of ClaimsPrincipal).</p><p>In this series we&rsquo;ll be using an API that is protected by <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-5.0">JWT Bearer authentication</a>. By configuring JWT Bearer authentication, the framework does all the work of validating the incoming JWT tokens for us.</p><p>The token validation happens in the <a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs>JwtBearerHandler</a>. If the token is valid, a <code>ClaimsPrincipal</code> is created and added to the context. The principal contains a lot of information, but the relevant part for us here is the <a href=https://github.com/microsoft/referencesource/blob/master/mscorlib/system/security/claims/ClaimsPrincipal.cs#L508>Claims list property</a>. In the claims list we will find all the data that was in the JWT token (email, name, etc).</p><p>Reading the <code>Claims</code> property in the <code>ClaimsPrincipal</code> will ultimately iterate through all the <code>ClaimsIdentity</code>, producing a &ldquo;flat&rdquo; list with all the <code>Claims</code> combined. This is the important part for us. We will create a new <code>ClaimsIdentity</code> that will contain all the user permissions as <code>Claims</code>.</p><p>You can see it like a 1:N relationship between a <code>ClaimsPrincipal</code> and <code>ClaimsIdentity</code>. The principal can have many identities and that&rsquo;s exactly what we will be doing next.</p><p>Don&rsquo;t feel bad if all this seems complicated. Hopefully, the next section will clear things up.</p><h3 id=the-permissions-middleware>The permissions middleware<a hidden class=anchor aria-hidden=true href=#the-permissions-middleware>#</a></h3><p>The goal of our middleware is to create a <code>ClaimsIdentity</code> containing all the user permissions as <code>Claim</code>. With this built and added to the <code>HttpContext</code> we can use the built-in policy-based authorization the ASP.NET Core framework gives us.</p><p>If you look closer to the source code for <a href=https://github.com/microsoft/referencesource/blob/master/mscorlib/system/security/claims/ClaimsPrincipal.cs#L508>ClaimsPrincipal</a> we can see that the <code>Claims</code> is an <code>IEnumerable</code> and its getter just iterates through all the <code>ClaimsIdentity</code> claims, and that is also an <code>IEnumerable</code> with no setter. All this means we can&rsquo;t add new <code>Claims</code> to identity after it&rsquo;s created. Immutability ftw!</p><p>Another benefit from this design is <strong>Separation of concerns</strong>. Having a separate identity to hold the permissions gives us a clear separation between their <em>identity</em> (who they are) and their permissions (what they can do).</p><p>I think it&rsquo;s enough talking. Let&rsquo;s see the code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> AuthUtils;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Http;
<span style=color:#66d9ef>using</span> Microsoft.Extensions.Logging;
<span style=color:#66d9ef>using</span> System.Threading.Tasks;

<span style=color:#66d9ef>namespace</span> API.Authorization
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionsMiddleware</span>
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> RequestDelegate _next;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ILogger&lt;PermissionsMiddleware&gt; _logger;

        <span style=color:#66d9ef>public</span> PermissionsMiddleware(
            RequestDelegate next,
            ILogger&lt;PermissionsMiddleware&gt; logger)
        {
            _next = next;
            _logger = logger;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task InvokeAsync(
            HttpContext context, IUserPermissionService permissionService)
        {
            <span style=color:#75715e>// 1 - if the request is not authenticated, nothing to do
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (context.User.Identity == <span style=color:#66d9ef>null</span> || !context.User.Identity.IsAuthenticated)
            {
                <span style=color:#66d9ef>await</span> _next(context);
                <span style=color:#66d9ef>return</span>;
            }

            <span style=color:#66d9ef>var</span> cancellationToken = context.RequestAborted;

            <span style=color:#75715e>// 2. The &#39;sub&#39; claim is how we find the user in our system
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> userSub = context.User.FindFirst(StandardJwtClaimTypes.Subject)?.Value;
            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>string</span>.IsNullOrEmpty(userSub))
            {
                <span style=color:#66d9ef>await</span> context.WriteAccessDeniedResponse(
                  <span style=color:#e6db74>&#34;User &#39;sub&#39; claim is required&#34;</span>, 
                  cancellationToken: cancellationToken);
                <span style=color:#66d9ef>return</span>;
            }

            <span style=color:#75715e>// 3 - Now we try to get the user permissions (as ClaimsIdentity)
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> permissionsIdentity = <span style=color:#66d9ef>await</span> permissionService
                .GetUserPermissionsIdentity(userSub, cancellationToken);
            <span style=color:#66d9ef>if</span> (permissionsIdentity == <span style=color:#66d9ef>null</span>)
            {
                _logger.LogWarning(<span style=color:#e6db74>&#34;User {sub} does not have permissions&#34;</span>, userSub);

                <span style=color:#66d9ef>await</span> context.WriteAccessDeniedResponse(cancellationToken: cancellationToken);
                <span style=color:#66d9ef>return</span>;
            }

            <span style=color:#75715e>// 4 - User has permissions
</span><span style=color:#75715e></span>            <span style=color:#75715e>// so we add the extra identity to the ClaimsPrincipal
</span><span style=color:#75715e></span>            context.User.AddIdentity(permissionsIdentity);
            <span style=color:#66d9ef>await</span> _next(context);
        }
    }
}
</code></pre></div><p>Let&rsquo;s break it down:</p><ol><li>If the request is not <em>authenticated</em> there&rsquo;s nothing we can do, so just continue.</li></ol><blockquote><p><em>The request can be unauthenticated. For example, if you have a Swagger UI for your API. When you first browse it you are not logged in.</em></p></blockquote><ol start=2><li>Try to find the <code>sub</code> claim in the <code>Claims</code> list we talked before. The <code>sub</code> is used here to find the user in our <code>Users</code> table. If it&rsquo;s not there, we return a <code>403</code> status.</li></ol><blockquote><p><em>I used the <code>sub</code> to find the user here, but you can use other values in your app.</em></p></blockquote><ol start=3><li><p>With the <code>sub</code> in hand, we then join our tables <code>Users, Permissions, UserPermissions</code> to find the user permissions. If we find any, a <code>ClaimsIdentity</code> is built by the <code>GetUserPermissionsIdentity</code> method I created. All the permissions are now <code>Claims</code> inside.</p></li><li><p>If we reach this far, the user has at least 1 permission. So we add the extra <code>ClaimsIdentity</code> to the <code>ClaimsPrincipal</code>, using the <a href=https://github.com/microsoft/referencesource/blob/master/mscorlib/system/security/claims/ClaimsPrincipal.cs#L477>AddIdentity</a> method.</p></li></ol><h3 id=lets-test-it>Let&rsquo;s test it!<a hidden class=anchor aria-hidden=true href=#lets-test-it>#</a></h3><p>Given this data in our database</p><blockquote><p>To keep things easy to read, I used <code>ints</code> here. In the GitHub repo you&rsquo;ll see <code>Guids</code>.</p></blockquote><p><strong>Permissions</strong></p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Create</td></tr><tr><td>2</td><td>Update</td></tr><tr><td>3</td><td>Delete</td></tr></tbody></table><p><strong>Users</strong></p><table><thead><tr><th>Id</th><th>ExternalId</th><th>Email</th></tr></thead><tbody><tr><td>1</td><td>88421113</td><td><a href=mailto:bobsmith@email.com>bobsmith@email.com</a></td></tr></tbody></table><p><strong>UserPermissions</strong></p><table><thead><tr><th>Id</th><th>UserId</th><th>PermissionId</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr></tbody></table><p>And a controller with the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> System.Linq;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Authorization;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Mvc;

<span style=color:#66d9ef>namespace</span> API.Controllers
{
<span style=color:#a6e22e>    [Authorize]</span>
<span style=color:#a6e22e>    [ApiController]</span>
<span style=color:#a6e22e>    [Route(&#34;users&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> : ControllerBase
    {
<span style=color:#a6e22e>        [HttpGet(&#34;me&#34;)]</span>
        <span style=color:#66d9ef>public</span> IActionResult Get()
        {
            <span style=color:#75715e>// return all the user claims in all identities
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> Ok(User.Claims.Select(c =&gt; <span style=color:#66d9ef>new</span> {c.Type, c.Value}));
        }
    }
}
</code></pre></div><p>We get this response: (some values were removed for brevity)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;sub&#34;</span>,
    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;88421113&#34;</span>
  },
  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;name&#34;</span>,
    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;Bob Smith&#34;</span>
  },
  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;email&#34;</span>,
    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;BobSmith@email.com&#34;</span>
  },
  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;permissions&#34;</span>,
    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;Update&#34;</span>
  },
  {
    <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;permissions&#34;</span>,
    <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;Create&#34;</span>
  }
]
</code></pre></div><p>See the last two <code>permissions</code> values: <code>Create</code> and <code>Update</code>? Those were added by our middleware! Cool, huh?</p><blockquote><p>You can also check the integration I created. I&rsquo;ll explain testing in later posts but it&rsquo;s a good point to debug and see how things work.</p></blockquote><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We started the post by discussing the differences between <strong>Authentication</strong> & <strong>Authorization</strong> and why it&rsquo;s considered a bad idea to include authorization-like data in JWT tokens.</p><p>Next, I showed you a simple model for permission-based authorization, and a custom middleware responsible for creating a <code>ClaimsIdentity</code> containing all the user permissions.</p><p>Coming up next, we&rsquo;ll see how we can use the built-in policy authorization in ASP.NET Core to protect our endpoints with the permissions we prepared in this post.</p><p>Some of the topics here might be new to you (or not so clear?), so I encourage you to clone the project on GitHub and debug it to see how things work. The most important part for this post is the Middleware: <a href=https://github.com/joaopgrassi/authz-custom-middleware/blob/main/src/API/Authorization/PermissionsMiddleware.cs>PermissionsMiddleware.cs</a>. Pay attention to where we fetch the permissions. Inspect the <code>context.User</code> property to see all the stuff inside.</p><blockquote><p>Check the README.md for instructions on how to run the project locally* üòâ</p></blockquote><p>See you next time. Stay safe! ‚úã</p><p><a href="https://unsplash.com/@dimhou?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Photo by Dimitri Houtteman</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>You app still needs to fetch the public keys from the STS to validate the signature of the tokens. Libraries do that for you in the background so you don&rsquo;t have to worry. In some other cases you might need/want to validate the token everytime. <a href=http://docs.identityserver.io/en/latest/topics/reference_tokens.html>See Reference Tokens</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/identityserver/>identityserver</a></li><li><a href=https://blog.joaograssi.com/tags/authorization/>authorization</a></li><li><a href=https://blog.joaograssi.com/tags/security/>security</a></li><li><a href=https://blog.joaograssi.com/tags/permissions/>permissions</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>