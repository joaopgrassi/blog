<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Adding integration tests for permission-protected API endpoints in ASP.NET Core | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,authorization,security,permission-based-authorization,policies,integration-tests"><meta name=description content="In this post, I'll show you how to add integration tests for API endpoints protected with permissions."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.5df15aa0fa69a07f461d7f7c1614ad5deed5c58a9894e3e7595bf68d9e7d3414.css integrity="sha256-XfFaoPppoH9GHX98FhStXe7VxYqYlOPnWVv2jZ59NBQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content="Adding integration tests for permission-protected API endpoints in ASP.NET Core"><meta property="og:description" content="In this post, I'll show you how to add integration tests for API endpoints protected with permissions."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/"><meta property="og:image" content="https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/testing-endpoints-cover.png"><meta property="article:published_time" content="2021-05-12T20:21:00+00:00"><meta property="article:modified_time" content="2021-05-12T20:21:00+00:00"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/testing-endpoints-cover.png"><meta name=twitter:title content="Adding integration tests for permission-protected API endpoints in ASP.NET Core"><meta name=twitter:description content="In this post, I'll show you how to add integration tests for API endpoints protected with permissions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Adding integration tests for permission-protected API endpoints in ASP.NET Core","name":"Adding integration tests for permission-protected API endpoints in ASP.NET Core","description":"This is the forth post in the Authorization in ASP.NET Core series.\n  Part 1: Using a middleware to build a permission-based identity in ASP.NET Core\n  Part 2: Deep dive into ‚Ä¶","keywords":["asp.net-core","authorization","security","permission-based-authorization","policies","integration-tests"],"articleBody":"This is the forth post in the Authorization in ASP.NET Core series.\n  Part 1: Using a middleware to build a permission-based identity in ASP.NET Core\n  Part 2: Deep dive into policy-based authorization in ASP.NET Core\n  Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core\n  Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core (this post)\n  In the previous post I demonstrated an approach to add authorization to our API endpoints. They are now fully protected with permissions.\nWe are almost there, but there is something important missing: Tests.\nIn this post, I‚Äôll show you how we can add integration tests to our API endpoints. More specifically, I‚Äôll be focusing on how we can ‚Äúmock‚Äù an authenticated user and their set of permissions so we can test all different scenarios we might need. Let‚Äôs start!\nTL;DR In this post, I demonstrated how to add integration tests for the API we have been working on. I showed how to mock an authenticated user via a custom AuthenticationHandler and how to modify it with different permissions for each test in order to ensure all scenarios are working.\nCheck the code on GitHub.\nWhat we‚Äôll be testing In the last post, I demonstrated that by extending the authorization framework in ASP.NET Core, we achieved a very granular level of authorization for our API endpoints. Here is a refresher:\n[PermissionAuthorize(PermissionOperator.And, Permissions.Update, Permissions.Read)] [HttpPut] public IActionResult Update() { return Ok(\"It's good to change things sometimes!\"); } It‚Äôs all nice, but without tests, we are a bit in the dark:\n  Is it protected? What happens if I call it without having the required permissions?\n  How can I ensure that it‚Äôs clear when an existing endpoint changes its required permissions?\n  These are all valid questions (and many others) right? Let‚Äôs see how we can address them.\nIt all starts with the logged-in user The way we achieved this authorization is by implementing a custom AuthorizationHandler. In the last post, we created our own (among other things), which internally inspects if the logged-in User has the necessary claims. Here is one part of it:\npublic class PermissionHandler : AuthorizationHandler { protected override Task HandleRequirementAsync( AuthorizationHandlerContext context, PermissionRequirement requirement) { if (requirement.PermissionOperator == PermissionOperator.And) { foreach (var permission in requirement.Permissions) { // Here we are looking at the logged-in user's claims.  if (!context.User.HasClaim(PermissionRequirement.ClaimType, permission)) { context.Fail(); return Task.CompletedTask; } } context.Succeed(requirement); return Task.CompletedTask; } // omitted for brevity To add integration tests for the endpoint, we somehow need to have an authenticated user (Context.User) present.\nIf you have been following this series you know that our API has JWT Bearer token authentication configured (services.AddAuthentication(..).AddJwtBearer(..)).\nBy doing this we will be ultimately registering the JwtBearerHandler, which is an AuthenticationHandler. This handler is responsible for many things, but the important part for us now is: It creates the ClaimsPrincipal (Context.User).\nWhen you send a request to the API passing the JWT token in the header, this handler will be invoked as part of the pipeline and the HttpContext will have the User property populated when the token is valid.\nYou might wonder why I‚Äôm talking about all this. What does this have to do with testing?\nDuring our integration tests, we want to test the whole thing. That includes not only our controller but also our PermissionMiddleware and all the types we created in the last post that deals with the authorization part. With a single test, we can test all the moving parts that we have been working on so far. Cool, huh?!\nSo, how can we make the integration tests work now that they require an authenticated user with permissions? We can‚Äôt just request JWT tokens for each test. That would be very impractical. So what can we do?\nA custom authentication handler Let‚Äôs think about this together: We understand what the JwtBearerHandler does. We also understand we need a Context.User. Couldn‚Äôt we then create our own AuthenticationHandler and take full control of it? As matter of fact, we can!\nIn a nutshell, to authenticate a request we need just a handful of things:\n  ClaimsPrincipal - our user with whatever claims we want/need\n  AuthenticationTicket - the ‚Äúticket‚Äù containing our principal and which scheme it‚Äôs for\n  AuthenticationResult - the result of authenticating the request with the ticket\n  Here is our custom handler:\n// usings omitted for brevity. Don't worry the full code is on GitHub :)  public class TestAuthHandler : AuthenticationHandler { private readonly MockAuthUser _mockAuthUser; public TestAuthHandler( IOptionsMonitor options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock, MockAuthUser mockAuthUser) : base(options, logger, encoder, clock) { // 1. We get a \"mock\" user instance here via DI.  // we'll see how this work later, don't worry  _mockAuthUser = mockAuthUser; } protected override Task HandleAuthenticateAsync() { if (_mockAuthUser.Claims.Count == 0) return Task.FromResult(AuthenticateResult.Fail(\"Mock auth user not configured.\")); // 2. Create the principal and the ticket  var identity = new ClaimsIdentity(_mockAuthUser.Claims, AuthConstants.Scheme); var principal = new ClaimsPrincipal(identity); var ticket = new AuthenticationTicket(principal, AuthConstants.Scheme); // 3. Authenticate the request  var result = AuthenticateResult.Success(ticket); return Task.FromResult(result); } } We start by creating a new class inheriting from the abstract AuthenticationHandler one. Handlers are DI enabled, and the base class requires all those params. To make it short, focus on the mockAuthUser param injected. That is our User!\nThe HandleAuthenticateAsync is invoked by the framework when a request is trying to access an authorized endpoint. It will simply use the injected user and do the steps I mentioned above to authorize the request. That‚Äôs pretty much it for the handler.\nNext, we‚Äôll be focusing on how to prepare the integration tests to use it.\nRegistering our test authentication handler Next, we must register our handler into DI. An extension method comes in handy:\npublic static class AuthServiceCollectionExtensions { public static AuthenticationBuilder AddTestAuthentication( this IServiceCollection services) { services.AddAuthorization(options = { // AuthConstants.Scheme is just a scheme we define. I called it \"TestAuth\"  options.DefaultPolicy = new AuthorizationPolicyBuilder(AuthConstants.Scheme) .RequireAuthenticatedUser() .Build(); }); // Register our custom authentication handler  return services.AddAuthentication(AuthConstants.Scheme) .AddScheme( AuthConstants.Scheme, options = { }); } } Now we need to glue everything together for our tests.\nExtending our API via WebApplicationFactory  The focus of this post is not how to set up integration tests. If you are not familiar with it, check the official docs, or also my series of posts about it: Integration tests in ASP.NET Core\n These are the steps we need now:\n  Add our custom authentication handler to the api during tests (we can have multiple. TheJWTBearer will still be there)\n  Have a way to register our mock authenticated user into DI (remember our handler needs it)\n  Here is how the relevant part of the ConfigureWebHost method looks like:\n// Default logged in user for all requests - can be overwritten in individual tests private readonly MockAuthUser _user = new MockAuthUser( new Claim(\"sub\", Guid.NewGuid().ToString()), new Claim(\"email\", \"default-user@xyz.com\")); protected override void ConfigureWebHost(IWebHostBuilder builder) { builder.UseEnvironment(\"Test\"); builder.ConfigureServices(services = { // Add our custom handler  services.AddTestAuthentication(); // Register a default user, so all requests have it by default  services.AddScoped(_ = _user); }) } public class MockAuthUser { public List Claims { get; private set; } = new(); public MockAuthUser(params Claim[] claims) = Claims = claims.ToList(); } We register our custom handler using the extension method we just created. Then, we register the _user field as a scoped instance into DI.\nThe idea of registering a user into DI is that we can later override it with another instance during the tests. We‚Äôll see how this works next.\n You can check the complete code of the WebApplicationFactory on GitHub.\n Adding an integration test Now we have everything to write our test! Let‚Äôs try this:\n Given an endpoint protected with the Read AND Update permissions üîí And a user that does not have the Update permission tries to access it üòè Then the API returns a 403 - Forbidden response code ‚õî  public class ProductControllerTests : IClassFixture { private readonly ApiApplicationFactory _factory; public ProductControllerTests(ApiApplicationFactory factory) { _factory = factory; } [Fact] public async Task Put_RequiresReadAndUpdate_UserHasOnlyReadPermission_ShouldReturn403Forbidden() { // Arrange  // Create a user with the Read and Create permissions in our db  var user = await CreateTestUser(Permissions.Read, Permissions.Create); var client = _factory.WithWebHostBuilder(builder = { // register this user in DI (will override the initial one)  builder.ConfigureTestServices(services = services.AddScoped(_ = user)); }).CreateClient(); // Act  var response = await client.PutAsync(\"products\", new StringContent(string.Empty)); // Assert  Assert.Equal(HttpStatusCode.Forbidden, response.StatusCode); } And it passes!\n The CreateTestUser method inserts a new user with the specified permissions (Update,Create) in the database. In the first post of the series, we created a middleware that loads the permissions from the database based on the user sub claim. The middleware then uses the permissions found to augment the ClaimsPrincipal.\n The test is simple but it gives us so much value. Now we are sure that:\n  The middleware works - The user‚Äôs permissions are loaded from the db and added to the ClaimsPrincipal\n  The PermissionHandler correctly checks the endpoint‚Äôs permissions against the user‚Äôs Claims\n  The endpoint is in fact protected\n  Putting all together in a diagram, the ‚Äúflow‚Äù looks more or less like this:\nFlow of testing a protected endpoint  That‚Äôs it. Now we can add all sorts of tests and combinations as we see fit.\nConclusion In the previous post of the series, we added authorization to our API endpoints, but we didn‚Äôt know it was working as we expected. We were missing a way to verify it.\nIn this post, I showed you how to solved that by adding integration tests. The tests gave us the answer that our endpoints are indeed protected and that the permission checks work.\nWe saw how to mock an authenticated user for our tests by implementing a custom AuthenticationHandler. We then manipulated this user to test all different permission scenarios.\nAll the questions from the beginning were answered:\nIs it protected? What happens if I call it without having the required permissions? The API returns a 403 - Forbidden. The endpoint is not reached.\nHow can I ensure that it‚Äôs clear when an existing endpoint changes its required permissions? If we have tests for it when someone changes the endpoint‚Äôs permissions the tests will fail (with some caveats).\nAs usual, all the code is on GitHub. The relevant parts are insideAPI.Tests.\nThanks for reading and I hope this was useful to you. Share with your .NET friends üòâ\nPhoto by Abdullah Aydin on Unsplash\n","wordCount":"1723","inLanguage":"en","image":"https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/testing-endpoints-cover.png","datePublished":"2021-05-12T20:21:00Z","dateModified":"2021-05-12T20:21:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Adding integration tests for permission-protected API endpoints in ASP.NET Core</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/testing-endpoints-cover.png alt="Padlock on a wooden door"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#what-well-be-testing aria-label="What we&amp;rsquo;ll be testing">What we&rsquo;ll be testing</a></li><li><a href=#it-all-starts-with-the-logged-in-user aria-label="It all starts with the logged-in user">It all starts with the logged-in user</a></li><li><a href=#a-custom-authentication-handler aria-label="A custom authentication handler">A custom authentication handler</a></li><li><a href=#registering-our-test-authentication-handler aria-label="Registering our test authentication handler">Registering our test authentication handler</a></li><li><a href=#extending-our-api-via-webapplicationfactory aria-label="Extending our API via WebApplicationFactory">Extending our API via <code>WebApplicationFactory</code></a></li><li><a href=#adding-an-integration-test aria-label="Adding an integration test">Adding an integration test</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></blockquote></details></div><div class=post-content><p>This is the forth post in the <a href=/series/authorization-in-asp.net-core>Authorization in ASP.NET Core</a> series.</p><ul><li><p><a href=/posts/2021/asp-net-core-permission-based-authorization-middleware>Part 1: Using a middleware to build a permission-based identity in ASP.NET Core</a></p></li><li><p><a href=/posts/2021/asp-net-core-deep-dive-policy-based-authorization>Part 2: Deep dive into policy-based authorization in ASP.NET Core</a></p></li><li><p><a href=/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies>Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core</a></p></li><li><p><a href=/posts/2021/asp-net-core-testing-permission-protected-api-endpoints>Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core (this post)</a></p></li></ul><p>In the previous post I demonstrated an approach to add authorization to our API endpoints. They are now fully protected with permissions.</p><p>We are almost there, but there is something important missing: <strong>Tests</strong>.</p><p>In this post, I&rsquo;ll show you how we can add integration tests to our API endpoints. More specifically, I&rsquo;ll be focusing on how we can &ldquo;mock&rdquo; an authenticated user and their set of permissions so we can test all different scenarios we might need. Let&rsquo;s start!</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>In this post, I demonstrated how to add integration tests for the API we have been working on. I showed how to mock an authenticated user via a custom <code>AuthenticationHandler</code> and how to modify it with different permissions for each test in order to ensure all scenarios are working.</p><p>Check the code on <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/main/tests/API.Tests>GitHub</a>.</p><h2 id=what-well-be-testing>What we&rsquo;ll be testing<a hidden class=anchor aria-hidden=true href=#what-well-be-testing>#</a></h2><p>In the last post, I demonstrated that by extending the authorization framework in ASP.NET Core, we achieved a very granular level of authorization for our API endpoints. Here is a refresher:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.And, Permissions.Update, Permissions.Read)]</span>
<span style=color:#a6e22e>[HttpPut]</span>
<span style=color:#66d9ef>public</span> IActionResult Update()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;It&#39;s good to change things sometimes!&#34;</span>);
}
</code></pre></div><p>It&rsquo;s all nice, but without tests, we are a bit in the dark:</p><ul><li><p>Is it protected? What happens if I call it without having the required permissions?</p></li><li><p>How can I ensure that it&rsquo;s clear when an existing endpoint changes its required permissions?</p></li></ul><p>These are all valid questions (and many others) right? Let&rsquo;s see how we can address them.</p><h2 id=it-all-starts-with-the-logged-in-user>It all starts with the logged-in user<a hidden class=anchor aria-hidden=true href=#it-all-starts-with-the-logged-in-user>#</a></h2><p>The way we achieved this authorization is by implementing a custom <code>AuthorizationHandler</code>. In the last post, we created our own (among other things), which internally inspects if the logged-in <code>User</code> has the necessary claims. Here is one part of it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionHandler</span> : AuthorizationHandler&lt;PermissionRequirement&gt;
{
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Task HandleRequirementAsync(
        AuthorizationHandlerContext context, PermissionRequirement requirement)
    {
        <span style=color:#66d9ef>if</span> (requirement.PermissionOperator == PermissionOperator.And)
        {
            <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> permission <span style=color:#66d9ef>in</span> requirement.Permissions)
            {
                <span style=color:#75715e>// Here we are looking at the logged-in user&#39;s claims.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (!context.User.HasClaim(PermissionRequirement.ClaimType, permission))
                {
                    context.Fail();
                    <span style=color:#66d9ef>return</span> Task.CompletedTask;
                }
            }
            context.Succeed(requirement);
            <span style=color:#66d9ef>return</span> Task.CompletedTask;
        }
<span style=color:#75715e>// omitted for brevity
</span></code></pre></div><p>To add integration tests for the endpoint, we somehow need to have an <em>authenticated user</em> (<code>Context.User</code>) present.</p><p>If you have been following this series you know that our API has JWT Bearer token authentication configured (<code>services.AddAuthentication(..).AddJwtBearer(..)</code>).</p><p>By doing this we will be ultimately registering the <code>JwtBearerHandler</code>, which is an <code>AuthenticationHandler</code>. This handler is responsible for many things, but the important part for us now is: It creates the <code>ClaimsPrincipal</code> (<code>Context.User</code>).</p><p>When you send a request to the API passing the JWT token in the header, this handler will be invoked as part of the pipeline and the <code>HttpContext</code> will have the <code>User</code> property populated when the token is valid.</p><p>You might wonder why I&rsquo;m talking about all this. What does this have to do with testing?</p><p>During our integration tests, we want to test the <strong>whole thing</strong>. That includes not only our controller but also our PermissionMiddleware and all the types we created in the last post that deals with the authorization part. With a single test, we can test all the moving parts that we have been working on so far. Cool, huh?!</p><p>So, how can we make the integration tests work now that they require an authenticated user with permissions? We can&rsquo;t just request JWT tokens for each test. That would be very impractical. So what <em>can</em> we do?</p><h2 id=a-custom-authentication-handler>A custom authentication handler<a hidden class=anchor aria-hidden=true href=#a-custom-authentication-handler>#</a></h2><p>Let&rsquo;s think about this together: We understand what the <code>JwtBearerHandler</code> does. We also understand we need a <code>Context.User</code>. Couldn&rsquo;t we then create our own AuthenticationHandler and take full control of it? As matter of fact, we can!</p><p>In a nutshell, to authenticate a request we need just a handful of things:</p><ol><li><p><code>ClaimsPrincipal</code> - our user with whatever claims we want/need</p></li><li><p><code>AuthenticationTicket</code> - the &ldquo;ticket&rdquo; containing our principal and which scheme it&rsquo;s for</p></li><li><p><code>AuthenticationResult</code> - the result of authenticating the request with the ticket</p></li></ol><p>Here is our custom handler:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// usings omitted for brevity. Don&#39;t worry the full code is on GitHub :)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestAuthHandler</span> : AuthenticationHandler&lt;AuthenticationSchemeOptions&gt;
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> MockAuthUser _mockAuthUser;

    <span style=color:#66d9ef>public</span> TestAuthHandler(
        IOptionsMonitor&lt;AuthenticationSchemeOptions&gt; options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock,
        MockAuthUser mockAuthUser)
        : <span style=color:#66d9ef>base</span>(options, logger, encoder, clock)
    {
        <span style=color:#75715e>// 1. We get a &#34;mock&#34; user instance here via DI.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// we&#39;ll see how this work later, don&#39;t worry
</span><span style=color:#75715e></span>        _mockAuthUser = mockAuthUser;
    }

    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        <span style=color:#66d9ef>if</span> (_mockAuthUser.Claims.Count == <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> Task.FromResult(AuthenticateResult.Fail(<span style=color:#e6db74>&#34;Mock auth user not configured.&#34;</span>));

        <span style=color:#75715e>// 2. Create the principal and the ticket
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> identity = <span style=color:#66d9ef>new</span> ClaimsIdentity(_mockAuthUser.Claims, AuthConstants.Scheme);
        <span style=color:#66d9ef>var</span> principal = <span style=color:#66d9ef>new</span> ClaimsPrincipal(identity);
        <span style=color:#66d9ef>var</span> ticket = <span style=color:#66d9ef>new</span> AuthenticationTicket(principal, AuthConstants.Scheme);

        <span style=color:#75715e>// 3. Authenticate the request
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> result = AuthenticateResult.Success(ticket);
        <span style=color:#66d9ef>return</span> Task.FromResult(result);
    }
}
</code></pre></div><p>We start by creating a new class inheriting from the abstract <code>AuthenticationHandler</code> one. Handlers are DI enabled, and the base class requires all those params. To make it short, focus on the <code>mockAuthUser</code> param injected. That is our User!</p><p>The <code>HandleAuthenticateAsync</code> is invoked by the framework when a request is trying to access an authorized endpoint. It will simply use the injected user and do the steps I mentioned above to authorize the request. That&rsquo;s pretty much it for the handler.</p><p>Next, we&rsquo;ll be focusing on how to prepare the integration tests to use it.</p><h2 id=registering-our-test-authentication-handler>Registering our test authentication handler<a hidden class=anchor aria-hidden=true href=#registering-our-test-authentication-handler>#</a></h2><p>Next, we must register our handler into DI. An extension method comes in handy:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthServiceCollectionExtensions</span>
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AuthenticationBuilder AddTestAuthentication(
        <span style=color:#66d9ef>this</span> IServiceCollection services)
    {
        services.AddAuthorization(options =&gt;
        {
            <span style=color:#75715e>// AuthConstants.Scheme is just a scheme we define. I called it &#34;TestAuth&#34;
</span><span style=color:#75715e></span>            options.DefaultPolicy = <span style=color:#66d9ef>new</span> AuthorizationPolicyBuilder(AuthConstants.Scheme)
                .RequireAuthenticatedUser()
                .Build();
        });

        <span style=color:#75715e>// Register our custom authentication handler
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> services.AddAuthentication(AuthConstants.Scheme)
            .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(
                AuthConstants.Scheme, options =&gt; { });
    }
}
</code></pre></div><p>Now we need to glue everything together for our tests.</p><h2 id=extending-our-api-via-webapplicationfactory>Extending our API via <code>WebApplicationFactory</code><a hidden class=anchor aria-hidden=true href=#extending-our-api-via-webapplicationfactory>#</a></h2><blockquote><p>The focus of this post is not how to set up integration tests. If you are not familiar with it, <a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-5.0">check the official docs</a>, or also my series of posts about it: <a href=https://blog.joaograssi.com/series/integration-tests-in-asp.net-core/>Integration tests in ASP.NET Core</a></p></blockquote><p>These are the steps we need now:</p><ol><li><p>Add our custom authentication handler to the api during tests (we can have multiple. The<code>JWTBearer</code> will still be there)</p></li><li><p>Have a way to register our mock authenticated user into DI (remember our handler needs it)</p></li></ol><p>Here is how the relevant part of the <code>ConfigureWebHost</code> method looks like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>
<span style=color:#75715e>// Default logged in user for all requests - can be overwritten in individual tests
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> MockAuthUser _user = <span style=color:#66d9ef>new</span> MockAuthUser(
    <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;sub&#34;</span>, Guid.NewGuid().ToString()),
    <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;email&#34;</span>, <span style=color:#e6db74>&#34;default-user@xyz.com&#34;</span>));

<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> ConfigureWebHost(IWebHostBuilder builder)
{
    builder.UseEnvironment(<span style=color:#e6db74>&#34;Test&#34;</span>);
    builder.ConfigureServices(services =&gt; 
        {
            <span style=color:#75715e>// Add our custom handler
</span><span style=color:#75715e></span>            services.AddTestAuthentication();
            
            <span style=color:#75715e>// Register a default user, so all requests have it by default
</span><span style=color:#75715e></span>            services.AddScoped(_ =&gt; _user);       
        })
}

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MockAuthUser</span>
{
    <span style=color:#66d9ef>public</span> List&lt;Claim&gt; Claims { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>new</span>();

    <span style=color:#66d9ef>public</span> MockAuthUser(<span style=color:#66d9ef>params</span> Claim[] claims)
        =&gt; Claims = claims.ToList();
}

</code></pre></div><p>We register our custom handler using the extension method we just created. Then, we register the <code>_user</code> field as a scoped instance into DI.</p><p>The idea of registering a user into DI is that we can later override it with another instance during the tests. We&rsquo;ll see how this works next.</p><blockquote><p>You can check the complete code of the <code>WebApplicationFactory</code> on <a href=https://github.com/joaopgrassi/authz-custom-middleware/blob/main/tests/API.Tests/ApiApplicationFactory.cs>GitHub</a>.</p></blockquote><h2 id=adding-an-integration-test>Adding an integration test<a hidden class=anchor aria-hidden=true href=#adding-an-integration-test>#</a></h2><p>Now we have everything to write our test! Let&rsquo;s try this:</p><ul><li><strong>Given</strong> an endpoint protected with the <code>Read</code> <strong>AND</strong> <code>Update</code> permissions üîí</li><li><strong>And</strong> a user that does not have the <code>Update</code> permission tries to access it üòè</li><li><strong>Then</strong> the API returns a <code>403 - Forbidden</code> response code ‚õî</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductControllerTests</span> : IClassFixture&lt;ApiApplicationFactory&gt;
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ApiApplicationFactory _factory;

    <span style=color:#66d9ef>public</span> ProductControllerTests(ApiApplicationFactory factory)
    {
        _factory = factory;
    }
<span style=color:#a6e22e>    
</span><span style=color:#a6e22e>    [Fact]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Put_RequiresReadAndUpdate_UserHasOnlyReadPermission_ShouldReturn403Forbidden()
    {
        <span style=color:#75715e>// Arrange
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// Create a user with the Read and Create permissions in our db
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> user = <span style=color:#66d9ef>await</span> CreateTestUser(Permissions.Read, Permissions.Create);

        <span style=color:#66d9ef>var</span> client = _factory.WithWebHostBuilder(builder =&gt;
        {
            <span style=color:#75715e>// register this user in DI (will override the initial one)
</span><span style=color:#75715e></span>            builder.ConfigureTestServices(services =&gt; services.AddScoped(_ =&gt; user));
        }).CreateClient();
        
        <span style=color:#75715e>// Act
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> client.PutAsync(<span style=color:#e6db74>&#34;products&#34;</span>, <span style=color:#66d9ef>new</span> StringContent(<span style=color:#66d9ef>string</span>.Empty));
        
        <span style=color:#75715e>// Assert
</span><span style=color:#75715e></span>        Assert.Equal(HttpStatusCode.Forbidden, response.StatusCode);
    }
</code></pre></div><p>And it passes!</p><blockquote><p>The <code>CreateTestUser</code> method inserts a new user with the specified permissions (<code>Update</code>,<code>Create</code>) in the database. In the first post of the series, we created a <a href=https://github.com/joaopgrassi/authz-custom-middleware/blob/57adf66c0932e9fdb2fad742e24f94ffdb74d44e/src/API/Authorization/PermissionsMiddleware.cs#L39>middleware that loads the permissions</a> from the database based on the user <code>sub</code> claim. The middleware then uses the permissions found to augment the ClaimsPrincipal.</p></blockquote><p>The test is simple but it gives us so much value. Now we are sure that:</p><ol><li><p>The middleware works - The user&rsquo;s permissions are loaded from the db and added to the <code>ClaimsPrincipal</code></p></li><li><p>The <code>PermissionHandler</code> correctly checks the endpoint&rsquo;s permissions against the user&rsquo;s <code>Claims</code></p></li><li><p>The endpoint is in fact protected</p></li></ol><p>Putting all together in a diagram, the &ldquo;flow&rdquo; looks more or less like this:</p><figure class=figure-border><img class=img-center src=/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/request_authorization.png alt="Flow of testing a protected endpoint" loading=lazy><figcaption class=img-caption>Flow of testing a protected endpoint</figcaption></figure><p>That&rsquo;s it. Now we can add all sorts of tests and combinations as we see fit.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In the previous post of the series, we added authorization to our API endpoints, but we didn&rsquo;t know it was working as we expected. We were missing a way to verify it.</p><p>In this post, I showed you how to solved that by adding integration tests. The tests gave us the answer that our endpoints are indeed protected and that the permission checks work.</p><p>We saw how to mock an authenticated user for our tests by implementing a custom <code>AuthenticationHandler</code>. We then manipulated this user to test all different permission scenarios.</p><p>All the questions from the beginning were answered:</p><p><strong>Is it protected? What happens if I call it without having the required permissions?</strong>
<em>The API returns a 403 - Forbidden. The endpoint is not reached.</em></p><p><strong>How can I ensure that it&rsquo;s clear when an existing endpoint changes its required permissions?</strong>
<em>If we have tests for it when someone changes the endpoint&rsquo;s permissions the tests will fail (with some caveats).</em></p><p>As usual, all the code is on <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/main/tests/API.Tests>GitHub</a>. The relevant parts are inside<code>API.Tests</code>.</p><p>Thanks for reading and I hope this was useful to you. Share with your .NET friends üòâ</p><p><a href="https://unsplash.com/@aydinabdullah?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Photo by Abdullah Aydin</a> on <a href=https://unsplash.com/photos/X2MkCH617-o>Unsplash</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/authorization/>authorization</a></li><li><a href=https://blog.joaograssi.com/tags/security/>security</a></li><li><a href=https://blog.joaograssi.com/tags/permission-based-authorization/>permission-based-authorization</a></li><li><a href=https://blog.joaograssi.com/tags/policies/>policies</a></li><li><a href=https://blog.joaograssi.com/tags/integration-tests/>integration-tests</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>