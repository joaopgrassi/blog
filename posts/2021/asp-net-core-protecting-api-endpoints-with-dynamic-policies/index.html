<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Protecting your API endpoints with dynamic policies in ASP.NET Core | Joao Grassi's blog</title>
<meta name=keywords content="asp.net-core,authorization,security,permission-based-authorization,policies">
<meta name=description content="In this post, I'll show you how to protect your API endpoints by using a combination of the user's permissions and dynamic policies in ASP.NET Core.">
<meta name=author content="Joao Grassi">
<link rel=canonical href=https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.a62f9b67a2ed8d7ac28c4555d29a3928a4b4f7b8f363dc332d58a581310d0418.css integrity="sha256-pi+bZ6LtjXrCjEVV0po5KKS097jzY9wzLVilgTENBBg=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.joaograssi.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Protecting your API endpoints with dynamic policies in ASP.NET Core">
<meta property="og:description" content="In this post, I'll show you how to protect your API endpoints by using a combination of the user's permissions and dynamic policies in ASP.NET Core.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/">
<meta property="og:image" content="https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/post-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-31T21:21:00+00:00">
<meta property="article:modified_time" content="2021-03-31T21:21:00+00:00">
<meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-testing-permission-protected-api-endpoints/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-deep-dive-policy-based-authorization/"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2021/asp-net-core-permission-based-authorization-middleware/">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/post-cover.png">
<meta name=twitter:title content="Protecting your API endpoints with dynamic policies in ASP.NET Core">
<meta name=twitter:description content="In this post, I'll show you how to protect your API endpoints by using a combination of the user's permissions and dynamic policies in ASP.NET Core.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.joaograssi.com/posts/"},{"@type":"ListItem","position":3,"name":"Protecting your API endpoints with dynamic policies in ASP.NET Core","item":"https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protecting your API endpoints with dynamic policies in ASP.NET Core","name":"Protecting your API endpoints with dynamic policies in ASP.NET Core","description":"In this post, I'll show you how to protect your API endpoints by using a combination of the user's permissions and dynamic policies in ASP.NET Core.","keywords":["asp.net-core","authorization","security","permission-based-authorization","policies"],"articleBody":"This is the third post in the Authorization in ASP.NET Core series.\n  Part 1: Using a middleware to build a permission-based identity in ASP.NET Core\n  Part 2: Deep dive into policy-based authorization in ASP.NET Core\n  Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core (this post)\n  Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core\n  In this post, we‚Äôll come full circle. I‚Äôll show you how to put everything together and start authorizing API endpoints with permissions.\nTL;DR In this post, I demonstrated how to authorize API endpoints simply by doing this: [PermissionAuthorize(Permissions.Read)]. Behind the scenes, everything works by leveraging dynamic policies via a custom IAuthorizationPolicyProvider.\nJump to the What do we need section to see the breakdown. If you still don‚Äôt feel like reading, check the branch for this post on GitHub.\nPolicies recap In the last post, we learned that everything in ASP.NET Core authorization revolves around policies. I showed some examples of Role-based and Claims-based/Policy authorization and how those are backed by policies.\nAlthough both options offer a great start in adding basic authorization to your APIs, they come with their set of limitations.\nTo me, the biggest limitation is that you have to register them before-hand, during the call to AddAuthorization.\nLet‚Äôs say you have CRUD permissions in your system (like we saw in the first post). If you stick to the ‚Äúclassic‚Äù policies, you would need to do this:\n// Startup.cs services.AddAuthorization(options = { options.AddPolicy(\"Create\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"permissions\" \u0026\u0026 c.Value == \"Create\"))); options.AddPolicy(\"Read\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"permissions\" \u0026\u0026 c.Value == \"Read\"))); options.AddPolicy(\"Update\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"permissions\" \u0026\u0026 c.Value == \"Update\"))); options.AddPolicy(\"Delete\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"permissions\" \u0026\u0026 c.Value == \"Delete\"))); }) // controller [HttpPost] [Authorize(Policy = \"Create\")] // use our policy here public IActionResult Create() { return Ok(\"Something was created\"); } Since you have to define them statically, that certainly will not scale well. Imagine if you have 100 policies? All that code there.. not great right?\nThe official docs highlight some good reasons why they might not be enough for you:\n  Using an external service to provide policy evaluation. Using a large range of policies (for different room numbers or ages, for example), so it doesn‚Äôt make sense to add each individual authorization policy with an AuthorizationOptions.AddPolicy call. Creating policies at runtime based on information in an external data source (like a database) or determining authorization requirements dynamically through another mechanism. https://docs.microsoft.com/en-us/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-5.0   Point 1 above could be very likely to happen in a ‚Äúreal-world‚Äù app. Often we need to contact a database or another service to evaluate the permission, and with the classic approach, that is not possible.\nThankfully, the authorization architecture in ASP.NET Core is flexible enough and can accommodate more complex scenarios. But before we start, I want to give you an overview of what do we want to achieve in the end with all of this.\nWhat do we want to achieve Before I start talking about how to solve the problem, let‚Äôs see first what is the ultimate goal. I believe thinking about the requirements will help you understand better where we are going with this.\nLet‚Äôs continue with the CRUD example. What I would like (and I imagine you too) is:\n  Devs are used to the [Authorize] attribute. So I want to use that in my endpoints, telling it which permission is required.\n  Have the option to pass multiple permissions, and specify OR or AND (requiring both, or any).\n  Not need to define them beforehand. They should be created automagically. ‚ú®\n  Like so:\n[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)] [HttpPost] public IActionResult Create() { return Ok(\"I'm such a creator!\"); } I know, looks cool right? Let‚Äôs see how we can do that next. üòé\nWhat do we need To achieve what we want, we need to create policies ‚Äúon-the-fly‚Äù. Remember, in the end, we always need one.\nIn the previous post, I showed you all about Requirements, Policies and Authorization Handlers. We‚Äôll need all of those now to achieve this.\n If you did not read the previous post, I recommend you do so now before continuing. The rest of the post assumes that you have some understanding of the individual pieces.\n Let‚Äôs start with the easiest: Requirements.\nRequirements Our example above had two things: Operator and Permission(s).\n[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)] [PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)] The requirement is the type that will contain such data. Later on, it gets injected into the handler, which uses it to decide things.\nOur requirement looks like this:\nusing System; using Microsoft.AspNetCore.Authorization; namespace AuthUtils.PolicyProvider { public class PermissionRequirement : IAuthorizationRequirement { public static string ClaimType = AppClaimTypes.Permissions; // 1 - The operator  public PermissionOperator PermissionOperator { get; } // 2 - The list of permissions passed  public string[] Permissions { get; } public PermissionRequirement( PermissionOperator permissionOperator, string[] permissions) { if (permissions.Length == 0) throw new ArgumentException(\"At least one permission is required.\", nameof(permissions)); PermissionOperator = permissionOperator; Permissions = permissions; } } } Requirements must implement the IAuthorizationRequirement marker interface. You can pass data to it, just like I did above. In this case, we need 1 - the operator and 2 - the list of permissions. We also have the ClaimType which is always permissions.\nAuthorization Handlers Authorization Handlers are types that are responsible for evaluating requirements and ultimately ‚Äúmarking‚Äù them as Succeed or Fail. Handlers can ‚Äúhandle‚Äù one or more requirements.\nFor our case, it‚Äôs enough that our handler only deals with our PermissionRequirement. Because of that, we need to inherit from the generic abstract class AuthorizationHandler, where T is the requirement type.\nHere are some facts about them:\n  If inheriting from the base AuthorizationHandler class, the handler needs to override the HandleRequirementAsync method. This method receives two parameters: an AuthorizationHandlerContext and the instance of the requirement, in this case, our PermissionRequirement.\n  Handlers don‚Äôt need to return anything. If the logic tells that the user has permission, we need to call context.Succeed(requirement). That is the only thing necessary to authorize the request.\n  Optionally, you can also call context.Fail() to ensure failure. Calling it will ensure that the request is not authorized, even if other handlers call context.Succeed.\n  You can inject DI services into handlers! That is super useful because, for example, you can inject your DbContext and get data to help in your authorization logic.\n   Check the docs for learning more about having multiple handlers and what a handler should return\n Enough talking. The handler for our PermissionRequirement looks like this:\nusing System.Threading.Tasks; using Microsoft.AspNetCore.Authorization; namespace AuthUtils.PolicyProvider { public class PermissionHandler : AuthorizationHandler { protected override Task HandleRequirementAsync( AuthorizationHandlerContext context, PermissionRequirement requirement) { if (requirement.PermissionOperator == PermissionOperator.And) { foreach (var permission in requirement.Permissions) { if (!context.User. HasClaim(PermissionRequirement.ClaimType, permission)) { // If the user lacks ANY of the required permissions  // we mark it as failed.  context.Fail(); return Task.CompletedTask; } } // identity has all required permissions  context.Succeed(requirement); return Task.CompletedTask; } foreach (var permission in requirement.Permissions) { if (context.User.HasClaim(PermissionRequirement.ClaimType, permission)) { // In the OR case, as soon as we found a matching permission  // we can already mark it as Succeed  context.Succeed(requirement); return Task.CompletedTask; } } // identity does not have any of the required permissions  context.Fail(); return Task.CompletedTask; } } } We receive an instance of a PermissionRequirement and then it‚Äôs just looking if the logged-in user has the proper permissions. If we see the user has them, we call context.Succeed(requirement);. If not, we want to ensure it fails, so we call context.Fail();.\nI want to emphasize that here is where your main authorization logic lives.\n I used context.Fail() because I want to be absolutely sure that if the user does not have the required permissions, the request should not be authorized.\n Let‚Äôs look at the Authorize attribute next.\nAuthorize attribute Now we have the requirement and the handler. Those two comprise the ‚Äúbusiness logic‚Äù side of authorization.\nNow comes what I call ‚Äúplumbing code‚Äù, starting first with our custom authorize attribute.\nAt a high level, the custom attribute serves two purposes. To receive the permissions and to annotate the endpoint. (Metadata)\nHere‚Äôs how it looks:\nusing System; using Microsoft.AspNetCore.Authorization; namespace AuthUtils.PolicyProvider { public enum PermissionOperator { And = 1, Or = 2 } public class PermissionAuthorizeAttribute : AuthorizeAttribute { internal const string PolicyPrefix = \"PERMISSION_\"; private const string Separator = \"_\"; public PermissionAuthorizeAttribute( PermissionOperator permissionOperator, params string[] permissions) { // E.g: PERMISSION_1_Create_Update..  Policy = $\"{PolicyPrefix}{(int)permissionOperator}{Separator}{string.Join(Separator, permissions)}\"; } public PermissionAuthorizeAttribute(string permission) { // E.g: PERMISSION_1_Create..  Policy = $\"{PolicyPrefix}{(int)PermissionOperator.And}{Separator}{permission}\"; } public static PermissionOperator GetOperatorFromPolicy(string policyName) { var @operator = int.Parse(policyName.AsSpan(PolicyPrefix.Length, 1)); return (PermissionOperator)@operator; } public static string[] GetPermissionsFromPolicy(string policyName) { return policyName.Substring(PolicyPrefix.Length + 2) .Split(new[] {Separator}, StringSplitOptions.RemoveEmptyEntries); } } } That is a lot of code. Let‚Äôs make some sense of it:\n1 - We have an enum which is a nice way to pass AND or OR as the operator.\n2 - We inherit from the traditional AuthorizeAttribute.\n3 - Next, you can see two internal strings PolicyPrefix and Separator. Hold them in your mind for a sec.\n4 - Then we have our constructors. One receives the operator + permissions. The other just one permission.\nWith this custom attribute we can do this:\n// multiple permissions [PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)] // single permission [PermissionAuthorize(\"Create\")] Notice that in the ctor, we set a property called Policy. This comes from the base class and it‚Äôs crucial that we set it. Policies must have a name. Remember the example from before:\n// Startup.cs services.AddAuthorization(options = { // Will set the Policy = 'Create'  options.AddPolicy(\"Create\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = c.Type == \"permissions\" \u0026\u0026 c.Value == \"Create\"))); }) // controller [HttpPost] [Authorize(Policy = \"Create\")] // we use the policy name here public IActionResult Create() { return Ok(\"Something was created\"); } Since we don‚Äôt want to define our policies statically, our policy name needs to be ‚Äúdynamic‚Äù.\nHere you can decide what makes sense to you, but what I did is . In the end, the Policy property evaluates to something like:\n// Policy = PERMISSION_2_Create_Update [PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)] // Policy = PERMISSION_1_Create [PermissionAuthorize(\"Create\")] This will be crucial in the last part of the puzzle, our policy provider. Speaking of which‚Ä¶\nPolicy Provider Let‚Äôs review a bit:\n  We have the PermissionRequirement which is where we have the permission(s) and/or operator.\n  We have the PermissionHandler which is where we receive our requirement instance and do our authz logic\n  We have the PermissionAuthorizeAttribute which is what we use to annotate our endpoints with the proper permissions\n  You might be wondering now: Where is the PermissionRequirement created? I pass the permissions to our PermissionAuthorizeAttribute which, becomes a glorified string, and that‚Äôs it. I‚Äôm not getting it..? ü§î\nThe answer to that is this: IAuthorizationPolicyProvider.\nASP.NET Core ships with one implementation of the IAuthorizationPolicyProvider interface : DefaultAuthorizationPolicyProvider.\nThe job of the DefaultAuthorizationPolicyProvider is to provide policies to the authorization framework. If we take a look at the default implementation, it has a method called GetPolicyAsync with the following code:\npublic virtual Task GetPolicyAsync(string policyName) { // MVC caches policies specifically for this class, so this method MUST return the same policy per  // policyName for every request or it could allow undesired access. It also must return synchronously.  // A change to either of these behaviors would require shipping a patch of MVC as well.  return Task.FromResult(_options.GetPolicy(policyName)); } See the policyName param? That is where the Policy string we built before comes to use. In the default implementation, the method tries to find a policy with the name provided. _options.GetPolicy will look into the policies statically defined inside AddAuthorization.\nSince we don‚Äôt define our policies statically, the default implementation will not find them. We need to create our own:\nusing System; using System.Threading.Tasks; using Microsoft.AspNetCore.Authorization; using Microsoft.Extensions.Options; using static AuthUtils.PolicyProvider.PermissionAuthorizeAttribute; namespace AuthUtils.PolicyProvider { public class PermissionAuthorizationPolicyProvider : DefaultAuthorizationPolicyProvider { public PermissionAuthorizationPolicyProvider( IOptions options) : base(options) { } public override async Task GetPolicyAsync( string policyName) { if (!policyName.StartsWith(PolicyPrefix, StringComparison.OrdinalIgnoreCase)) return await base.GetPolicyAsync(policyName); // Will extract the Operator AND/OR enum from the string  PermissionOperator @operator = GetOperatorFromPolicy(policyName); // Will extract the permissions from the string (Create, Update..)  string[] permissions = GetPermissionsFromPolicy(policyName); // Here we create the instance of our requirement  var requirement = new PermissionRequirement(@operator, permissions); // Now we use the builder to create a policy, adding our requirement  return new AuthorizationPolicyBuilder() .AddRequirements(requirement).Build(); } } } Now, imagine that we have a policyName of PERMISSION_2_Create_Update:\n1 - We inherit from the default implementation so we don‚Äôt have to reinvent the wheel\n2 - We override the method I mentioned above. The first thing we do is check if the policyName starts with our defined prefix PERMISSION. If it doesn‚Äôt, we just fall back to the original method, loading from the static policies\n3 - Then we create an instance of our PermissionRequirement. For that, we need the operator + list of permissions. I have helper methods to extract that from our policyName string.\n4 - Finally we use the builder to create and return a policy containing our requirement!\nThe important part here, and there was a hint in the default implementation is that: given a policy name, the provider must always return the same policy. So given a policy name of PERMISSION_2_Create_Update, it will always return the same policy with the same requirements inside.\nThat is why we did all that ‚Äústringyfication‚Äù of our operator and permissions inside our attribute. All so it could be passed to our custom policy provider and used to construct dynamic policies/requirements.\nThe last thing now is to register things and we are done.\nRegistering our custom types: We have all the pieces. Now we only need to register them so the framework can pick them up. In ConfigureServices we need to:\nservices.AddAuthorization(options = { // One static policy - All users must be authenticated  options.DefaultPolicy = new AuthorizationPolicyBuilder(JwtBearerDefaults.AuthenticationScheme) .RequireAuthenticatedUser() .Build(); // A static policy from our previous post. This still works!  options.AddPolicy(\"Over18YearsOld\", policy = policy.RequireAssertion(context = context.User.HasClaim(c = (c.Type == \"DateOfBirth\" \u0026\u0026 DateTime.Now.Year - DateTime.Parse(c.Value).Year = 18) ))); }); // Register our custom Authorization handler services.AddSingleton(); // Overrides the DefaultAuthorizationPolicyProvider with our own services.AddSingleton(); That‚Äôs it. Now we can start adding permissions to our endpoints!\n[PermissionAuthorize(Permissions.Read)] [HttpGet] public IActionResult Get() { return Ok(\"We've got products!\"); } [PermissionAuthorize(PermissionOperator.And, Permissions.Update, Permissions.Read)] [HttpPut] public IActionResult Update() { return Ok(\"It's good to change things sometimes!\"); } If we try to send a request without having the necessary permissions we get now a 403 - Forbidden as expected:\nExample of an unauthorized request  Conclusion Back in the first post of the series we saw how to create a custom ClaimsIdentity that contained all the user‚Äôs permissions as Claim. In the second post, I took you on a deep dive into the types and architecture of authorization in ASP.NET Core. These two established the foundation for us.\nIn this post, we came full circle. We created a powerful, yet simple structure (only 4 new files!) that can be used to authorize your APIs. You saw how to create your own Requirement, AuthorizatioHandler, AuthorizeAttribute and finally the PolicyProvider.\nWith this approach, you can achieve very granular levels of authorization in your endpoints, without sacrificing simplicity. We don‚Äôt need to define manual policies anymore. We simply use the good old [Authorize] attribute, add permissions to it, and all works.\nThis is what I like the most about this solution. At first sight, it might seem like a lot, but the core of it is not that complicated. Once it is done you can just focus on building your API and being productive. The highlights for me are:\n Protecting endpoints is super easy [PermissionAuthorize(Permissions.Read)]. Other developers in the team don‚Äôt need to know about all the inner details (would be nice but not required) It‚Äôs very clear to see what permissions are required to access an endpoint We are not derailing and doing a complete custom thing. We are simply taking advantage of the framework‚Äôs flexibility and good API design It is completely testable and easy to see if your endpoints have the expected permissions  As usual, I have all this on GitHub. You can debug the integration test (spoiler alert!) I have for the ProductsController GET method. Put a breakpoint on the PermissionHandler and PermissionAuthorizationPolicyProvider to see things in action.\nYou can also run the API and test with Swagger. alice should have permission to access all endpoints, while bob can only access one. The swagger UI also has some documentation to help you.\nComing up next, I‚Äôll show how to write integration tests for endpoints that are protected with our permissions.\nThanks for reading and I hope this was useful to you. Share with your .NET friends üòâ\nPhoto by Waldemar Brandt on Unsplash\n","wordCount":"2785","inLanguage":"en","image":"https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/post-cover.png","datePublished":"2021-03-31T21:21:00Z","dateModified":"2021-03-31T21:21:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.joaograssi.com/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://blog.joaograssi.com/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://blog.joaograssi.com/series/ title=Series>
<span>Series</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Protecting your API endpoints with dynamic policies in ASP.NET Core
</h1>
<div class=post-description>
In this post, I'll show you how to protect your API endpoints by using a combination of the user's permissions and dynamic policies in ASP.NET Core.
</div>
</header>
<figure class=entry-cover>
<img loading=lazy src=https://blog.joaograssi.com/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/post-cover.png alt="Brick wall">
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#tldr aria-label=TL;DR>TL;DR</a></li>
<li>
<a href=#policies-recap aria-label="Policies recap">Policies recap</a></li>
<li>
<a href=#what-do-we-want-to-achieve aria-label="What do we want to achieve">What do we want to achieve</a></li>
<li>
<a href=#what-do-we-need aria-label="What do we need">What do we need</a><ul>
<li>
<a href=#requirements aria-label=Requirements>Requirements</a></li>
<li>
<a href=#authorization-handlers aria-label="Authorization Handlers">Authorization Handlers</a></li>
<li>
<a href=#authorize-attribute aria-label="Authorize attribute">Authorize attribute</a></li>
<li>
<a href=#policy-provider aria-label="Policy Provider">Policy Provider</a></li>
<li>
<a href=#registering-our-custom-types aria-label="Registering our custom types:">Registering our custom types:</a></li></ul>
</li>
<li>
<a href=#conclusion aria-label=Conclusion>Conclusion</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>This is the third post in the <a href=/series/authorization-in-asp.net-core>Authorization in ASP.NET Core</a> series.</p>
<ul>
<li>
<p><a href=/posts/2021/asp-net-core-permission-based-authorization-middleware>Part 1: Using a middleware to build a permission-based identity in ASP.NET Core</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-deep-dive-policy-based-authorization>Part 2: Deep dive into policy-based authorization in ASP.NET Core</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies>Part 3: Protecting your API endpoints with dynamic policies in ASP.NET Core (this post)</a></p>
</li>
<li>
<p><a href=/posts/2021/asp-net-core-testing-permission-protected-api-endpoints>Part 4: Adding integration tests for permission-protected API endpoints in ASP.NET Core</a></p>
</li>
</ul>
<p>In this post, we&rsquo;ll come full circle. I&rsquo;ll show you how to put everything together and start authorizing API endpoints with permissions.</p>
<h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2>
<p>In this post, I demonstrated how to authorize API endpoints simply by doing this: <code>[PermissionAuthorize(Permissions.Read)]</code>. Behind the scenes, everything works by leveraging dynamic policies via a custom <code>IAuthorizationPolicyProvider</code>.</p>
<p>Jump to the <a href=#what-do-we-need>What do we need</a> section to see the breakdown. If you still don&rsquo;t feel like reading, check the branch for this post on <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/posts/custom-policy-provider>GitHub</a>.</p>
<h2 id=policies-recap>Policies recap<a hidden class=anchor aria-hidden=true href=#policies-recap>#</a></h2>
<p>In the last post, we learned that everything in ASP.NET Core authorization revolves around <em>policies</em>. I showed some examples of <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/roles?view=aspnetcore-5.0">Role-based</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims?view=aspnetcore-5.0">Claims-based/Policy</a> authorization and how those are backed by policies.</p>
<p>Although both options offer a great start in adding basic authorization to your APIs, they come with their set of limitations.</p>
<p>To me, the biggest limitation is that you have to register them before-hand, during the call to <code>AddAuthorization</code>.</p>
<p>Let&rsquo;s say you have <code>CRUD</code> permissions in your system (like we saw in the first post). If you stick to the &ldquo;classic&rdquo; policies, you would need to do this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Startup.cs
</span><span style=color:#75715e></span>services.AddAuthorization(options =&gt;
{
    options.AddPolicy(<span style=color:#e6db74>&#34;Create&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; c.Type == <span style=color:#e6db74>&#34;permissions&#34;</span> &amp;&amp; c.Value == <span style=color:#e6db74>&#34;Create&#34;</span>)));

    options.AddPolicy(<span style=color:#e6db74>&#34;Read&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; c.Type == <span style=color:#e6db74>&#34;permissions&#34;</span> &amp;&amp; c.Value == <span style=color:#e6db74>&#34;Read&#34;</span>)));
    
    options.AddPolicy(<span style=color:#e6db74>&#34;Update&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; c.Type == <span style=color:#e6db74>&#34;permissions&#34;</span> &amp;&amp; c.Value == <span style=color:#e6db74>&#34;Update&#34;</span>)));

    options.AddPolicy(<span style=color:#e6db74>&#34;Delete&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; c.Type == <span style=color:#e6db74>&#34;permissions&#34;</span> &amp;&amp; c.Value == <span style=color:#e6db74>&#34;Delete&#34;</span>)));
})

<span style=color:#75715e>// controller
</span><span style=color:#75715e></span><span style=color:#a6e22e>[HttpPost]</span>
<span style=color:#a6e22e>[Authorize(Policy = &#34;Create&#34;)]</span> <span style=color:#75715e>// use our policy here
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> IActionResult Create()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;Something was created&#34;</span>);
}
</code></pre></div><p>Since you have to define them statically, that certainly will not scale well. Imagine if you have 100 policies? All that code there.. not great right?</p>
<p>The official docs highlight some good reasons why they might not be enough for you:</p>
<blockquote>
<ul>
<li>Using an external service to provide policy evaluation.</li>
<li>Using a large range of policies (for different room numbers or ages, for example), so it doesn&rsquo;t make sense to add each individual authorization policy with an AuthorizationOptions.AddPolicy call.</li>
<li>Creating policies at runtime based on information in an external data source (like a database) or determining authorization requirements dynamically through another mechanism.
<em><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-5.0">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-5.0</a></em></li>
</ul>
</blockquote>
<p>Point 1 above could be very likely to happen in a &ldquo;real-world&rdquo; app. Often we need to contact a database or another service to evaluate the permission, and with the classic approach, that is not possible.</p>
<p>Thankfully, the authorization architecture in ASP.NET Core is flexible enough and can accommodate more complex scenarios. But before we start, I want to give you an overview of what do we want to achieve in the end with all of this.</p>
<h2 id=what-do-we-want-to-achieve>What do we want to achieve<a hidden class=anchor aria-hidden=true href=#what-do-we-want-to-achieve>#</a></h2>
<p>Before I start talking about how to solve the problem, let&rsquo;s see first what is the ultimate goal. I believe thinking about the requirements will help you understand better where we are going with this.</p>
<p>Let&rsquo;s continue with the <code>CRUD</code> example. What I would like (and I imagine you too) is:</p>
<ul>
<li>
<p>Devs are used to the <code>[Authorize]</code> attribute. So I want to use that in my endpoints, telling it which permission is required.</p>
</li>
<li>
<p>Have the option to pass multiple permissions, and specify <code>OR</code> or <code>AND</code> (requiring both, or any).</p>
</li>
<li>
<p><strong>Not</strong> need to define them beforehand. They should be created automagically. ‚ú®</p>
</li>
</ul>
<p>Like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)]</span>
<span style=color:#a6e22e>[HttpPost]</span>
<span style=color:#66d9ef>public</span> IActionResult Create()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;I&#39;m such a creator!&#34;</span>);
}
</code></pre></div><p>I know, looks cool right? Let&rsquo;s see how we can do that next. üòé</p>
<h2 id=what-do-we-need>What do we need<a hidden class=anchor aria-hidden=true href=#what-do-we-need>#</a></h2>
<p>To achieve what we want, we need to create policies &ldquo;on-the-fly&rdquo;. Remember, in the end, we always need one.</p>
<p>In the previous post, I showed you all about <code>Requirements</code>, <code>Policies</code> and <code>Authorization Handlers</code>. We&rsquo;ll need all of those now to achieve this.</p>
<blockquote>
<p>If you did not read the previous post, I recommend you do so now before continuing. The rest of the post assumes that you have some understanding of the individual pieces.</p>
</blockquote>
<p>Let&rsquo;s start with the easiest: Requirements.</p>
<h3 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h3>
<p>Our example above had two things: <code>Operator</code> and <code>Permission(s)</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)]</span>
<span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)]</span>
</code></pre></div><p>The requirement is the type that will contain such data. Later on, it gets injected into the handler, which uses it to decide things.</p>
<p>Our requirement looks like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Authorization;

<span style=color:#66d9ef>namespace</span> AuthUtils.PolicyProvider
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionRequirement</span> : IAuthorizationRequirement
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> ClaimType =&gt; AppClaimTypes.Permissions;
        
        <span style=color:#75715e>// 1 - The operator
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> PermissionOperator PermissionOperator { <span style=color:#66d9ef>get</span>; }
        
        <span style=color:#75715e>// 2 - The list of permissions passed
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span>[] Permissions { <span style=color:#66d9ef>get</span>; }

        <span style=color:#66d9ef>public</span> PermissionRequirement(
            PermissionOperator permissionOperator, <span style=color:#66d9ef>string</span>[] permissions)
        {
            <span style=color:#66d9ef>if</span> (permissions.Length == <span style=color:#ae81ff>0</span>)
                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(<span style=color:#e6db74>&#34;At least one permission is required.&#34;</span>, nameof(permissions));

            PermissionOperator = permissionOperator;
            Permissions = permissions;
        }
    }
}

</code></pre></div><p>Requirements must implement the <code>IAuthorizationRequirement</code> marker interface. You can pass data to it, just like I did above. In this case, we need <code>1 - the operator</code> and <code>2 - the list of permissions</code>. We also have the <code>ClaimType</code> which is always <code>permissions</code>.</p>
<h3 id=authorization-handlers>Authorization Handlers<a hidden class=anchor aria-hidden=true href=#authorization-handlers>#</a></h3>
<p>Authorization Handlers are types that are responsible for evaluating requirements and ultimately &ldquo;marking&rdquo; them as <code>Succeed</code> or <code>Fail</code>. Handlers can &ldquo;handle&rdquo; <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-5.0#authorization-handlers">one or more requirements</a>.</p>
<p>For our case, it&rsquo;s enough that our handler only deals with our <code>PermissionRequirement</code>. Because of that, we need to inherit from the generic abstract class <code>AuthorizationHandler&lt;T></code>, where <code>T</code> is the requirement type.</p>
<p>Here are some facts about them:</p>
<ol>
<li>
<p>If inheriting from the base <code>AuthorizationHandler&lt;T></code> class, the handler needs to override the <code>HandleRequirementAsync</code> method. This method receives two parameters: an <code>AuthorizationHandlerContext</code> and the instance of the requirement, in this case, our <code>PermissionRequirement</code>.</p>
</li>
<li>
<p>Handlers don&rsquo;t need to return anything. If the logic tells that the user has permission, we need to call <code>context.Succeed(requirement)</code>. That is the only thing necessary to authorize the request.</p>
</li>
<li>
<p>Optionally, you can also call <code>context.Fail()</code> to ensure failure. Calling it will ensure that the request is <strong>not authorized</strong>, even if other handlers call <code>context.Succeed</code>.</p>
</li>
<li>
<p>You can inject DI services into handlers! That is super useful because, for example, you can inject your <code>DbContext</code> and get data to help in your authorization logic.</p>
</li>
</ol>
<blockquote>
<p>Check the docs for learning more about <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-5.0#what-should-a-handler-return">having multiple handlers and what a handler should return</a></p>
</blockquote>
<p>Enough talking. The handler for our <code>PermissionRequirement</code> looks like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>
<span style=color:#66d9ef>using</span> System.Threading.Tasks;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Authorization;

<span style=color:#66d9ef>namespace</span> AuthUtils.PolicyProvider
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionHandler</span> : AuthorizationHandler&lt;PermissionRequirement&gt;
    {
        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Task HandleRequirementAsync(
            AuthorizationHandlerContext context, PermissionRequirement requirement)
        {
            <span style=color:#66d9ef>if</span> (requirement.PermissionOperator == PermissionOperator.And)
            {
                <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> permission <span style=color:#66d9ef>in</span> requirement.Permissions)
                {
                    <span style=color:#66d9ef>if</span> (!context.User.
                        HasClaim(PermissionRequirement.ClaimType, permission))
                    {
                        <span style=color:#75715e>// If the user lacks ANY of the required permissions
</span><span style=color:#75715e></span>                        <span style=color:#75715e>// we mark it as failed.
</span><span style=color:#75715e></span>                        context.Fail();
                        <span style=color:#66d9ef>return</span> Task.CompletedTask;
                    }
                }
                
                <span style=color:#75715e>// identity has all required permissions
</span><span style=color:#75715e></span>                context.Succeed(requirement);
                <span style=color:#66d9ef>return</span> Task.CompletedTask;
            }

            <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> permission <span style=color:#66d9ef>in</span> requirement.Permissions)
            {
                <span style=color:#66d9ef>if</span> (context.User.HasClaim(PermissionRequirement.ClaimType, permission))
                {
                    <span style=color:#75715e>// In the OR case, as soon as we found a matching permission
</span><span style=color:#75715e></span>                    <span style=color:#75715e>// we can already mark it as Succeed
</span><span style=color:#75715e></span>                    context.Succeed(requirement);
                    <span style=color:#66d9ef>return</span> Task.CompletedTask;
                }
            }
                
            <span style=color:#75715e>// identity does not have any of the required permissions
</span><span style=color:#75715e></span>            context.Fail();
            <span style=color:#66d9ef>return</span> Task.CompletedTask;
        }
    }
}
</code></pre></div><p>We receive an instance of a <code>PermissionRequirement</code> and then it&rsquo;s just looking if the logged-in user has the proper permissions. If we see the user has them, we call <code>context.Succeed(requirement);</code>. If not, we want to ensure it fails, so we call <code>context.Fail();</code>.</p>
<p>I want to emphasize that here <strong>is where your main authorization logic lives</strong>.</p>
<blockquote>
<p>I used <code>context.Fail()</code> because I want to be <em>absolutely sure</em> that if the user does not have the required permissions, the request <strong>should not be authorized</strong>.</p>
</blockquote>
<p>Let&rsquo;s look at the <code>Authorize</code> attribute next.</p>
<h3 id=authorize-attribute>Authorize attribute<a hidden class=anchor aria-hidden=true href=#authorize-attribute>#</a></h3>
<p>Now we have the requirement and the handler. Those two comprise the &ldquo;business logic&rdquo; side of authorization.</p>
<p>Now comes what I call &ldquo;plumbing code&rdquo;, starting first with our custom authorize attribute.</p>
<p>At a high level, the custom attribute serves two purposes. To receive the permissions and to annotate the endpoint. (Metadata)</p>
<p>Here&rsquo;s how it looks:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Authorization;

<span style=color:#66d9ef>namespace</span> AuthUtils.PolicyProvider
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> PermissionOperator
    {
        And = <span style=color:#ae81ff>1</span>, Or = <span style=color:#ae81ff>2</span>
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionAuthorizeAttribute</span> : AuthorizeAttribute
    {
        <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> PolicyPrefix = <span style=color:#e6db74>&#34;PERMISSION_&#34;</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> Separator = <span style=color:#e6db74>&#34;_&#34;</span>;

        <span style=color:#66d9ef>public</span> PermissionAuthorizeAttribute(
            PermissionOperator permissionOperator, <span style=color:#66d9ef>params</span> <span style=color:#66d9ef>string</span>[] permissions)
        {
            <span style=color:#75715e>// E.g: PERMISSION_1_Create_Update..
</span><span style=color:#75715e></span>            Policy = <span style=color:#e6db74>$&#34;{PolicyPrefix}{(int)permissionOperator}{Separator}{string.Join(Separator, permissions)}&#34;</span>;
        }

        <span style=color:#66d9ef>public</span> PermissionAuthorizeAttribute(<span style=color:#66d9ef>string</span> permission)
        {
            <span style=color:#75715e>// E.g: PERMISSION_1_Create..
</span><span style=color:#75715e></span>            Policy = <span style=color:#e6db74>$&#34;{PolicyPrefix}{(int)PermissionOperator.And}{Separator}{permission}&#34;</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> PermissionOperator GetOperatorFromPolicy(<span style=color:#66d9ef>string</span> policyName)
        {
            <span style=color:#66d9ef>var</span> @operator = <span style=color:#66d9ef>int</span>.Parse(policyName.AsSpan(PolicyPrefix.Length, <span style=color:#ae81ff>1</span>));
            <span style=color:#66d9ef>return</span> (PermissionOperator)@operator;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span>[] GetPermissionsFromPolicy(<span style=color:#66d9ef>string</span> policyName)
        {
            <span style=color:#66d9ef>return</span> policyName.Substring(PolicyPrefix.Length + <span style=color:#ae81ff>2</span>)
                .Split(<span style=color:#66d9ef>new</span>[] {Separator}, StringSplitOptions.RemoveEmptyEntries);
        }
    }
}

</code></pre></div><p>That is a lot of code. Let&rsquo;s make some sense of it:</p>
<p>1 - We have an enum which is a nice way to pass <code>AND</code> or <code>OR</code> as the operator.</p>
<p>2 - We inherit from the traditional <code>AuthorizeAttribute</code>.</p>
<p>3 - Next, you can see two internal strings <code>PolicyPrefix</code> and <code>Separator</code>. Hold them in your mind for a sec.</p>
<p>4 - Then we have our constructors. One receives the operator + permissions. The other just one permission.</p>
<p>With this custom attribute we can do this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// multiple permissions
</span><span style=color:#75715e></span><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)]</span>

<span style=color:#75715e>// single permission
</span><span style=color:#75715e></span><span style=color:#a6e22e>[PermissionAuthorize(&#34;Create&#34;)]</span>
</code></pre></div><p>Notice that in the ctor, we set a property called <code>Policy</code>. This comes from the base class and it&rsquo;s <strong>crucial</strong> that we set it. Policies <strong>must</strong> have a name. Remember the example from before:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Startup.cs
</span><span style=color:#75715e></span>services.AddAuthorization(options =&gt;
{
    <span style=color:#75715e>// Will set the Policy = &#39;Create&#39;
</span><span style=color:#75715e></span>    options.AddPolicy(<span style=color:#e6db74>&#34;Create&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt; c.Type == <span style=color:#e6db74>&#34;permissions&#34;</span> &amp;&amp; c.Value == <span style=color:#e6db74>&#34;Create&#34;</span>)));
})

<span style=color:#75715e>// controller
</span><span style=color:#75715e></span><span style=color:#a6e22e>[HttpPost]</span>
<span style=color:#a6e22e>[Authorize(Policy = &#34;Create&#34;)]</span> <span style=color:#75715e>// we use the policy name here
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> IActionResult Create()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;Something was created&#34;</span>);
}
</code></pre></div><p>Since we don&rsquo;t want to define our policies statically, our policy name needs to be &ldquo;dynamic&rdquo;.</p>
<p>Here you can decide what makes sense to you, but what I did is <code>&lt;prefix>&lt;operator>&lt;separator>&lt;permissions></code>. In the end, the <code>Policy</code> property evaluates to something like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Policy = PERMISSION_2_Create_Update
</span><span style=color:#75715e></span><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.Or, Permissions.Create, Permissions.Update)]</span>

<span style=color:#75715e>// Policy = PERMISSION_1_Create
</span><span style=color:#75715e></span><span style=color:#a6e22e>[PermissionAuthorize(&#34;Create&#34;)]</span>
</code></pre></div><p>This will be crucial in the last part of the puzzle, our policy provider. Speaking of which&mldr;</p>
<h3 id=policy-provider>Policy Provider<a hidden class=anchor aria-hidden=true href=#policy-provider>#</a></h3>
<p>Let&rsquo;s review a bit:</p>
<ul>
<li>
<p>We have the <code>PermissionRequirement</code> which is where we have the permission(s) and/or operator.</p>
</li>
<li>
<p>We have the <code>PermissionHandler</code> which is where we receive our requirement instance and do our authz logic</p>
</li>
<li>
<p>We have the <code>PermissionAuthorizeAttribute</code> which is what we use to annotate our endpoints with the proper permissions</p>
</li>
</ul>
<p>You might be wondering now: Where is the <code>PermissionRequirement</code> created? I pass the permissions to our <code>PermissionAuthorizeAttribute</code> which, becomes a glorified string, and that&rsquo;s it. I&rsquo;m not getting it..? ü§î</p>
<p>The answer to that is this: <code>IAuthorizationPolicyProvider</code>.</p>
<p>ASP.NET Core ships with one implementation of the <code>IAuthorizationPolicyProvider</code> interface : <a href=https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Core/src/DefaultAuthorizationPolicyProvider.cs>DefaultAuthorizationPolicyProvider</a>.</p>
<p>The job of the <code>DefaultAuthorizationPolicyProvider</code> is to provide policies to the authorization framework. If we take a look at the default implementation, it has a method called <a href=https://github.com/dotnet/aspnetcore/blob/7dea0cb6736bc8ea2b53e5a716b926e7a80a4430/src/Security/Authorization/Core/src/DefaultAuthorizationPolicyProvider.cs#L68>GetPolicyAsync</a> with the following code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> Task&lt;AuthorizationPolicy?&gt; GetPolicyAsync(<span style=color:#66d9ef>string</span> policyName)
{
    <span style=color:#75715e>// MVC caches policies specifically for this class, so this method MUST return the same policy per
</span><span style=color:#75715e></span>    <span style=color:#75715e>// policyName for every request or it could allow undesired access. It also must return synchronously.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// A change to either of these behaviors would require shipping a patch of MVC as well.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> Task.FromResult(<span style=color:#ae81ff>_</span>options.GetPolicy(policyName));
}
</code></pre></div><p>See the <code>policyName</code> param? That is where the <code>Policy</code> string we built before comes to use. In the default implementation, the method tries to find a policy with the name provided. <code>_options.GetPolicy</code> will look into the policies statically defined inside <code>AddAuthorization</code>.</p>
<p>Since we don&rsquo;t define our policies statically, the default implementation will not find them. We need to create our own:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Threading.Tasks;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Authorization;
<span style=color:#66d9ef>using</span> Microsoft.Extensions.Options;

<span style=color:#66d9ef>using</span> static AuthUtils.PolicyProvider.PermissionAuthorizeAttribute;

<span style=color:#66d9ef>namespace</span> AuthUtils.PolicyProvider
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PermissionAuthorizationPolicyProvider</span> : DefaultAuthorizationPolicyProvider
    {
        <span style=color:#66d9ef>public</span> PermissionAuthorizationPolicyProvider(
            IOptions&lt;AuthorizationOptions&gt; options) : <span style=color:#66d9ef>base</span>(options) { }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task&lt;AuthorizationPolicy?&gt; GetPolicyAsync(
            <span style=color:#66d9ef>string</span> policyName)
        {
            <span style=color:#66d9ef>if</span> (!policyName.StartsWith(PolicyPrefix, StringComparison.OrdinalIgnoreCase))
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>base</span>.GetPolicyAsync(policyName);

            <span style=color:#75715e>// Will extract the Operator AND/OR enum from the string
</span><span style=color:#75715e></span>            PermissionOperator @operator = GetOperatorFromPolicy(policyName);

            <span style=color:#75715e>// Will extract the permissions from the string (Create, Update..)
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>string</span>[] permissions = GetPermissionsFromPolicy(policyName);

            <span style=color:#75715e>// Here we create the instance of our requirement
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> requirement = <span style=color:#66d9ef>new</span> PermissionRequirement(@operator, permissions);

            <span style=color:#75715e>// Now we use the builder to create a policy, adding our requirement
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AuthorizationPolicyBuilder()
                .AddRequirements(requirement).Build();
        }
    }
}
</code></pre></div><p>Now, imagine that we have a <code>policyName</code> of <code>PERMISSION_2_Create_Update</code>:</p>
<p>1 - We inherit from the default implementation so we don&rsquo;t have to reinvent the wheel</p>
<p>2 - We override the method I mentioned above. The first thing we do is check if the <code>policyName</code> starts with our defined prefix <code>PERMISSION</code>. If it doesn&rsquo;t, we just fall back to the original method, loading from the static policies</p>
<p>3 - Then we create an instance of our <code>PermissionRequirement</code>. For that, we need the operator + list of permissions. I have helper methods to extract that from our <code>policyName</code> string.</p>
<p>4 - Finally we use the builder to create and return a policy containing our requirement!</p>
<p>The important part here, and there was a hint in the default implementation is that: <strong>given a policy name, the provider must always return the same policy</strong>. So given a policy name of <code>PERMISSION_2_Create_Update</code>, it will always return the same policy with the same requirements inside.</p>
<p>That is why we did all that &ldquo;stringyfication&rdquo; of our operator and permissions inside our attribute. All so it could be passed to our custom policy provider and used to construct dynamic policies/requirements.</p>
<p>The last thing now is to register things and we are done.</p>
<h3 id=registering-our-custom-types>Registering our custom types:<a hidden class=anchor aria-hidden=true href=#registering-our-custom-types>#</a></h3>
<p>We have all the pieces. Now we only need to register them so the framework can pick them up. In <code>ConfigureServices</code> we need to:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>services.AddAuthorization(options =&gt;
{
    <span style=color:#75715e>// One static policy - All users must be authenticated
</span><span style=color:#75715e></span>    options.DefaultPolicy = <span style=color:#66d9ef>new</span> AuthorizationPolicyBuilder(JwtBearerDefaults.AuthenticationScheme)
        .RequireAuthenticatedUser()
        .Build();
    
    <span style=color:#75715e>// A static policy from our previous post. This still works!
</span><span style=color:#75715e></span>    options.AddPolicy(<span style=color:#e6db74>&#34;Over18YearsOld&#34;</span>, policy =&gt; policy.RequireAssertion(context =&gt;
        context.User.HasClaim(c =&gt;
            (c.Type == <span style=color:#e6db74>&#34;DateOfBirth&#34;</span> &amp;&amp; DateTime.Now.Year - DateTime.Parse(c.Value).Year &gt;= <span style=color:#ae81ff>18</span>)
        )));
});

<span style=color:#75715e>// Register our custom Authorization handler
</span><span style=color:#75715e></span>services.AddSingleton&lt;IAuthorizationHandler, PermissionHandler&gt;();

<span style=color:#75715e>// Overrides the DefaultAuthorizationPolicyProvider with our own
</span><span style=color:#75715e></span>services.AddSingleton&lt;IAuthorizationPolicyProvider, PermissionAuthorizationPolicyProvider&gt;();
</code></pre></div><p>That&rsquo;s it. Now we can start adding permissions to our endpoints!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>
</span><span style=color:#a6e22e>[PermissionAuthorize(Permissions.Read)]</span>
<span style=color:#a6e22e>[HttpGet]</span>
<span style=color:#66d9ef>public</span> IActionResult Get()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;We&#39;ve got products!&#34;</span>);
}
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[PermissionAuthorize(PermissionOperator.And, Permissions.Update, Permissions.Read)]</span>
<span style=color:#a6e22e>[HttpPut]</span>
<span style=color:#66d9ef>public</span> IActionResult Update()
{
    <span style=color:#66d9ef>return</span> Ok(<span style=color:#e6db74>&#34;It&#39;s good to change things sometimes!&#34;</span>);
}

</code></pre></div><p>If we try to send a request without having the necessary permissions we get now a <code>403 - Forbidden</code> as expected:</p>
<figure class=figure-border>
<img class=img-center src=/posts/2021/asp-net-core-protecting-api-endpoints-with-dynamic-policies/forbidden_request_swagger.png alt="Example of an unauthorized request" loading=lazy>
<figcaption class=img-caption>Example of an unauthorized request</figcaption>
</figure>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Back in the first post of the series we saw how to create a custom <code>ClaimsIdentity</code> that contained all the user&rsquo;s permissions as <code>Claim</code>. In the second post, I took you on a deep dive into the types and architecture of authorization in ASP.NET Core. These two established the foundation for us.</p>
<p>In this post, we came full circle. We created a powerful, yet simple structure (only 4 new files!) that can be used to authorize your APIs. You saw how to create your own <em><code>Requirement</code></em>, <em><code>AuthorizatioHandler</code></em>, <em><code>AuthorizeAttribute</code></em> and finally the <em><code>PolicyProvider</code></em>.</p>
<p>With this approach, you can achieve very granular levels of authorization in your endpoints, without sacrificing simplicity. We don&rsquo;t need to define manual policies anymore. We simply use the good old <code>[Authorize]</code> attribute, add permissions to it, and all works.</p>
<p>This is what I like the most about this solution. At first sight, it might seem like a lot, but the core of it is not that complicated. Once it is done you can just focus on building your API and being productive. The highlights for me are:</p>
<ul>
<li>Protecting endpoints is super easy <code>[PermissionAuthorize(Permissions.Read)]</code>.</li>
<li>Other developers in the team don&rsquo;t need to know about all the inner details (would be nice but not required)</li>
<li>It&rsquo;s very clear to see what permissions are required to access an endpoint</li>
<li>We are not derailing and doing a complete custom thing. We are simply taking advantage of the framework&rsquo;s flexibility and good API design</li>
<li>It is completely testable and easy to see if your endpoints have the expected permissions</li>
</ul>
<p>As usual, I have all this on <a href=https://github.com/joaopgrassi/authz-custom-middleware/tree/posts/custom-policy-provider>GitHub</a>. You can debug the integration test (spoiler alert!) I have for the <code>ProductsController</code> GET method. Put a breakpoint on the <code>PermissionHandler</code> and <code>PermissionAuthorizationPolicyProvider</code> to see things in action.</p>
<p>You can also run the API and test with Swagger. <code>alice</code> should have permission to access all endpoints, while <code>bob</code> can only access one. The swagger UI also has some documentation to help you.</p>
<p>Coming up next, I&rsquo;ll show how to write integration tests for endpoints that are protected with our permissions.</p>
<p>Thanks for reading and I hope this was useful to you. Share with your .NET friends üòâ</p>
<p><a href="https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Photo by Waldemar Brandt</a> on <a href=https://unsplash.com/photos/rfap5oG0c4M>Unsplash</a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li>
<li><a href=https://blog.joaograssi.com/tags/authorization/>authorization</a></li>
<li><a href=https://blog.joaograssi.com/tags/security/>security</a></li>
<li><a href=https://blog.joaograssi.com/tags/permission-based-authorization/>permission-based-authorization</a></li>
<li><a href=https://blog.joaograssi.com/tags/policies/>policies</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script data-goatcounter=https://trinity.goatcounter.com/count src=/count.js type=text/javascript></script>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>