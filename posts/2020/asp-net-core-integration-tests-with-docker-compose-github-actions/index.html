<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ASP.NET Core integration tests with docker-compose on GitHub Actions | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,github,github-actions,integration-tests,docker"><meta name=description content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on GitHub Actions."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.e1ab5a6d2c103bea5816e8a73d5b790df987819379382379bab1664c1e016e49.css integrity="sha256-4atabSwQO+pYFuinPVt5DfmHgZN5OCN5urFmTB4Bbkk=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><link href=https://blog.joaograssi.com/assets/css/custom_blog.min.7298d009bdbcc5c0dad21993cd67b42de34ddb29b145cf2557a3f1d4e613ee2b.css integrity="sha256-cpjQCb28xcDa0hmTzWe0LeNN2ymxRc8lV6Px1OYT7is=" rel="preload stylesheet" as=style><meta property="og:title" content="ASP.NET Core integration tests with docker-compose on GitHub Actions"><meta property="og:description" content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on GitHub Actions."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/"><meta property="og:image" content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/ghactions-dockercompose-cover.png"><meta property="article:published_time" content="2020-12-12T14:27:00+00:00"><meta property="article:modified_time" content="2020-12-12T14:27:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/ghactions-dockercompose-cover.png"><meta name=twitter:title content="ASP.NET Core integration tests with docker-compose on GitHub Actions"><meta name=twitter:description content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on GitHub Actions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ASP.NET Core integration tests with docker-compose on GitHub Actions","name":"ASP.NET Core integration tests with docker-compose on GitHub Actions","description":"This is the forth (and last) post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose ‚Ä¶","keywords":["asp.net-core","github","github-actions","integration-tests","docker"],"articleBody":"This is the forth (and last) post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose for your ASP.NET + EF Core integration tests\n  Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines\n  Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions (this post)\n  In the previous post of the series we saw how to create and run our tests in a CI fashion using Azure Pipelines.\nIn this post, we‚Äôll see how to accomplish the same, but using GitHub Actions.\nTL;DR Go directly to the GitHub workflow yml\nThe full project on GitHub\nCreating our GitHub Workflow If you already use Azure Pipelines, you will be familiar with the concepts on GitHub Actions. A pipeline in Azure DevOps is a Workflow in GitHub Action. Nevertheless, I highly encourage you to go through the basics of GitHub Actions just so you don‚Äôt feel lost Introduction to GitHub Actions.\nIf it‚Äôs your first time dealing with this, don‚Äôt worry. I‚Äôll break down each part of the workflow and explain it at a high level, as in the last post.\nThis is how our final workflow yml file looks like:\nname: BlogAPI env: DOTNET_CLI_TELEMETRY_OPTOUT: 1 on: push: paths: - 'src/**' - 'tests/**' - 'BlogApp.sln' - 'Directory.Build.props' - '**/blogapi-workflow.yml' pull_request: paths: - 'src/**' - 'tests/**' - 'BlogApp.sln' - 'Directory.Build.props' - '**/blogapi-workflow.yml' workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Check out code uses: actions/checkout@v2 - name: Start dependencies (docker-compose) run: | docker-compose up -d  - name: Wait for SQL Server container uses: jakejarvis/wait-action@master with: time: '5s' - name: Install .NET Core SDK uses: actions/setup-dotnet@v1 with: dotnet-version: '3.1.x' - name: Restore NuGet packages run: dotnet restore - name: Build run: dotnet build -c Release --no-restore - name: Test run: dotnet test -c Release --no-build Let‚Äôs review the steps:\nName and env The name will be the name of your workflow when you visit the ‚ÄúActions‚Äù menu on your GitHub repo.\nThe env section lets you set environment variables. In this case, I‚Äôm opting out of the dotnet CLI telemetry collection.\nOn (triggers) The on section configures how and when the workflow runs. It is all based on hooks, and there are many of them to pick. In the example above I configured it to run on:\n each push (push) when a pull request is open (pull_request) manually via the Actions page (workflow_dispatch).  You can see all the triggers available here: Workflow webhook events.\nIn each event, you can also configure more things. In the workflow above I configured paths. This will make sure that the build runs when any file changes within the configured paths. There are other things you can configure, so be sure to check the documentation.\nJobs The job section is very similar (if not the same) to Azure Pipelines. We only have one job with a handful of tasks. Check this part of the documentation to learn more about the syntax and what you can do: Jobs.\nStart dependencies (docker-compose) As we know, our tests expect a SQL Server running on localhost,1433. Since Docker/compose is already installed, we just need to start it as usual with docker-compose up -d (-d for detached, because we don‚Äôt want to block the terminal).\nWait for SQL Server container Since it could take a few seconds for the SQL Server container to be up and ready to accept connections, I added this handy GitHub Action that enables us to ‚Äúwait‚Äù for some time before moving to the next task. This way we are sure the tests can talk with SQL Server.\nRestore, Build and Test The rest of the tasks are relatively self-explanatory and don‚Äôt deviate much from the commands you would normally run if you use the .NET Core CLI. But let‚Äôs review them anyway:\n  First, we need to have the proper .NET Core SDK installed. For this we can use the setup-dotnet GitHub Action (actions/setup-dotnet@v1) passing the SDK version we want.\n  Next, we use the normal CLI commands to restore, build, and test the project\n  That‚Äôs pretty much it! Now every time you push or open a pull request the workflow will run and our tests using Docker will be executed. See here a workflow run example.\nCreating the Workflow on GitHub GitHub actions expects our yml workflow files to be in a specific folder. Follow the steps:\n  In your repository, create the .github/workflows/ directory to store your workflow files.\n  In the .github/workflows/ directory, create a new file called blogapi-workflow.yml (or whatever name you want) and add the code we saw here before.\n  Commit the changes and push. Your GitHub Actions workflow is created and will run automatically!\n  Summary In this post, I showed you how we can run our tests using SQL Server on Docker over on GitHub Actions. We saw the yml file and we went through all the tasks that define it. If you feel a bit overwhelmed, it‚Äôs OK. It takes a bit of practice to get used to the syntax but I‚Äôm sure in no time you‚Äôll master it. üòé\nAs a closing consideration, I wanted to point out that there‚Äôs no silver bullet workflow, and what I presented here is just one way to do it. You could instead just write a PowerShell or Bash script that would do the same steps and your yml file would just run that.\nThat‚Äôs it for this series! I hope it was useful to you and that you learned something along the way. I sure did and implemented many of the things here in my day-to-day projects.\nThanks for reading.\nOctocat and the dotnet-bot image credits.\n","wordCount":"944","inLanguage":"en","image":"https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/ghactions-dockercompose-cover.png","datePublished":"2020-12-12T14:27:00Z","dateModified":"2020-12-12T14:27:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h>Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>ASP.NET Core integration tests with docker-compose on GitHub Actions</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/ghactions-dockercompose-cover.png alt="Octocat + GitHub Action + dotnet bot"></figure><div class=toc><details><summary><div class=details accesskey=c>Table of Contents</div></summary><blockquote><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#workflow-yml aria-label="Creating our GitHub Workflow">Creating our GitHub Workflow</a><ul><li><a href=#name-and-env aria-label="Name and env">Name and env</a></li><li><a href=#on-triggers aria-label="On (triggers)">On (triggers)</a></li><li><a href=#jobs aria-label=Jobs>Jobs</a><ul><li><a href=#start-dependencies-docker-compose aria-label="Start dependencies (docker-compose)">Start dependencies (docker-compose)</a></li><li><a href=#wait-for-sql-server-container aria-label="Wait for SQL Server container">Wait for SQL Server container</a></li><li><a href=#restore-build-and-test aria-label="Restore, Build and Test">Restore, Build and Test</a></li></ul></li></ul></li><li><a href=#creating-the-workflow-on-github aria-label="Creating the Workflow on GitHub">Creating the Workflow on GitHub</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></blockquote></details></div><div class=post-content><p>This is the forth (and last) post in the <a href=/series/integration-tests-in-asp.net-core>Integration tests in ASP.NET Core</a> series.</p><ul><li><p><a href=/limitations-ef-core-in-memory-database-providers>Part 1: Limitations of the EF Core in-memory database providers</a></p></li><li><p><a href=/using-docker-compose-for-your-asp-net-ef-core-integration-tests>Part 2: Using docker-compose for your ASP.NET + EF Core integration tests</a></p></li><li><p><a href=/asp-net-core-integration-tests-with-docker-compose-azure-pipelines>Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines</a></p></li><li><p><a href=/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions>Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions (this post)</a></p></li></ul><p>In the previous post of the series we saw how to create and run our tests in a <a href=https://en.wikipedia.org/wiki/Continuous_integration>CI</a> fashion using Azure Pipelines.</p><p>In this post, we&rsquo;ll see how to accomplish the same, but using GitHub Actions.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p><a href=#workflow-yml>Go directly to the GitHub workflow yml</a></p><p><a href=https://github.com/joaopgrassi/dockercompose-azdevops>The full project on GitHub</a></p><h2 id=workflow-yml>Creating our GitHub Workflow<a hidden class=anchor aria-hidden=true href=#workflow-yml>#</a></h2><p>If you already use Azure Pipelines, you will be familiar with the concepts on GitHub Actions. A pipeline in Azure DevOps is a Workflow in GitHub Action. Nevertheless, I highly encourage you to go through the basics of GitHub Actions just so you don&rsquo;t feel lost <a href=https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions>Introduction to GitHub Actions</a>.</p><p>If it&rsquo;s your first time dealing with this, don&rsquo;t worry. I&rsquo;ll break down each part of the workflow and explain it at a high level, as in the last post.</p><p>This is how our final workflow yml file looks like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>name</span>: <span style=color:#ae81ff>BlogAPI</span>
<span style=color:#f92672>env</span>:
  <span style=color:#f92672>DOTNET_CLI_TELEMETRY_OPTOUT</span>: <span style=color:#ae81ff>1</span>
<span style=color:#f92672>on</span>:
  <span style=color:#f92672>push</span>:
    <span style=color:#f92672>paths</span>:
      - <span style=color:#e6db74>&#39;src/**&#39;</span>
      - <span style=color:#e6db74>&#39;tests/**&#39;</span>
      - <span style=color:#e6db74>&#39;BlogApp.sln&#39;</span>
      - <span style=color:#e6db74>&#39;Directory.Build.props&#39;</span>
      - <span style=color:#e6db74>&#39;**/blogapi-workflow.yml&#39;</span>
  <span style=color:#f92672>pull_request</span>:
    <span style=color:#f92672>paths</span>:
      - <span style=color:#e6db74>&#39;src/**&#39;</span>
      - <span style=color:#e6db74>&#39;tests/**&#39;</span>
      - <span style=color:#e6db74>&#39;BlogApp.sln&#39;</span>
      - <span style=color:#e6db74>&#39;Directory.Build.props&#39;</span>
      - <span style=color:#e6db74>&#39;**/blogapi-workflow.yml&#39;</span>
  <span style=color:#f92672>workflow_dispatch</span>:
<span style=color:#f92672>jobs</span>:
  <span style=color:#f92672>build</span>:
    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
    <span style=color:#f92672>steps</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Check out code</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v2</span>
    
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Start dependencies (docker-compose)</span>
        <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>          </span>          <span style=color:#ae81ff>docker-compose up -d  </span>

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Wait for SQL Server container</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>jakejarvis/wait-action@master</span>
        <span style=color:#f92672>with</span>:
          <span style=color:#f92672>time</span>: <span style=color:#e6db74>&#39;5s&#39;</span>

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install .NET Core SDK</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/setup-dotnet@v1</span>
        <span style=color:#f92672>with</span>:
          <span style=color:#f92672>dotnet-version</span>: <span style=color:#e6db74>&#39;3.1.x&#39;</span>
    
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Restore NuGet packages</span>
        <span style=color:#f92672>run</span>: <span style=color:#ae81ff>dotnet restore</span>

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Build</span>
        <span style=color:#f92672>run</span>: <span style=color:#ae81ff>dotnet build -c Release --no-restore</span>
    
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Test</span>
        <span style=color:#f92672>run</span>: <span style=color:#ae81ff>dotnet test -c Release --no-build</span>
</code></pre></div><p>Let&rsquo;s review the steps:</p><h3 id=name-and-env>Name and env<a hidden class=anchor aria-hidden=true href=#name-and-env>#</a></h3><p>The <strong>name</strong> will be the name of your workflow when you visit the &ldquo;Actions&rdquo; menu on your GitHub repo.</p><p>The <strong>env</strong> section lets you set environment variables. In this case, I&rsquo;m opting out of the dotnet CLI telemetry collection.</p><h3 id=on-triggers>On (triggers)<a hidden class=anchor aria-hidden=true href=#on-triggers>#</a></h3><p>The <strong>on</strong> section configures how and when the workflow runs. It is all based on hooks, and there are many of them to pick. In the example above I configured it to run on:</p><ul><li>each push (<code>push</code>)</li><li>when a pull request is open (<code>pull_request</code>)</li><li>manually via the Actions page (<code>workflow_dispatch</code>).</li></ul><p>You can see all the triggers available here: <a href=https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows#webhook-events>Workflow webhook events</a>.</p><p>In each event, you can also configure more things. In the workflow above I configured <a href=https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpaths>paths</a>. This will make sure that the build runs when any file changes within the configured paths. There are other things you can configure, so be sure to check the documentation.</p><h3 id=jobs>Jobs<a hidden class=anchor aria-hidden=true href=#jobs>#</a></h3><p>The <strong>job</strong> section is very similar (if not the same) to Azure Pipelines. We only have one job with a handful of tasks. Check this part of the documentation to learn more about the syntax and what you can do: <a href=https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobs>Jobs</a>.</p><h4 id=start-dependencies-docker-compose>Start dependencies (docker-compose)<a hidden class=anchor aria-hidden=true href=#start-dependencies-docker-compose>#</a></h4><p>As we know, our tests expect a SQL Server running on <code>localhost,1433</code>. Since Docker/compose is already installed, we just need to start it as usual with <code>docker-compose up -d</code> (-d for detached, because we don&rsquo;t want to block the terminal).</p><h4 id=wait-for-sql-server-container>Wait for SQL Server container<a hidden class=anchor aria-hidden=true href=#wait-for-sql-server-container>#</a></h4><p>Since it could take a few seconds for the SQL Server container to be up and ready to accept connections, I added this <a href=https://github.com/jakejarvis/wait-action>handy GitHub Action</a> that enables us to &ldquo;wait&rdquo; for some time before moving to the next task. This way we are sure the tests can talk with SQL Server.</p><h4 id=restore-build-and-test>Restore, Build and Test<a hidden class=anchor aria-hidden=true href=#restore-build-and-test>#</a></h4><p>The rest of the tasks are relatively self-explanatory and don&rsquo;t deviate much from the commands you would normally run if you use the <a href=https://docs.microsoft.com/en-us/dotnet/core/tools/>.NET Core CLI</a>. But let&rsquo;s review them anyway:</p><ol><li><p>First, we need to have the proper .NET Core SDK installed. For this we can use the <a href=https://github.com/actions/setup-dotnet>setup-dotnet</a> GitHub Action (<code>actions/setup-dotnet@v1</code>) passing the SDK version we want.</p></li><li><p>Next, we use the normal CLI commands to <code>restore</code>, <code>build</code>, and <code>test</code> the project</p></li></ol><p>That&rsquo;s pretty much it! Now every time you push or open a pull request the workflow will run and our tests using Docker will be executed. <a href="https://github.com/joaopgrassi/dockercompose-azdevops/runs/1542654298?check_suite_focus=true">See here a workflow run example</a>.</p><h2 id=creating-the-workflow-on-github>Creating the Workflow on GitHub<a hidden class=anchor aria-hidden=true href=#creating-the-workflow-on-github>#</a></h2><p>GitHub actions expects our <code>yml</code> workflow files to be in a specific folder. Follow the steps:</p><ol><li><p>In your repository, create the <code>.github/workflows/</code> directory to store your workflow files.</p></li><li><p>In the <code>.github/workflows/</code> directory, create a new file called <code>blogapi-workflow.yml</code> (or whatever name you want) and add the code we saw here before.</p></li><li><p>Commit the changes and push. Your GitHub Actions workflow is created and will run automatically!</p></li></ol><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this post, I showed you how we can run our tests using SQL Server on Docker over on GitHub Actions. We saw the <code>yml</code> file and we went through all the tasks that define it. If you feel a bit overwhelmed, it&rsquo;s OK. It takes a bit of practice to get used to the syntax but I&rsquo;m sure in no time you&rsquo;ll master it. üòé</p><p>As a closing consideration, I wanted to point out that there&rsquo;s no <em>silver bullet</em> workflow, and what I presented here is just one way to do it. You could instead just write a PowerShell or Bash script that would do the same steps and your <code>yml</code> file would just run that.</p><p>That&rsquo;s it for this series! I hope it was useful to you and that you learned something along the way. I sure did and implemented many of the things here in my day-to-day projects.</p><p>Thanks for reading.</p><p><a href=https://github.com/logos>Octocat</a> and the <a href=https://github.com/dotnet/brand/blob/master/dotnet-bot-illustrations/dotnet-bot/dotnet-bot.png>dotnet-bot</a> image credits.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/github>github</a></li><li><a href=https://blog.joaograssi.com/tags/github-actions>github-actions</a></li><li><a href=https://blog.joaograssi.com/tags/integration-tests>integration-tests</a></li><li><a href=https://blog.joaograssi.com/tags/docker>docker</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};mybutton.onclick=function(){document.body.scrollTop=0;document.documentElement.scrollTop=0;window.location.hash=''}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>