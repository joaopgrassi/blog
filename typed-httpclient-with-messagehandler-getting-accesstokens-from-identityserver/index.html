<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,.net-core,identityserver,httpclientfactory,httpclient,accesstokens,oauth"><meta name=description content="Learn how to use the HttpClientFactory in conjunction with typed HttpClients and MessageHandlers to get access tokens implicitly from IdentityServer."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/typed-httpclient-with-messagehandler-getting-accesstokens-from-identityserver/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.e1ab5a6d2c103bea5816e8a73d5b790df987819379382379bab1664c1e016e49.css integrity="sha256-4atabSwQO+pYFuinPVt5DfmHgZN5OCN5urFmTB4Bbkk=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><link href=https://blog.joaograssi.com/assets/css/custom_blog.min.7298d009bdbcc5c0dad21993cd67b42de34ddb29b145cf2557a3f1d4e613ee2b.css integrity="sha256-cpjQCb28xcDa0hmTzWe0LeNN2ymxRc8lV6Px1OYT7is=" rel="preload stylesheet" as=style><meta property="og:title" content="Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler"><meta property="og:description" content="Learn how to use the HttpClientFactory in conjunction with typed HttpClients and MessageHandlers to get access tokens implicitly from IdentityServer."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/typed-httpclient-with-messagehandler-getting-accesstokens-from-identityserver/"><meta property="og:image" content="https://blog.joaograssi.com/content/images/2019/03/barbed-wire-on-green-background.jpg"><meta property="article:published_time" content="2019-03-06T21:57:00+00:00"><meta property="article:modified_time" content="2019-03-06T21:57:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/content/images/2019/03/barbed-wire-on-green-background.jpg"><meta name=twitter:title content="Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler"><meta name=twitter:description content="Learn how to use the HttpClientFactory in conjunction with typed HttpClients and MessageHandlers to get access tokens implicitly from IdentityServer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler","name":"Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler","description":"Recently, I had to interact with an external API which is protected by JWT Bearer Tokens. For this, I had to get an access_token first and then set it to each request. But, this …","keywords":["asp.net-core",".net-core","identityserver","httpclientfactory","httpclient","accesstokens","oauth"],"articleBody":"Recently, I had to interact with an external API which is protected by JWT Bearer Tokens. For this, I had to get an access_token first and then set it to each request. But, this can get quite tedious very soon even if you just do it a few times. In the end, I wanted an implementation that encapsulated the need for developers to worry about getting access tokens prior to communicating with the API.\nIn this post I’ll demonstrate how we can use the HttpClientFactory introduced back on ASP.NET Core 2.1 in conjunction with typed HttpClients and MessageHandlers, to achieve a nice and easy API abstraction over an external service.\nAside: If you don’t know what a HttpClientFactory is I strongly recommend you to read Steve Gordon’s series about it: HttpClientFactory in ASP.NET Core 2.1. Steve does a very good job on explaining what problems the factory solves and why you should care about it. Even if you are not using .ASP.NET Core I still recommend it, because it boils down to the issue we long have with the HttpClient class. Pause, go there and read it. Then come back here to (hopefully) learn more :)\nThe applications used to demonstrate this post In more detail, the scenario I described before is comprised of the following applications:\n  The Identity Provider (Going to use IdentityServer4)\n  An API which is protected by JWT tokens (still under our control, but as a completely separated service)\n  The “client” API which needs to get data from the protected API.\n  Graphic representation always helps in understanding how things are tied together. So, here’s is an image that represents the flow of requests between the applications laid out above:\nHow the apps communicate between themselves  If you are familiar with OAuth, you might recognize the flow above. Basically, we are going to communicate with our Protected API via the OAuth 2.0 Client Credentials Grant Type\nAll the code used in this post is available on GitHub: httpclient-token-identityserver\nTalking to our protected API It’s time to dig into the code. I’ll guide you through the approaches that we can use to talk with our “Protected API”, starting from the most simple and obvious one (not great, BTW) and, step-by-step we’ll improve it until we reach a nice and clean design. (at least I think so)\n Note: I’ll be using the IdentityModel NuGet package during this post. This is a very neat package that makes the interaction with Identity Server extremely easy by the use of extension methods on HttpClient. You are not required to use it, but you’ll have to write more code on your own :)\n Let’s remember what we have to do before we can consume our “Protected API”\n We need to get a hold of the credentials of our API (remember we are a “client”) We need to authenticate with Identity Server (using the credentials above) in order to obtain an access_token We need to set the access_token in the Authorization: Bearer  request header Send the request to our Protected API  Attempt 1 - “Works but it’s not great” approach [HttpGet(\"version1\")] public async Task GetVersionOne() { // 1. \"retrieve\" our api credentials. This must be registered on Identity Server!  var apiClientCredentials = new ClientCredentialsTokenRequest { Address = \"http://localhost:5000/connect/token\", ClientId = \"client-app\", ClientSecret = \"secret\", // This is the scope our Protected API requires.  Scope = \"read:entity\" }; // creates a new HttpClient to talk to our IdentityServer (localhost:5000)  var client = new HttpClient(); // just checks if we can reach the Discovery document. Not 100% needed but..  var disco = await client.GetDiscoveryDocumentAsync(\"http://localhost:5000\"); if (disco.IsError) { return StatusCode(500); } // 2. Authenticates and get an access token from Identity Server  var tokenResponse = await client.RequestClientCredentialsTokenAsync(apiClientCredentials); if (tokenResponse.IsError) { return StatusCode(500); } // Another HttpClient for talking now with our Protected API  var apiClient = new HttpClient(); // 3. Set the access_token in the request Authorization: Bearer   client.SetBearerToken(tokenResponse.AccessToken); // 4. Send a request to our Protected API  var response = await client.GetAsync(\"http://localhost:5002/api/protected\"); if (!response.IsSuccessStatusCode) { return StatusCode(500); } var content = await response.Content.ReadAsStringAsync(); // All good! We have the data here  return Ok(content); } This works but it’s not optimal. A few problems:\n Our credentials are hardcoded and created “on-the-fly” We create two HttpClients every time this endpoint is hit  If you’ve read Steve’s series mentioned earlier (or you already know the issue), you should have a guess on what’s wrong with this approach, right?\nAttempt 2 - Creating a typed HttpClient for Identity Server Every time we need to get an access_token we’ll have to do the same code from step 1 and 2. We can refactor that using the HttpClientFactory and typed HttpClient introduced in ASP.NET Core 2.1.\nOur Typed Identity Server client:\npublic interface IIdentityServerClient { Taskstring RequestClientCredentialsTokenAsync(); } public class IdentityServerClient : IIdentityServerClient { private readonly HttpClient _httpClient; private readonly ClientCredentialsTokenRequest _tokenRequest; private readonly ILogger _logger; public IdentityServerClient( HttpClient httpClient, ClientCredentialsTokenRequest tokenRequest, ILogger logger) { _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); _tokenRequest = tokenRequest ?? throw new ArgumentNullException(nameof(tokenRequest)); _logger = logger ?? throw new ArgumentNullException(nameof(logger)); } public async Taskstring RequestClientCredentialsTokenAsync() { // request the access token token  var tokenResponse = await _httpClient.RequestClientCredentialsTokenAsync(_tokenRequest); if (tokenResponse.IsError) { _logger.LogError(tokenResponse.Error); throw new HttpRequestException(\"Something went wrong while requesting the access token\"); } return tokenResponse.AccessToken; } } The code above is just an Interface and an implementing class that exposes one method: RequestClientCredentialsTokenAsync. It gets an access_token from Identity Server and returns it, very simple. This class also gets by the DI container an instance of ClientCredentialsTokenRequest which contains our credentials, so no more hardcoded stuff.\nYou might have noticed also the HttpClient injected into the constructor. This HttpClient is provided by the DI container to us and it’s “pre” configured. We’ll see how that works next.\nHow to register our typed HttpClient\nNow that we have our IdentityServerClient class ready, we need to register it within the DI container so we can request it later. This happens in our Startup.cs and more specifically in the ConfigureServices method:\npublic void public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.AddSingleton(new ClientCredentialsTokenRequest { Address = \"http://localhost:5000/connect/token\", ClientId = \"client-app\", ClientSecret = \"secret\", Scope = \"read:entity\" }); services.AddHttpClient(client = { client.BaseAddress = new Uri(\"http://localhost:5000\"); client.DefaultRequestHeaders.Add(\"Accept\", \"application/json\"); }); } First we register our ClientCredentialsTokenRequest as a Singleton. In a real-world app you would most likely read these values from appsettings.json, but to keep it simple we’ll leave it that way.\nNext is where the “magic” happens. We call the AddHttpClient extension method on IServiceCollection which, in this case, is adding a typed HttpClient. The AddHttpClient provides an overload where you can pass an Action and pre-configure the HttpClient that will get injected later. Here we are setting the BaseAddress of our IdentityServer and some default request headers. Now, every time I request an IIdentityServerClient I’ll get a HttpClient pre-configured with those values.\n There are other ways of registering Http clients. For instance, you could add a named client like AddHttpClient(\"MyClient\"). I tend to prefer strongly typed ones as they provide a more constrained API plus I avoid magic strings in my code.\n With our typed IdentityServerClient created and configured, let’s refactor our controller.\nprivate readonly IIdentityServerClient _identityServerClient; public ConsumerController(IIdentityServerClient identityServerClient) { _identityServerClient = identityServerClient; } [HttpGet(\"version2\")] public async Task GetVersionThree() { // uses our typed HttpClient to get an access_token from identity server  var accessToken = await _identityServerClient.RequestClientCredentialsTokenAsync(); // the rest is the same as in version1  var apiClient = new HttpClient(); apiClient.SetBearerToken(accessToken); var response = await apiClient.GetAsync(\"http://localhost:5002/api/protected\"); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); return StatusCode(500); } var content = await response.Content.ReadAsStringAsync(); return Ok(content); } Now our ConsumerController takes a dependency on IIdentityServerClient. Next, I added a new version2 endpoint which basically is a copy from version1 but without all the code that dealt with getting a token. That now is just one line. So much cleaner isn’t it?!\nWhen we call _identityServerClient.RequestClientCredentialsTokenAsync() in our verison2 endpoint, the framework will inject the ClientCredentialsTokenRequest singleton that we configured into the IdentityServerClient class and it will proceed to get and return the access_token from Identity Server.\nI think this version is way better than the first one. But we still create a new HttpClient for talking to our protected API. Let’s see how to fix that in the next step.\nAttempt 3 - Creating a typed HttpClient for our Protected API Now that we have seen how we can create and use a typed HttpClient, we can use the same approach and create a typed for our “Protected API”. A quick implementation looks like this:\npublic class ProtectedApiClient : IProtectedApiClient { private readonly IIdentityServerClient _identityServerClient; private readonly HttpClient _httpClient; public ProtectedApiClient( HttpClient httpClient, IIdentityServerClient identityServerClient) { _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); _identityServerClient = identityServerClient ?? throw new ArgumentNullException(nameof(identityServerClient)); } public async Taskstring GetProtectedResources() { // code to obtain and set the access_token in the header  var accessToken = await _identityServerClient.RequestClientCredentialsTokenAsync(); _httpClient.SetBearerToken(accessToken); // request data from our Protected API  var response = await _httpClient.GetAsync(\"/api/protected\"); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); throw new Exception(\"Failed to get protected resources.\"); } return await response.Content.ReadAsStringAsync(); } } Nothing special going on here. Since we need to get tokens, we take a dependency on IIdentityServerClient and we receive our typed HttpClient which was configured exactly as before.\nLet’s enumerate what we have improved so far:\n  Both clients are now managed by the HttpClientFactory. No more new HttpClient() in our code!\n  We have strongly typed interfaces that makes communicating with external services much easier (plus is so much more readable than looking and finding HttpClients all over the place)\n  But, we can improve this further. We can encapsulate the code for getting an access_token and remove that code from our ProtectedApiClient. We can achieve this by using Message Handlers.\nAttempt 3.1 - Using Message Handlers with our typed HttpClient We can make the “experience” of talking with our protected API via our typed client even better. Right now, we still have to worry about getting an access_token prior to actually doing what we need to do. In this case, getting a token prior to sending a request is what is known as a cross-cutting concern and Message Handlers are especially useful for cases like this.\nMessage Handlers have been around for some time now, so they are not something new or exclusively related to .NET Core. Here’s a definition (from 2012!) for it from docs.microsoft.com\n A message handler is a class that receives an HTTP request and returns an HTTP response. Typically, a series of message handlers are chained together. The first handler receives an HTTP request, does some processing, and gives the request to the next handler. At some point, the response is created and goes back up the chain. This pattern is called a delegating handler.\n Okay, this definition can be somewhat confusing and hard to absorb if you’ve never heard of it before. Analogies help me on bringing things into perspective, so perhaps this one might help you grasp the idea. You can skip to the next part if you want.\nImagine a scenario where you received your internet bill and it is $100 bucks more expensive than usual. You want to call the provider to straight things up. Your end goal is to talk to the manager in charge. Here’s a typical result of such a call:\nComplaining over the phone - an analogy to message handlers  Hopefully, this made things clearer?. In the flow above:\n  You (client) is who fired the “request”. Your request is picked up by the 1st contact (our Message Handler). He does his job with the request, for example, he increments it with an incident Id, for instance, and dispatches it to his boss, the next handler in line.\n  The manager is the last handler in the chain (the default/inner handler). He processes the request, and returns the results, in this case, the refund. The 1st contact picks it up and forwards it to you.\n  Creating our Message Handler Let’s then create our Message Handler that will be responsible for “incrementing” a request by adding an access_token to the Authorization header. We just need to create a class which inherits from the abstract DelegatingHandler class. Finally, we need to override the SendAsync and provide our logic.\npublic class ProtectedApiBearerTokenHandler : DelegatingHandler { private readonly IIdentityServerClient _identityServerClient; public ProtectedApiBearerTokenHandler( IIdentityServerClient identityServerClient) { _identityServerClient = identityServerClient ?? throw new ArgumentNullException(nameof(identityServerClient)); } protected override async Task SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { // request the access token  var accessToken = await _identityServerClient.RequestClientCredentialsTokenAsync(); // set the bearer token to the outgoing request  request.SetBearerToken(accessToken); // Proceed calling the inner handler, that will actually send the request  // to our protected api  return await base.SendAsync(request, cancellationToken); } } The key point in our handler is everything that happens before calling the next handler in line (where we do base.SendAsync). In our case, we are using the IIdentityServerClient we created before to request an access_token. With the token in hand, we add it to the Authorization header of the request. At this point, our “handler’s logic” is done. The last thing we need to do is to make sure we call the next handler in line. In our case, it will be the “inner” handler.\nThe inner handler will then call our Protected API. The response will “bubble” back first to the inner handler, then to our ProtectedApiBearerTokenHandler and finally back to us. Using the analogy from before, our handler is the “1st contact” from the internet provider company.\nRegistering and using our ProtectedApiBearerTokenHandler Now that we have our handler, we need to first register it in the DI container and change our code to use it. Let’s first refactor our ProtectedApiClient from before since we don’t need to get tokens anymore. Our Handler will take care of it :)\npublic class ProtectedApiClient : IProtectedApiClient { private readonly HttpClient _httpClient; public ProtectedApiClient(HttpClient httpClient) { _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient)); } public async Taskstring GetProtectedResources() { // No more getting access_tokens code!  var response = await _httpClient.GetAsync(\"/api/protected\"); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); throw new Exception(\"Failed to get protected resources.\"); } return await response.Content.ReadAsStringAsync(); } } As you can see, we cleaned our ProtectedApiClient from the dependency on IIdentityServerClient. We just use the HttpClient injected as if it was an “unauthenticated” request. Next, let’s register both the ProtectedApiClient and the ProtectedApiBearerTokenHandler in the DI container (inside ConfigureServices).\n// previous code omitted for brevity  // The DelegatingHandler has to be registered as a Transient Service services.AddTransient(); // Register our ProtectedApi client with a DelegatingHandler // that knows how to obtain an access_token services.AddHttpClient(client = { client.BaseAddress = new Uri(\"http://localhost:5002\"); client.DefaultRequestHeaders.Add(\"Accept\", \"application/json\"); }).AddHttpMessageHandler(); Final attempt - Using the ProtectedApiClient in our controller With both our typed client and message handler registered it’s time to refactor our controller! We’ll add another endpoint version3 and get a dependency on our IProtectedApiClient. Wait for it…\n[Route(\"api/[controller]\")] [ApiController] public class ConsumerController : ControllerBase { private readonly IProtectedApiClient _protectedApiClient; public ConsumerController( IProtectedApiClient protectedApiClient) { _protectedApiClient = protectedApiClient ?? throw new ArgumentNullException(nameof(protectedApiClient)); } //Uses the typed HttpClient that implicitly gets the access_token from IdentityServer [HttpGet(\"version3\")] public async Task GetVersionFour() { var result = await _protectedApiClient.GetProtectedResources(); return Ok(result); } } Whoa. What an improvement, huh? We went from 48 lines of code on version1 to only 2 lines on version3. We are not creating HttpClients anymore and we have nice interfaces that behave like “client” libraries to our external services. In fact, you could even turn these typed clients into a NuGet package that can be distributed let’s say, between departments within your company.\nFinal thoughts I hope I helped you understand all the benefits the HttpClientFactory and its fellow companions can bring to your application. I myself learned a lot while actually coding this in a real app, and then trimming it down so I could write this post.\nOne thing I want to share is: The ProtectedApiBearerTokenHandler I demonstrated here works but it’s not optimal for production usage. I didn’t touch on subjects like caching the access tokens for instance, but it’s something you should really think about it in your application, and with that also comes thread safety and so on.\nI mentioned a couple of times during the post about the IdentityModel NuGet package from the Identity Server “eco-system”. The IdentityModel package also offers a MessageHandler that does the same thing I showed you here (handling access tokens). If you want a solid version to use in your apps, I strongly recommend checking it out: RefreshTokenDelegatingHandler.cs\nLinks and references  https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-message-handlers https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore https://www.stevejgordon.co.uk/httpclient-creation-and-disposal-internals-should-i-dispose-of-httpclient https://github.com/IdentityModel/IdentityModel2 https://odetocode.com/blogs/scott/archive/2013/04/04/webapi-tip-7-beautiful-message-handlers.aspx  Credits: Photo on Visual Hunt\n","wordCount":"2754","inLanguage":"en","image":"https://blog.joaograssi.com/content/images/2019/03/barbed-wire-on-green-background.jpg","datePublished":"2019-03-06T21:57:00Z","dateModified":"2019-03-06T21:57:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/typed-httpclient-with-messagehandler-getting-accesstokens-from-identityserver/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h>Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Encapsulating getting access tokens from IdentityServer with a typed HttpClient and MessageHandler</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/content/images/2019/03/barbed-wire-on-green-background.jpg alt="Barbed wire on a green background"></figure><div class=post-content><p>Recently, I had to interact with an external API which is protected by JWT Bearer Tokens. For this, I had to get an access_token first and then set it to each request. But, this can get quite tedious very soon even if you just do it a few times. In the end, I wanted an implementation that encapsulated the need for developers to worry about getting access tokens prior to communicating with the API.</p><p>In this post I&rsquo;ll demonstrate how we can use the HttpClientFactory introduced back on ASP.NET Core 2.1 in conjunction with typed HttpClients and MessageHandlers, to achieve a nice and easy API abstraction over an external service.</p><p>Aside: If you don&rsquo;t know what a HttpClientFactory is I strongly recommend you to read Steve Gordon&rsquo;s series about it: HttpClientFactory in ASP.NET Core 2.1. Steve does a very good job on explaining what problems the factory solves and why you should care about it. Even if you are not using .ASP.NET Core I still recommend it, because it boils down to the issue we long have with the HttpClient class. Pause, go there and read it. Then come back here to (hopefully) learn more :)</p><h2 id=the-applications-used-to-demonstrate-this-post>The applications used to demonstrate this post<a hidden class=anchor aria-hidden=true href=#the-applications-used-to-demonstrate-this-post>#</a></h2><p>In more detail, the scenario I described before is comprised of the following applications:</p><ol><li><p>The Identity Provider (Going to use IdentityServer4)</p></li><li><p>An API which is protected by JWT tokens (still under our control, but as a completely separated service)</p></li><li><p>The &ldquo;client&rdquo; API which needs to get data from the protected API.</p></li></ol><p>Graphic representation always helps in understanding how things are tied together. So, here&rsquo;s is an image that represents the flow of requests between the applications laid out above:</p><figure class=figure-border><img class=img-center src=/typed-httpclient-with-messagehandler-getting-accesstokens-from-identityserver/client_credentials_flow-1.svg alt="How the apps communicate between themselves" loading=lazy><figcaption class=img-caption>How the apps communicate between themselves</figcaption></figure><p>If you are familiar with OAuth, you might recognize the flow above. Basically, we are going to communicate with our Protected API via the <a href=https://tools.ietf.org/html/rfc6749#section-4.4>OAuth 2.0 Client Credentials Grant Type</a></p><p>All the code used in this post is available on GitHub: <a href=https://github.com/joaopgrassi/httpclient-token-identityserver>httpclient-token-identityserver</a></p><h2 id=talking-to-our-protected-api>Talking to our protected API<a hidden class=anchor aria-hidden=true href=#talking-to-our-protected-api>#</a></h2><p>It&rsquo;s time to dig into the code. I&rsquo;ll guide you through the approaches that we can use to talk with our &ldquo;Protected API&rdquo;, starting from the most simple and obvious one (not great, BTW) and, step-by-step we&rsquo;ll improve it until we reach a nice and clean design. (at least I think so)</p><blockquote><p><strong>Note</strong>: I&rsquo;ll be using the <a href=https://identitymodel.readthedocs.io/en/latest/>IdentityModel</a> NuGet package during this post. This is a very neat package that makes the interaction with Identity Server extremely easy by the use of extension methods on <code>HttpClient</code>. You are not required to use it, but you&rsquo;ll have to write more code on your own :)</p></blockquote><p>Let&rsquo;s remember what we have to do before we can consume our &ldquo;Protected API&rdquo;</p><ol><li>We need to get a hold of the credentials of our API (remember we are a &ldquo;client&rdquo;)</li><li>We need to authenticate with Identity Server (using the credentials above) in order to obtain an <code>access_token</code></li><li>We need to set the <code>access_token</code> in the <code>Authorization: Bearer &lt;token></code> request header</li><li>Send the request to our Protected API</li></ol><h3 id=attempt-1---works-but-its-not-great-approach>Attempt 1 - &ldquo;Works but it&rsquo;s not great&rdquo; approach<a hidden class=anchor aria-hidden=true href=#attempt-1---works-but-its-not-great-approach>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[HttpGet(&#34;version1&#34;)]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; GetVersionOne()
{
    <span style=color:#75715e>// 1. &#34;retrieve&#34; our api credentials. This must be registered on Identity Server!
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> apiClientCredentials = <span style=color:#66d9ef>new</span> ClientCredentialsTokenRequest
    {
        Address = <span style=color:#e6db74>&#34;http://localhost:5000/connect/token&#34;</span>,

        ClientId = <span style=color:#e6db74>&#34;client-app&#34;</span>,
        ClientSecret = <span style=color:#e6db74>&#34;secret&#34;</span>,

        <span style=color:#75715e>// This is the scope our Protected API requires. 
</span><span style=color:#75715e></span>        Scope = <span style=color:#e6db74>&#34;read:entity&#34;</span>
    };

    <span style=color:#75715e>// creates a new HttpClient to talk to our IdentityServer (localhost:5000)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> client = <span style=color:#66d9ef>new</span> HttpClient();

    <span style=color:#75715e>// just checks if we can reach the Discovery document. Not 100% needed but..
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> disco = <span style=color:#66d9ef>await</span> client.GetDiscoveryDocumentAsync(<span style=color:#e6db74>&#34;http://localhost:5000&#34;</span>);
    <span style=color:#66d9ef>if</span> (disco.IsError)
    {
        <span style=color:#66d9ef>return</span> StatusCode(<span style=color:#ae81ff>500</span>);
    }

    <span style=color:#75715e>// 2. Authenticates and get an access token from Identity Server
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> tokenResponse = <span style=color:#66d9ef>await</span> client.RequestClientCredentialsTokenAsync(apiClientCredentials);
    <span style=color:#66d9ef>if</span> (tokenResponse.IsError)
    {
        <span style=color:#66d9ef>return</span> StatusCode(<span style=color:#ae81ff>500</span>);
    }

    <span style=color:#75715e>// Another HttpClient for talking now with our Protected API
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> apiClient = <span style=color:#66d9ef>new</span> HttpClient();

    <span style=color:#75715e>// 3. Set the access_token in the request Authorization: Bearer &lt;token&gt;
</span><span style=color:#75715e></span>    client.SetBearerToken(tokenResponse.AccessToken);

    <span style=color:#75715e>// 4. Send a request to our Protected API
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> client.GetAsync(<span style=color:#e6db74>&#34;http://localhost:5002/api/protected&#34;</span>);
    <span style=color:#66d9ef>if</span> (!response.IsSuccessStatusCode)
    {
        <span style=color:#66d9ef>return</span> StatusCode(<span style=color:#ae81ff>500</span>);
    }

    <span style=color:#66d9ef>var</span> content = <span style=color:#66d9ef>await</span> response.Content.ReadAsStringAsync();

    <span style=color:#75715e>// All good! We have the data here
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> Ok(content);
}
</code></pre></div><p>This works but it&rsquo;s not optimal. A few problems:</p><ol><li>Our credentials are hardcoded and created &ldquo;on-the-fly&rdquo;</li><li>We create two <code>HttpClient</code>s every time this endpoint is hit</li></ol><p>If you&rsquo;ve read Steve&rsquo;s series mentioned earlier (or you already know the issue), you should have a guess on what&rsquo;s wrong with this approach, right?</p><h3 id=attempt-2---creating-a-typed-httpclient-for-identity-server>Attempt 2 - Creating a typed <code>HttpClient</code> for Identity Server<a hidden class=anchor aria-hidden=true href=#attempt-2---creating-a-typed-httpclient-for-identity-server>#</a></h3><p>Every time we need to get an <code>access_token</code> we&rsquo;ll have to do the same code from step 1 and 2. We can refactor that using the <code>HttpClientFactory</code> and typed <code>HttpClient</code> introduced in ASP.NET Core 2.1.</p><p><strong>Our Typed Identity Server client:</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> IIdentityServerClient
{
    Task&lt;<span style=color:#66d9ef>string</span>&gt; RequestClientCredentialsTokenAsync();
}

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IdentityServerClient</span> : IIdentityServerClient
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> HttpClient _httpClient;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ClientCredentialsTokenRequest _tokenRequest;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ILogger&lt;IdentityServerClient&gt; _logger;

    <span style=color:#66d9ef>public</span> IdentityServerClient(
        HttpClient httpClient, 
        ClientCredentialsTokenRequest tokenRequest,
        ILogger&lt;IdentityServerClient&gt; logger)
    {
        _httpClient = httpClient ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(httpClient));
        _tokenRequest = tokenRequest ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(tokenRequest));
        _logger = logger ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(logger));
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>string</span>&gt; RequestClientCredentialsTokenAsync()
    {
        <span style=color:#75715e>// request the access token token
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> tokenResponse = <span style=color:#66d9ef>await</span> _httpClient.RequestClientCredentialsTokenAsync(_tokenRequest);
        <span style=color:#66d9ef>if</span> (tokenResponse.IsError)
        {
            _logger.LogError(tokenResponse.Error);
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> HttpRequestException(<span style=color:#e6db74>&#34;Something went wrong while requesting the access token&#34;</span>);
        }
        <span style=color:#66d9ef>return</span> tokenResponse.AccessToken;
    }
}
</code></pre></div><p>The code above is just an Interface and an implementing class that exposes one method: <code>RequestClientCredentialsTokenAsync</code>. It gets an <code>access_token</code> from Identity Server and returns it, very simple. This class also gets by the DI container an instance of <code>ClientCredentialsTokenRequest</code> which contains our credentials, so no more hardcoded stuff.</p><p>You might have noticed also the <code>HttpClient</code> injected into the constructor. This <code>HttpClient</code> is provided by the DI container to us and it&rsquo;s &ldquo;pre&rdquo; configured. We&rsquo;ll see how that works next.</p><p><strong>How to register our typed HttpClient</strong></p><p>Now that we have our <code>IdentityServerClient</code> class ready, we need to register it within the DI container so we can request it later. This happens in our <code>Startup.cs</code> and more specifically in the <code>ConfigureServices</code> method:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services)
{
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

    services.AddSingleton(<span style=color:#66d9ef>new</span> ClientCredentialsTokenRequest
    {
        Address = <span style=color:#e6db74>&#34;http://localhost:5000/connect/token&#34;</span>,
        ClientId = <span style=color:#e6db74>&#34;client-app&#34;</span>,
        ClientSecret = <span style=color:#e6db74>&#34;secret&#34;</span>,
        Scope = <span style=color:#e6db74>&#34;read:entity&#34;</span>
    });

    services.AddHttpClient&lt;IIdentityServerClient, IdentityServerClient&gt;(client =&gt;
    {
        client.BaseAddress = <span style=color:#66d9ef>new</span> Uri(<span style=color:#e6db74>&#34;http://localhost:5000&#34;</span>);
        client.DefaultRequestHeaders.Add(<span style=color:#e6db74>&#34;Accept&#34;</span>, <span style=color:#e6db74>&#34;application/json&#34;</span>);
    });
}
</code></pre></div><p>First we register our <code>ClientCredentialsTokenRequest</code> as a Singleton. In a real-world app you would most likely read these values from <code>appsettings.json</code>, but to keep it simple we&rsquo;ll leave it that way.</p><p>Next is where the &ldquo;magic&rdquo; happens. We call the <code>AddHttpClient</code> extension method on <code>IServiceCollection</code> which, in this case, is adding a <strong>typed</strong> <code>HttpClient</code>. The <code>AddHttpClient</code> provides an overload where you can pass an <code>Action&lt;HttpClient></code> <strong>and pre-configure the HttpClient that will get injected later</strong>. Here we are setting the <code>BaseAddress</code> of our IdentityServer and some default request headers. Now, every time I request an <code>IIdentityServerClient</code> I&rsquo;ll get a <code>HttpClient</code> pre-configured with those values.</p><blockquote><p>There are other ways of registering Http clients. For instance, you could add a <strong>named</strong> client like <code>AddHttpClient("MyClient")</code>. I tend to prefer strongly typed ones as they provide a more constrained API plus I avoid magic strings in my code.</p></blockquote><p>With our typed <code>IdentityServerClient</code> created and configured, let&rsquo;s refactor our controller.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IIdentityServerClient _identityServerClient;

<span style=color:#66d9ef>public</span> ConsumerController(IIdentityServerClient identityServerClient)
{
    _identityServerClient = identityServerClient;
}
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[HttpGet(&#34;version2&#34;)]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; GetVersionThree()
{
    <span style=color:#75715e>// uses our typed HttpClient to get an access_token from identity server
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> accessToken = <span style=color:#66d9ef>await</span> _identityServerClient.RequestClientCredentialsTokenAsync();

    <span style=color:#75715e>// the rest is the same as in version1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> apiClient = <span style=color:#66d9ef>new</span> HttpClient();
    apiClient.SetBearerToken(accessToken);

    <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> apiClient.GetAsync(<span style=color:#e6db74>&#34;http://localhost:5002/api/protected&#34;</span>);
    <span style=color:#66d9ef>if</span> (!response.IsSuccessStatusCode)
    {
        Console.WriteLine(response.StatusCode);
        <span style=color:#66d9ef>return</span> StatusCode(<span style=color:#ae81ff>500</span>);
    }
    <span style=color:#66d9ef>var</span> content = <span style=color:#66d9ef>await</span> response.Content.ReadAsStringAsync();
    <span style=color:#66d9ef>return</span> Ok(content);
}
</code></pre></div><p>Now our <code>ConsumerController</code> takes a dependency on <code>IIdentityServerClient</code>. Next, I added a new <code>version2</code> endpoint which basically is a copy from <code>version1</code> but without all the code that dealt with getting a token. That now is just <strong>one line</strong>. So much cleaner isn&rsquo;t it?!</p><p>When we call <code>_identityServerClient.RequestClientCredentialsTokenAsync()</code> in our <code>verison2</code> endpoint, the framework will inject the <code>ClientCredentialsTokenRequest</code> singleton that we configured into the <code>IdentityServerClient</code> class and it will proceed to get and return the <code>access_token</code> from Identity Server.</p><p>I think this version is way better than the first one. But we still create a new <code>HttpClient</code> for talking to our protected API. Let&rsquo;s see how to fix that in the next step.</p><h3 id=attempt-3---creating-a-typed-httpclient-for-our-protected-api>Attempt 3 - Creating a typed <code>HttpClient</code> for our Protected API<a hidden class=anchor aria-hidden=true href=#attempt-3---creating-a-typed-httpclient-for-our-protected-api>#</a></h3><p>Now that we have seen how we can create and use a typed HttpClient, we can use the same approach and create a typed for our &ldquo;Protected API&rdquo;. A quick implementation looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProtectedApiClient</span> : IProtectedApiClient
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IIdentityServerClient _identityServerClient;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> HttpClient _httpClient;

    <span style=color:#66d9ef>public</span> ProtectedApiClient(
        HttpClient httpClient, 
        IIdentityServerClient identityServerClient)
    {
        _httpClient = httpClient ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(httpClient));
        _identityServerClient = identityServerClient 
            ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(identityServerClient));
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>string</span>&gt; GetProtectedResources()
    {
        <span style=color:#75715e>// code to obtain and set the access_token in the header
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> accessToken = <span style=color:#66d9ef>await</span> _identityServerClient.RequestClientCredentialsTokenAsync();
        _httpClient.SetBearerToken(accessToken);

        <span style=color:#75715e>// request data from our Protected API
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> _httpClient.GetAsync(<span style=color:#e6db74>&#34;/api/protected&#34;</span>);
        <span style=color:#66d9ef>if</span> (!response.IsSuccessStatusCode)
        {
            Console.WriteLine(response.StatusCode);
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Failed to get protected resources.&#34;</span>);
        }
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> response.Content.ReadAsStringAsync();
    }
}
</code></pre></div><p>Nothing special going on here. Since we need to get tokens, we take a dependency on <code>IIdentityServerClient</code> and we receive our typed <code>HttpClient</code> which was configured exactly as before.</p><p>Let&rsquo;s enumerate what we have improved so far:</p><ol><li><p>Both clients are now managed by the <code>HttpClientFactory</code>. No more <code>new HttpClient()</code> in our code!</p></li><li><p>We have strongly typed interfaces that makes communicating with external services much easier (plus is so much more readable than looking and finding HttpClients all over the place)</p></li></ol><p>But, we can improve this further. We can encapsulate the code for getting an <code>access_token</code> and remove that code from our <code>ProtectedApiClient</code>. We can achieve this by using <code>Message Handlers</code>.</p><h3 id=attempt-31---using-message-handlers-with-our-typed-httpclient>Attempt 3.1 - Using Message Handlers with our typed <code>HttpClient</code><a hidden class=anchor aria-hidden=true href=#attempt-31---using-message-handlers-with-our-typed-httpclient>#</a></h3><p>We can make the &ldquo;experience&rdquo; of talking with our protected API via our typed client even better. Right now, we still have to worry about getting an <code>access_token</code> prior to actually doing what we need to do. In this case, getting a token prior to sending a request is what is known as a <em>cross-cutting</em> concern and Message Handlers are especially useful for cases like this.</p><p>Message Handlers have been around for some time now, so they are not something new or exclusively related to .NET Core. Here&rsquo;s a definition (from 2012!) for it from <a href=https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers>docs.microsoft.com</a></p><blockquote><p>A message handler is a class that receives an HTTP request and returns an HTTP response. Typically, a series of message handlers are chained together. The first handler receives an HTTP request, does some processing, and gives the request to the next handler. At some point, the response is created and goes back up the chain. This pattern is called a delegating handler.</p></blockquote><p>Okay, this definition can be somewhat confusing and hard to absorb if you&rsquo;ve never heard of it before. Analogies help me on bringing things into perspective, so perhaps this one might help you grasp the idea. You can skip to the next part if you want.</p><p>Imagine a scenario where you received your internet bill and it is $100 bucks more expensive than usual. You want to call the provider to straight things up. Your end goal is to talk to the manager in charge. Here&rsquo;s a typical result of such a call:</p><figure class=figure-border><img class=img-center src=/typed-httpclient-with-messagehandler-getting-accesstokens-from-identityserver/phone-call-diagram-2.svg alt="Complaining over the phone - an analogy to message handlers" loading=lazy><figcaption class=img-caption>Complaining over the phone - an analogy to message handlers</figcaption></figure><p>Hopefully, this made things clearer?. In the flow above:</p><ol><li><p><strong>You</strong> (client) is who fired the &ldquo;request&rdquo;. Your request is picked up by the <strong>1st contact</strong> (our <code>Message Handler</code>). He does his job with the request, for example, he <strong>increments it with an incident Id, for instance,</strong> and <strong>dispatches</strong> it to his boss, the next handler in line.</p></li><li><p><strong>The manager</strong> is the last handler in the chain (the default/inner handler). He processes the request, and returns the results, in this case, the refund. The 1st contact picks it up and forwards it to you.</p></li></ol><h4 id=creating-our-message-handler>Creating our Message Handler<a hidden class=anchor aria-hidden=true href=#creating-our-message-handler>#</a></h4><p>Let&rsquo;s then create our <code>Message Handler</code> that will be responsible for &ldquo;incrementing&rdquo; a request by adding an <code>access_token</code> to the <code>Authorization</code> header. We just need to create a class which inherits from the abstract <code>DelegatingHandler</code> class. Finally, we need to override the <code>SendAsync</code> and provide our logic.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProtectedApiBearerTokenHandler</span> : DelegatingHandler
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IIdentityServerClient _identityServerClient;

    <span style=color:#66d9ef>public</span> ProtectedApiBearerTokenHandler(
        IIdentityServerClient identityServerClient)
    {
        _identityServerClient = identityServerClient 
            ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(identityServerClient));
    }

    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request, 
        CancellationToken cancellationToken)
    {
        <span style=color:#75715e>// request the access token
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> accessToken = <span style=color:#66d9ef>await</span> _identityServerClient.RequestClientCredentialsTokenAsync();

        <span style=color:#75715e>// set the bearer token to the outgoing request
</span><span style=color:#75715e></span>        request.SetBearerToken(accessToken);

        <span style=color:#75715e>// Proceed calling the inner handler, that will actually send the request
</span><span style=color:#75715e></span>        <span style=color:#75715e>// to our protected api
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>base</span>.SendAsync(request, cancellationToken);
    }
}
</code></pre></div><p>The key point in our handler is everything that happens <strong>before</strong> calling the next handler in line (where we do <code>base.SendAsync</code>). In our case, we are using the <code>IIdentityServerClient</code> we created before to request an <code>access_token</code>. With the token in hand, we add it to the <code>Authorization</code> header of the request. At this point, our &ldquo;handler&rsquo;s logic&rdquo; is done. The last thing we need to do is to make sure we call the next handler in line. In our case, it will be the &ldquo;inner&rdquo; handler.</p><p>The inner handler will then call our Protected API. The response will &ldquo;bubble&rdquo; back first to the inner handler, then to our <code>ProtectedApiBearerTokenHandler</code> and finally back to us. Using the analogy from before, our handler is the &ldquo;1st contact&rdquo; from the internet provider company.</p><h4 id=registering-and-using-our-protectedapibearertokenhandler>Registering and using our <code>ProtectedApiBearerTokenHandler</code><a hidden class=anchor aria-hidden=true href=#registering-and-using-our-protectedapibearertokenhandler>#</a></h4><p>Now that we have our handler, we need to first register it in the DI container and change our code to use it. Let&rsquo;s first refactor our <code>ProtectedApiClient</code> from before since we don&rsquo;t need to get tokens anymore. Our Handler will take care of it :)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProtectedApiClient</span> : IProtectedApiClient
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> HttpClient _httpClient;

    <span style=color:#66d9ef>public</span> ProtectedApiClient(HttpClient httpClient)
    {
        _httpClient = httpClient ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(httpClient));
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>string</span>&gt; GetProtectedResources()
    {
        <span style=color:#75715e>// No more getting access_tokens code!
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> _httpClient.GetAsync(<span style=color:#e6db74>&#34;/api/protected&#34;</span>);
        <span style=color:#66d9ef>if</span> (!response.IsSuccessStatusCode)
        {
            Console.WriteLine(response.StatusCode);
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Failed to get protected resources.&#34;</span>);
        }
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> response.Content.ReadAsStringAsync();
    }
}
</code></pre></div><p>As you can see, we cleaned our <code>ProtectedApiClient</code> from the dependency on <code>IIdentityServerClient</code>. We just use the <code>HttpClient</code> injected as if it was an &ldquo;unauthenticated&rdquo; request. Next, let&rsquo;s register both the <code>ProtectedApiClient</code> and the <code>ProtectedApiBearerTokenHandler</code> in the DI container (inside <code>ConfigureServices</code>).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// previous code omitted for brevity
</span><span style=color:#75715e></span>
<span style=color:#75715e>// The DelegatingHandler has to be registered as a Transient Service
</span><span style=color:#75715e></span>services.AddTransient&lt;ProtectedApiBearerTokenHandler&gt;();

<span style=color:#75715e>// Register our ProtectedApi client with a DelegatingHandler
</span><span style=color:#75715e>// that knows how to obtain an access_token
</span><span style=color:#75715e></span>services.AddHttpClient&lt;IProtectedApiClient, ProtectedApiClient&gt;(client =&gt;
{
    client.BaseAddress = <span style=color:#66d9ef>new</span> Uri(<span style=color:#e6db74>&#34;http://localhost:5002&#34;</span>);
    client.DefaultRequestHeaders.Add(<span style=color:#e6db74>&#34;Accept&#34;</span>, <span style=color:#e6db74>&#34;application/json&#34;</span>);
}).AddHttpMessageHandler&lt;ProtectedApiBearerTokenHandler&gt;();
</code></pre></div><h3 id=final-attempt---using-the-protectedapiclient-in-our-controller>Final attempt - Using the <code>ProtectedApiClient</code> in our controller<a hidden class=anchor aria-hidden=true href=#final-attempt---using-the-protectedapiclient-in-our-controller>#</a></h3><p>With both our typed client and message handler registered it&rsquo;s time to refactor our controller! We&rsquo;ll add another endpoint <code>version3</code> and get a dependency on our <code>IProtectedApiClient</code>. Wait for it&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[Route(&#34;api/[controller]</span><span style=color:#e6db74>&#34;)]
</span><span style=color:#e6db74></span><span style=color:#a6e22e>[ApiController]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConsumerController</span> : ControllerBase
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IProtectedApiClient _protectedApiClient;

    <span style=color:#66d9ef>public</span> ConsumerController(
        IProtectedApiClient protectedApiClient)
    {
        _protectedApiClient = protectedApiClient 
        ?? <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(nameof(protectedApiClient));
    }

    <span style=color:#75715e>//Uses the typed HttpClient that implicitly gets the access_token from IdentityServer
</span><span style=color:#75715e></span><span style=color:#a6e22e>    [HttpGet(&#34;version3&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; GetVersionFour()
    {
        <span style=color:#66d9ef>var</span> result = <span style=color:#66d9ef>await</span> _protectedApiClient.GetProtectedResources();
        <span style=color:#66d9ef>return</span> Ok(result);
    }
}
</code></pre></div><p>Whoa. What an improvement, huh? We went from <strong>48</strong> lines of code on <code>version1</code> to <strong>only 2</strong> lines on <code>version3</code>. We are not creating <code>HttpClient</code>s anymore and we have nice interfaces that behave like &ldquo;client&rdquo; libraries to our external services. In fact, you could even turn these typed clients into a NuGet package that can be distributed let&rsquo;s say, between departments within your company.</p><h2 id=final-thoughts>Final thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h2><p>I hope I helped you understand all the benefits the <code>HttpClientFactory</code> and its fellow companions can bring to your application. I myself learned a lot while actually coding this in a real app, and then trimming it down so I could write this post.</p><p>One thing I want to share is: The <code>ProtectedApiBearerTokenHandler</code> I demonstrated here works but it&rsquo;s not optimal for production usage. I didn&rsquo;t touch on subjects like caching the access tokens for instance, but it&rsquo;s something you should really think about it in your application, and with that also comes thread safety and so on.</p><p>I mentioned a couple of times during the post about the <code>IdentityModel</code> NuGet package from the Identity Server &ldquo;eco-system&rdquo;. The <code>IdentityModel</code> package also offers a <code>MessageHandler</code> that does the same thing I showed you here (handling access tokens). If you want a solid version to use in your apps, I strongly recommend checking it out: <a href=https://github.com/IdentityModel/IdentityModel2/blob/master/src/Client/RefreshTokenDelegatingHandler.cs>RefreshTokenDelegatingHandler.cs</a></p><h2 id=links-and-references>Links and references<a hidden class=anchor aria-hidden=true href=#links-and-references>#</a></h2><ol><li><a href=https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-message-handlers>https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-message-handlers</a></li><li><a href=https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore>https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore</a></li><li><a href=https://www.stevejgordon.co.uk/httpclient-creation-and-disposal-internals-should-i-dispose-of-httpclient>https://www.stevejgordon.co.uk/httpclient-creation-and-disposal-internals-should-i-dispose-of-httpclient</a></li><li><a href=https://github.com/IdentityModel/IdentityModel2>https://github.com/IdentityModel/IdentityModel2</a></li><li><a href=https://odetocode.com/blogs/scott/archive/2013/04/04/webapi-tip-7-beautiful-message-handlers.aspx>https://odetocode.com/blogs/scott/archive/2013/04/04/webapi-tip-7-beautiful-message-handlers.aspx</a></li></ol><h3 id=credits>Credits:<a hidden class=anchor aria-hidden=true href=#credits>#</a></h3><p>Photo on <a href=https://visualhunt.com/photo4/11756/barbed-wire-on-green-background/>Visual Hunt</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/.net-core>.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/identityserver>identityserver</a></li><li><a href=https://blog.joaograssi.com/tags/httpclientfactory>httpclientfactory</a></li><li><a href=https://blog.joaograssi.com/tags/httpclient>httpclient</a></li><li><a href=https://blog.joaograssi.com/tags/accesstokens>accesstokens</a></li><li><a href=https://blog.joaograssi.com/tags/oauth>oauth</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};mybutton.onclick=function(){document.body.scrollTop=0;document.documentElement.scrollTop=0;window.location.hash=''}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>