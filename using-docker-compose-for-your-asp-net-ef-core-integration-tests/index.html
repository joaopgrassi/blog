<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using docker-compose for your ASP.NET + EF Core integration tests | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,.net-core,integration-tests,entity-framework-core,docker"><meta name=description content="In this post, we will be looking at how can you run the integration tests of an ASP.NET + EF Core app against a &#34;full&#34; SQL Server instead of using the in-memory database providers."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/using-docker-compose-for-your-asp-net-ef-core-integration-tests/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.5df15aa0fa69a07f461d7f7c1614ad5deed5c58a9894e3e7595bf68d9e7d3414.css integrity="sha256-XfFaoPppoH9GHX98FhStXe7VxYqYlOPnWVv2jZ59NBQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content="Using docker-compose for your ASP.NET + EF Core integration tests"><meta property="og:description" content="In this post, we will be looking at how can you run the integration tests of an ASP.NET + EF Core app against a &#34;full&#34; SQL Server instead of using the in-memory database providers."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/using-docker-compose-for-your-asp-net-ef-core-integration-tests/"><meta property="og:image" content="https://blog.joaograssi.com/content/images/2020/08/using-docker-compose-for-your-asp-net-ef-core-integration-tests.jpg"><meta property="article:published_time" content="2020-08-13T21:21:00+00:00"><meta property="article:modified_time" content="2020-08-13T21:21:00+00:00"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/"><meta property="og:see_also" content="https://blog.joaograssi.com/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/"><meta property="og:see_also" content="https://blog.joaograssi.com/limitations-ef-core-in-memory-database-providers/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/content/images/2020/08/using-docker-compose-for-your-asp-net-ef-core-integration-tests.jpg"><meta name=twitter:title content="Using docker-compose for your ASP.NET + EF Core integration tests"><meta name=twitter:description content="In this post, we will be looking at how can you run the integration tests of an ASP.NET + EF Core app against a &#34;full&#34; SQL Server instead of using the in-memory database providers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using docker-compose for your ASP.NET + EF Core integration tests","name":"Using docker-compose for your ASP.NET \u002b EF Core integration tests","description":"This is the second post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose for your …","keywords":["asp.net-core",".net-core","integration-tests","entity-framework-core","docker"],"articleBody":"This is the second post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose for your ASP.NET + EF Core integration tests (this post)\n  Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines\n  Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions\n  In this post, we will be looking at how you can run the integration tests of an ASP.NET + EF Core app against a “full” SQL Server instead of using the in-memory database providers. We’ll be looking at this from a local development perspective and expand on it later in the next posts.\nTL;DR Used docker-compose, xunit Collection Fixtures and WebApplicationFactory in order to connect to SQL Server running on Docker and create/migrate/drop a new database for each test run.\nIf you want to skip and jump right at the code, check the project on GitHub\nAlternatives to the in-memory database providers If I’m not using the in-memory database providers, then I need to have a full SQL Server instance running on my machine? Not really. We have some options:\n SQL LocalDB SQL Server running on Docker  SQL LocalDB works great but.. it doesn’t work on Linux and you need to install it in your Windows machine. If you use Visual Studio you probably already have it installed but with more and more people using VS Code and Rider as their main IDEs, these options don’t work well.\nIf you don’t know SQL Server is available on Linux for quite some time now. Even better, it’s available as a Docker image. This is very powerful because it enables virtually anyone to have a full-fletched SQL Server running without having to install anything other than Docker.\nSo the answer I chose for my projects is Docker!\nUsing docker-compose for your integration tests We just need a docker-compose.yml file at the root of our repo which starts a SQL Server container for us. If you don’t know what docker-compose is, you can take a look at the official documentation. In very crude terms it’s just a way to tell Docker: run all these things for me and make them work together!\nAn example docker-compose.yml file that starts a SQL Server instance looks like this:\nversion: \"3.7\" networks: blogapp-network: services: blogapp-sqlserver: image: \"mcr.microsoft.com/mssql/server\" ports: - \"1433:1433\" environment: SA_PASSWORD: \"2@LaiNw)PDvs^tL!Ybt]6H^%h3UM\" ACCEPT_EULA: \"Y\" networks: - blogapp-network I’ll skip the details on this file since it’s too much for a single post, but the important parts are the image which tells what we want, in this case, SQL Server. The port which is mapping/exposing the port 1433 of the container to the host (our machines) and the password for the sa user.\nWhen you are ready, just execute docker-compose up at the root of your repo using your favorite shell and you are good to go! You have a full SQL Server at your disposal. Next, we’ll see then how to configure your code to use it.\nASP.NET Core integration tests against a real SQL Server For this part, I’m going to use a sample app based on the Blog entities that are in the official EF Core docs. It’s an ASP.NET Core API that has a controller to expose some CRUD operations around a Blog entity. All the code is available on GitHub.\nFor brevity I’ll skip some of the details about integration tests otherwise this will get long. If you are not familiar with it you can get up to speed by reading this: Integration tests in ASP.NET Core\nThe way things come together in a test project is by creating a class deriving from WebApplicationFactory. In this class, we have the possibility to alter our real app in any way we want. For example, in the link above they show you how to switch the registered DbContext with your “real” connection string to an in-memory one during the tests.\nWe’ll be using our container instead of the in-memory providers as you guessed by now. But first, we need to consider some points.\nUnderstanding the lifetime of things during the integration tests Testing code that uses EF Core means that we have to do the following at least once during a test run\n Run the migrations in order to create the database Maybe run some seed method Drop the database when done testing  This is very fast when using the in-memory providers but when using a real SQL Server it’s not so fast anymore. It’s still just within a second or so but you need to think better now when and how many times you want to do it. Because this can drastically impact the speed of your tests.\nDifferent testing frameworks offer different ways to share data across a test run. xunit offers 3 ways:\n Constructor and Dispose (shared setup/cleanup code without sharing object instances) Class Fixtures (shared object instance across tests in a single class) Collection Fixtures (shared object instances across multiple test classes)   Since xunit is the most used test framework in .NET, that’s what I’ll be using for the rest of the post.\n We can use a Collection Fixture in order to create the database once and use the same for all integration tests. Once all tests are finished, we can drop the database.\nYou have to understand though when writing your tests this way that you cannot rely on the state of the database because you don’t know which test executed before and what data it might have modified. For that reason, I always treat each test as if the database was empty and I always insert the data I want to assert first.\nLet’s see how to do this next.\nCreating our DB Collection Fixture using BlogApp.Data; using Microsoft.EntityFrameworkCore; using System; using Xunit; namespace BlogApp.Api.Tests { public class DbFixture : IDisposable { private readonly BlogDbContext _dbContext; public readonly string BlogDbName = $\"Blog-{Guid.NewGuid()}\"; public readonly string ConnString; private bool _disposed; public DbFixture() { ConnString = $\"Server=localhost,1433;Database={BlogDbName};User=sa;Password=2@LaiNw)PDvs^tL!Ybt]6H^%h3UM\"; var builder = new DbContextOptionsBuilder(); builder.UseSqlServer(ConnString); _dbContext = new BlogDbContext(builder.Options); _dbContext.Database.Migrate(); } public void Dispose() { Dispose(disposing: true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { // remove the temp db from the server once all tests are done  _dbContext.Database.EnsureDeleted(); } _disposed = true; } } } [CollectionDefinition(\"Database\")] public class DatabaseCollection : ICollectionFixture { // This class has no code, and is never created. Its purpose is simply  // to be the place to apply [CollectionDefinition] and all the  // ICollectionFixture interfaces.  } } The constructor is the important part of this class:\n Initializes a connection string pointing to our SQL Server running on Docker (localhost, 1433) Uses a Guid in the database name in order to create a random one on the server every time Creates a DbContext instance and calls Migrate in order to create the database (applying the migrations)  The fixture also implements IDisposable in order to drop the database at the end of each test run.\nNow we need to create the WebApplicationFactory and use this Fixture there.\nCreating our WebApplicationFactory The WebApplicationFactory is where we can tell ASP.NET Core: When the app requests an instance of a DbContext via DI, use this one. This is how it looks like:\nUpdate - Aug 13 2020 In the original post, I showed you how to use the Docker connection string by removing the original DbContext registration inside the WebApplicationFactory. Alexey pointed out that there are some good benefits of not doing that. A big one that I was not aware, is when using DbContext pooling. In that case, you might have custom configuration and by removing the original registration you are losing that, which defeats the purpose of integration tests.\nAlexey's suggestion on not removing the original DbContext registration  One easy solution is instead of removing the original DbContext registration, we just add an In-memory configuration provider with our integration test connection string. That will override the one in your appsettings.json during the tests. I’ve updated the code snippet below to reflect that along with the project on GitHub. Thanks, Alexey!\nusing Microsoft.AspNetCore.Hosting; using Microsoft.AspNetCore.Mvc.Testing; using Microsoft.Extensions.Configuration; using System.Collections.Generic; using Xunit; namespace BlogApp.Api.Tests { [Collection(\"Database\")] public class BlogWebApplicationFactory : WebApplicationFactory { private readonly DbFixture _dbFixture; public BlogWebApplicationFactory(DbFixture dbFixture) = _dbFixture = dbFixture; protected override void ConfigureWebHost(IWebHostBuilder builder) { builder.UseEnvironment(\"Test\"); // UPDATE: No need to remove the original DbContext.  // To use our Docker db, we can just provide an in-memory config provider.\t // The original code is just here for reference.  //builder.ConfigureServices(services =  //{  // // Remove the app's BlogDbContext registration.  // var descriptor = services.SingleOrDefault(  // d = d.ServiceType ==  // typeof(DbContextOptions));  // if (descriptor is object)  // services.Remove(descriptor);  // services.AddDbContext(options =  // {  // // uses the connection string from the fixture  // options.UseSqlServer(_dbFixture.ConnString);  // });  //})  builder.ConfigureAppConfiguration((context, config) = { config.AddInMemoryCollection(new[] { new KeyValuePairstring, string( \"ConnectionStrings:BlogConnection\", _dbFixture.ConnString) }); }); } } } Let’s go through it:\n  Note the [Collection(\"Database\")] attribute on the class. That tells xunit to inject the database fixture into this class’s constructor.\n  We add an in-memory configuration provider (AddInMemoryCollection) containing our Docker connection string. When the app starts, this will override the connection string in appsettings..json. No need to remove the original DbContext.\n  We have all we need now. Let’s connect all the pieces!\nCreating an integration test This is an example of an integration test class for our Blog controller:\nusing BlogApp.Api.Controllers.Models; using BlogApp.Data.Entities; using FluentAssertions; using System; using System.Net.Http; using System.Threading.Tasks; using Xunit; namespace BlogApp.Api.Tests.Controllers { [Collection(\"Database\")] public sealed class BlogsControllerTests : IClassFixture { private readonly BlogWebApplicationFactory _factory; public BlogsControllerTests(BlogWebApplicationFactory factory) { _factory = factory; } [Fact] public async Task Create_ShouldCreateBlog() { // Arrange  var createRequest = new CreateBlogRequest { Url = \"https://aspnet-core-is-cool.net\" }; var client = _factory.CreateClient(); // Act  var postResponse = await client .PostAsync(\"/v1/blogs\", new JsonContent(createRequest)); var blogCreateResponse = await postResponse.Content.ReadAsJsonAsync(); // Assert - by calling the Get/id and comparing the results  var getResponse = await client .GetAsync($\"/v1/blogs/{blogCreateResponse.Id}\"); var blogGetResponse = await getResponse.Content.ReadAsJsonAsync(); blogGetResponse.Should().BeEquivalentTo(blogCreateResponse); } } } Again let’s inspect things a bit:\n  This class also has the [Collection] attribute the same as the factory. We need this otherwise the factory doesn’t get the Fixture injected since it’s not a test on itself but rather just a normal class.\n  We use another xunit way of sharing data: IClassFixture. This will inject our WebApplicationFactory into the test class’s constructor and the same factory is shared for all tests in this class only\n  Inside the test we use the factory to create the HttpClient which points to our app\n  Next, we issue a POST request to the blog controller to create our blog\n  Then, we issue a GET request using the Id returned\n  Finally, we compare both values to see if they match\n  That’s it! The integration test is succinct and easy to understand. All the inner works of creating/migrating the database and dropping it are hidden away by the Collection Fixture + WebApplicationFactory.\nThe only thing developers working on this project need to do before running the tests is to execute docker-compose up (Assuming Docker is already running).\nSummary In this post we looked at several things so let’s recap a bit:\n  Created our docker-compose.yaml file which contains our SQL Server container\n  Understood the lifetime of a test run in xunit and used a Collection Fixture to manage our database creation/migration/deletion\n  Used a in-memory configuration provider inside our WebApplicationFactory in order to override the connection string present in appsettings..json and use the one connecting to our SQL Server running on Docker.\n  Created an integration test that POST and GET a blog from our SQL Server running on Docker\n  This solution combines the power of Docker containers with techniques to share “things” across tests using xunit and WebApplicationFactory.\nWith the approach I presented in this post, your tests now match better your production environment, thus exposing possible bugs earlier and giving you more confidence when you are ready to deploy your apps.\nComing up next, I’ll show you how you can run the same tests with Docker during your CI Build in Azure DevOps. Stay tuned!\nPhoto by Tom Fisk from Pexels\n","wordCount":"2015","inLanguage":"en","image":"https://blog.joaograssi.com/content/images/2020/08/using-docker-compose-for-your-asp-net-ef-core-integration-tests.jpg","datePublished":"2020-08-13T21:21:00Z","dateModified":"2020-08-13T21:21:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/using-docker-compose-for-your-asp-net-ef-core-integration-tests/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Using docker-compose for your ASP.NET + EF Core integration tests</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/content/images/2020/08/using-docker-compose-for-your-asp-net-ef-core-integration-tests.jpg alt="View from above of containers in a port"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#alternatives-to-the-in-memory-database-providers aria-label="Alternatives to the in-memory database providers">Alternatives to the in-memory database providers</a></li><li><a href=#using-docker-compose-for-your-integration-tests aria-label="Using docker-compose for your integration tests">Using <code>docker-compose</code> for your integration tests</a></li><li><a href=#aspnet-core-integration-tests-against-a-real-sql-server aria-label="ASP.NET Core integration tests against a real SQL Server">ASP.NET Core integration tests against a real SQL Server</a><ul><li><a href=#understanding-the-lifetime-of-things-during-the-integration-tests aria-label="Understanding the lifetime of things during the integration tests">Understanding the lifetime of things during the integration tests</a></li><li><a href=#creating-our-db-collection-fixture aria-label="Creating our DB Collection Fixture">Creating our DB Collection Fixture</a></li><li><a href=#creating-our-webapplicationfactory aria-label="Creating our WebApplicationFactory">Creating our WebApplicationFactory</a></li><li><a href=#update---aug-13-2020 aria-label="Update - Aug 13 2020">Update - Aug 13 2020</a></li><li><a href=#creating-an-integration-test aria-label="Creating an integration test">Creating an integration test</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></blockquote></details></div><div class=post-content><p>This is the second post in the <a href=/series/integration-tests-in-asp.net-core>Integration tests in ASP.NET Core</a> series.</p><ul><li><p><a href=/limitations-ef-core-in-memory-database-providers>Part 1: Limitations of the EF Core in-memory database providers</a></p></li><li><p><a href=/using-docker-compose-for-your-asp-net-ef-core-integration-tests>Part 2: Using docker-compose for your ASP.NET + EF Core integration tests (this post)</a></p></li><li><p><a href=/asp-net-core-integration-tests-with-docker-compose-azure-pipelines>Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines</a></p></li><li><p><a href=/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions>Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions</a></p></li></ul><p>In this post, we will be looking at how you can run the integration tests of an ASP.NET + EF Core app against a &ldquo;full&rdquo; SQL Server instead of using the in-memory database providers. We&rsquo;ll be looking at this from a local development perspective and expand on it later in the next posts.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>Used <a href=https://docs.docker.com/compose/>docker-compose</a>, <a href=https://xunit.net/docs/shared-context.html>xunit Collection Fixtures</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.1#customize-webapplicationfactory">WebApplicationFactory</a> in order to connect to SQL Server running on Docker and create/migrate/drop a new database for each test run.</p><p>If you want to skip and jump right at the code, <a href=https://github.com/joaopgrassi/dockercompose-azdevops>check the project on GitHub</a></p><h2 id=alternatives-to-the-in-memory-database-providers>Alternatives to the in-memory database providers<a hidden class=anchor aria-hidden=true href=#alternatives-to-the-in-memory-database-providers>#</a></h2><p>If I&rsquo;m not using the in-memory database providers, then I need to have a full SQL Server instance running on my machine? Not really. We have some options:</p><ul><li>SQL LocalDB</li><li>SQL Server running on Docker</li></ul><p>SQL LocalDB works great but.. it doesn&rsquo;t work on Linux and you need to install it in your Windows machine. If you use Visual Studio you probably already have it installed but with more and more people using VS Code and Rider as their main IDEs, these options don&rsquo;t work well.</p><p>If you don&rsquo;t know SQL Server is available on Linux for quite some time now. Even better, it&rsquo;s <a href=https://hub.docker.com/_/microsoft-mssql-server>available as a Docker image</a>. This is very powerful because it enables virtually anyone to have a full-fletched SQL Server running without having to install anything other than Docker.</p><p>So the answer I chose for my projects is <strong>Docker</strong>!</p><h2 id=using-docker-compose-for-your-integration-tests>Using <code>docker-compose</code> for your integration tests<a hidden class=anchor aria-hidden=true href=#using-docker-compose-for-your-integration-tests>#</a></h2><p>We just need a <code>docker-compose.yml</code> file at the root of our repo which starts a SQL Server container for us. If you don&rsquo;t know what docker-compose is, you can take a look at the <a href=https://docs.docker.com/compose/>official documentation</a>. In very crude terms it&rsquo;s just a way to tell Docker: run all these things for me and make them work together!</p><p>An example <code>docker-compose.yml</code> file that starts a SQL Server instance looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.7&#34;</span>

<span style=color:#f92672>networks</span>:
  <span style=color:#f92672>blogapp-network</span>:
  
<span style=color:#f92672>services</span>:
  <span style=color:#f92672>blogapp-sqlserver</span>:
    <span style=color:#f92672>image</span>: <span style=color:#e6db74>&#34;mcr.microsoft.com/mssql/server&#34;</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#e6db74>&#34;1433:1433&#34;</span>
    <span style=color:#f92672>environment</span>:
        <span style=color:#f92672>SA_PASSWORD</span>: <span style=color:#e6db74>&#34;2@LaiNw)PDvs^t&gt;L!Ybt]6H^%h3U&gt;M&#34;</span>
        <span style=color:#f92672>ACCEPT_EULA</span>: <span style=color:#e6db74>&#34;Y&#34;</span>
    <span style=color:#f92672>networks</span>:
      - <span style=color:#ae81ff>blogapp-network</span>
</code></pre></div><p>I&rsquo;ll skip the details on this file since it&rsquo;s too much for a single post, but the important parts are the <code>image</code> which tells what we want, in this case, SQL Server. The <code>port</code> which is mapping/exposing the port <strong>1433</strong> of the container to the host (our machines) and the password for the <code>sa</code> user.</p><p>When you are ready, just execute <code>docker-compose up</code> at the root of your repo using your favorite shell and you are good to go! You have a full SQL Server at your disposal. Next, we&rsquo;ll see then how to configure your code to use it.</p><h2 id=aspnet-core-integration-tests-against-a-real-sql-server>ASP.NET Core integration tests against a real SQL Server<a hidden class=anchor aria-hidden=true href=#aspnet-core-integration-tests-against-a-real-sql-server>#</a></h2><p>For this part, I&rsquo;m going to use a sample app based on the Blog entities that are in the official EF Core docs. It&rsquo;s an ASP.NET Core API that has a controller to expose some CRUD operations around a <code>Blog</code> entity. All the code is available on <a href=https://github.com/joaopgrassi/dockercompose-azdevops>GitHub</a>.</p><p>For brevity I&rsquo;ll skip some of the details about integration tests otherwise this will get long. If you are not familiar with it you can get up to speed by reading this: <a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.1">Integration tests in ASP.NET Core</a></p><p>The way things come together in a test project is by creating a class deriving from <code>WebApplicationFactory</code>. In this class, we have the possibility to alter our real app in any way we want. For example, in the link above they show you how to switch the registered DbContext with your &ldquo;real&rdquo; connection string to an in-memory one during the tests.</p><p>We&rsquo;ll be using our container instead of the in-memory providers as you guessed by now. But first, we need to consider some points.</p><h3 id=understanding-the-lifetime-of-things-during-the-integration-tests>Understanding the lifetime of things during the integration tests<a hidden class=anchor aria-hidden=true href=#understanding-the-lifetime-of-things-during-the-integration-tests>#</a></h3><p>Testing code that uses EF Core means that we have to do the following <strong>at least once during a test run</strong></p><ul><li>Run the migrations in order to create the database</li><li>Maybe run some seed method</li><li>Drop the database when done testing</li></ul><p>This is <strong>very fast</strong> when using the in-memory providers but when using a real SQL Server it&rsquo;s not so fast anymore. It&rsquo;s still just within a second or so but you need to think better now <strong>when and how many times</strong> you want to do it. Because this can drastically impact the speed of your tests.</p><p>Different testing frameworks offer different ways to share data across a test run. <code>xunit</code> offers 3 ways:</p><ul><li><strong>Constructor and Dispose</strong> (shared setup/cleanup code without sharing object instances)</li><li><strong>Class Fixtures</strong> (shared object instance across tests in a single class)</li><li><strong>Collection Fixtures</strong> (shared object instances across multiple test classes)</li></ul><blockquote><p>Since <code>xunit</code> is the <a href="https://nugettrends.com/packages?months=24&ids=xunit&ids=NUnit&ids=MSTest.TestFramework">most used test framework</a> in .NET, that&rsquo;s what I&rsquo;ll be using for the rest of the post.</p></blockquote><p>We can use a <code>Collection Fixture</code> in order to create the database once and use the same for all integration tests. Once all tests are finished, we can drop the database.</p><p>You have to understand though when writing your tests this way that <strong>you cannot rely on the state of the database</strong> because you don&rsquo;t know which test executed before and what data it might have modified. For that reason, I always treat each test as if the database was empty and I <em>always insert the data I want to assert first</em>.</p><p>Let&rsquo;s see how to do this next.</p><h3 id=creating-our-db-collection-fixture>Creating our DB Collection Fixture<a hidden class=anchor aria-hidden=true href=#creating-our-db-collection-fixture>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> BlogApp.Data;
<span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> Xunit;

<span style=color:#66d9ef>namespace</span> BlogApp.Api.Tests
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DbFixture</span> : IDisposable
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> BlogDbContext _dbContext;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> BlogDbName = <span style=color:#e6db74>$&#34;Blog-{Guid.NewGuid()}&#34;</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> ConnString;
        
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> _disposed;

        <span style=color:#66d9ef>public</span> DbFixture()
        {
            ConnString = <span style=color:#e6db74>$&#34;Server=localhost,1433;Database={BlogDbName};User=sa;Password=2@LaiNw)PDvs^t&gt;L!Ybt]6H^%h3U&gt;M&#34;</span>;

            <span style=color:#66d9ef>var</span> builder = <span style=color:#66d9ef>new</span> DbContextOptionsBuilder&lt;BlogDbContext&gt;();

            builder.UseSqlServer(ConnString);
            _dbContext = <span style=color:#66d9ef>new</span> BlogDbContext(builder.Options);

            _dbContext.Database.Migrate();
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
        {
            Dispose(disposing: <span style=color:#66d9ef>true</span>);
            GC.SuppressFinalize(<span style=color:#66d9ef>this</span>);
        }

        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
        {
            <span style=color:#66d9ef>if</span> (!_disposed)
            {
                <span style=color:#66d9ef>if</span> (disposing)
                {
                    <span style=color:#75715e>// remove the temp db from the server once all tests are done
</span><span style=color:#75715e></span>                    _dbContext.Database.EnsureDeleted();
                }

                _disposed = <span style=color:#66d9ef>true</span>;
            }
        }
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [CollectionDefinition(&#34;Database&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseCollection</span> : ICollectionFixture&lt;DbFixture&gt;
    {
        <span style=color:#75715e>// This class has no code, and is never created. Its purpose is simply
</span><span style=color:#75715e></span>        <span style=color:#75715e>// to be the place to apply [CollectionDefinition] and all the
</span><span style=color:#75715e></span>        <span style=color:#75715e>// ICollectionFixture&lt;&gt; interfaces.
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p>The constructor is the important part of this class:</p><ul><li>Initializes a connection string pointing to our SQL Server <strong>running on Docker</strong> (localhost, 1433)</li><li>Uses a <code>Guid</code> in the database name in order to create a random one on the server every time</li><li>Creates a <code>DbContext</code> instance and calls <code>Migrate</code> in order to create the database (applying the migrations)</li></ul><p>The fixture also implements <code>IDisposable</code> in order to drop the database at the end of each test run.</p><p>Now we need to create the <code>WebApplicationFactory</code> and use this Fixture there.</p><h3 id=creating-our-webapplicationfactory>Creating our WebApplicationFactory<a hidden class=anchor aria-hidden=true href=#creating-our-webapplicationfactory>#</a></h3><p>The <code>WebApplicationFactory</code> is where we can tell ASP.NET Core: When the app requests an instance of a <code>DbContext</code> via DI, use this one. This is how it looks like:</p><h3 id=update---aug-13-2020>Update - Aug 13 2020<a hidden class=anchor aria-hidden=true href=#update---aug-13-2020>#</a></h3><p>In the original post, I showed you how to use the Docker connection string by removing the original DbContext registration inside the <code>WebApplicationFactory</code>. <a href=https://twitter.com/Tyrrrz>Alexey</a> pointed out that there are some good benefits of <strong>not</strong> doing that. A big one that I was not aware, is when using <a href=https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling>DbContext pooling</a>. In that case, you might have custom configuration and by removing the original registration you are losing that, which defeats the purpose of integration tests.</p><figure class=figure-border><img class=img-center src=/using-docker-compose-for-your-asp-net-ef-core-integration-tests/twitter_dbcontext_pooling.png alt="Alexey's suggestion on not removing the original DbContext registration" loading=lazy><figcaption class=img-caption>Alexey's suggestion on not removing the original DbContext registration</figcaption></figure><p>One easy solution is instead of removing the original <code>DbContext</code> registration, we just add an <code>In-memory</code> configuration provider with our integration test connection string. That will override the one in your <code>appsettings.json</code> during the tests. I&rsquo;ve updated the code snippet below to reflect that along with the project on GitHub. Thanks, Alexey!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Hosting;
<span style=color:#66d9ef>using</span> Microsoft.AspNetCore.Mvc.Testing;
<span style=color:#66d9ef>using</span> Microsoft.Extensions.Configuration;
<span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> Xunit;

<span style=color:#66d9ef>namespace</span> BlogApp.Api.Tests
{
<span style=color:#a6e22e>    [Collection(&#34;Database&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BlogWebApplicationFactory</span> : WebApplicationFactory&lt;Startup&gt;
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> DbFixture _dbFixture;

        <span style=color:#66d9ef>public</span> BlogWebApplicationFactory(DbFixture dbFixture)
            =&gt; _dbFixture = dbFixture;

        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> ConfigureWebHost(IWebHostBuilder builder)
        {
            builder.UseEnvironment(<span style=color:#e6db74>&#34;Test&#34;</span>);
            
            <span style=color:#75715e>// UPDATE: No need to remove the original DbContext.
</span><span style=color:#75715e></span>            <span style=color:#75715e>// To use our Docker db, we can just provide an in-memory config provider.		
</span><span style=color:#75715e></span>            <span style=color:#75715e>// The original code is just here for reference.
</span><span style=color:#75715e></span>            
            <span style=color:#75715e>//builder.ConfigureServices(services =&gt;
</span><span style=color:#75715e></span>            <span style=color:#75715e>//{
</span><span style=color:#75715e></span>            <span style=color:#75715e>//    // Remove the app&#39;s BlogDbContext registration.
</span><span style=color:#75715e></span>            <span style=color:#75715e>//    var descriptor = services.SingleOrDefault(
</span><span style=color:#75715e></span>            <span style=color:#75715e>//        d =&gt; d.ServiceType ==
</span><span style=color:#75715e></span>            <span style=color:#75715e>//            typeof(DbContextOptions&lt;BlogDbContext&gt;));
</span><span style=color:#75715e></span>
            <span style=color:#75715e>//    if (descriptor is object)
</span><span style=color:#75715e></span>            <span style=color:#75715e>//        services.Remove(descriptor);
</span><span style=color:#75715e></span>
            <span style=color:#75715e>//    services.AddDbContext&lt;BlogDbContext&gt;(options =&gt;
</span><span style=color:#75715e></span>            <span style=color:#75715e>//    {
</span><span style=color:#75715e></span>            <span style=color:#75715e>//        // uses the connection string from the fixture
</span><span style=color:#75715e></span>            <span style=color:#75715e>//        options.UseSqlServer(_dbFixture.ConnString);
</span><span style=color:#75715e></span>            <span style=color:#75715e>//    });
</span><span style=color:#75715e></span>            <span style=color:#75715e>//})
</span><span style=color:#75715e></span>            builder.ConfigureAppConfiguration((context, config) =&gt;
            {
                config.AddInMemoryCollection(<span style=color:#66d9ef>new</span>[]
                {
                    <span style=color:#66d9ef>new</span> KeyValuePair&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>string</span>&gt;(
                        <span style=color:#e6db74>&#34;ConnectionStrings:BlogConnection&#34;</span>, _dbFixture.ConnString)
                });
            });
        }
    }
}
</code></pre></div><p>Let&rsquo;s go through it:</p><ol><li><p>Note the <code>[Collection("Database")]</code> attribute on the class. That tells <code>xunit</code> to inject the database fixture into this class&rsquo;s constructor.</p></li><li><p>We add an in-memory configuration provider (<code>AddInMemoryCollection</code>) containing our Docker connection string. When the app starts, this will override the connection string in <code>appsettings.&lt;env>.json</code>. No need to remove the original DbContext.</p></li></ol><p>We have all we need now. Let&rsquo;s connect all the pieces!</p><h3 id=creating-an-integration-test>Creating an integration test<a hidden class=anchor aria-hidden=true href=#creating-an-integration-test>#</a></h3><p>This is an example of an integration test class for our Blog controller:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> BlogApp.Api.Controllers.Models;
<span style=color:#66d9ef>using</span> BlogApp.Data.Entities;
<span style=color:#66d9ef>using</span> FluentAssertions;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Net.Http;
<span style=color:#66d9ef>using</span> System.Threading.Tasks;
<span style=color:#66d9ef>using</span> Xunit;

<span style=color:#66d9ef>namespace</span> BlogApp.Api.Tests.Controllers
{
<span style=color:#a6e22e>    [Collection(&#34;Database&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BlogsControllerTests</span> : IClassFixture&lt;BlogWebApplicationFactory&gt;
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> BlogWebApplicationFactory _factory;

        <span style=color:#66d9ef>public</span> BlogsControllerTests(BlogWebApplicationFactory factory)
        {
            _factory = factory;
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [Fact]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Create_ShouldCreateBlog()
        {
            <span style=color:#75715e>// Arrange
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> createRequest = <span style=color:#66d9ef>new</span> CreateBlogRequest
            {
                Url = <span style=color:#e6db74>&#34;https://aspnet-core-is-cool.net&#34;</span>
            };

            <span style=color:#66d9ef>var</span> client = _factory.CreateClient();

            <span style=color:#75715e>// Act
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> postResponse = <span style=color:#66d9ef>await</span> client
            .PostAsync(<span style=color:#e6db74>&#34;/v1/blogs&#34;</span>, <span style=color:#66d9ef>new</span> JsonContent&lt;CreateBlogRequest&gt;(createRequest));
            
            <span style=color:#66d9ef>var</span> blogCreateResponse = <span style=color:#66d9ef>await</span> postResponse.Content.ReadAsJsonAsync&lt;Blog&gt;();

            <span style=color:#75715e>// Assert - by calling the Get/id and comparing the results
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>var</span> getResponse = <span style=color:#66d9ef>await</span> client
            .GetAsync(<span style=color:#e6db74>$&#34;/v1/blogs/{blogCreateResponse.Id}&#34;</span>);
            
            <span style=color:#66d9ef>var</span> blogGetResponse =  <span style=color:#66d9ef>await</span> getResponse.Content.ReadAsJsonAsync&lt;Blog&gt;();

            blogGetResponse.Should().BeEquivalentTo(blogCreateResponse);
        }
    }
}
</code></pre></div><p>Again let&rsquo;s inspect things a bit:</p><ol><li><p>This class also has the <code>[Collection]</code> attribute the same as the factory. We need this otherwise the factory doesn&rsquo;t get the Fixture injected since it&rsquo;s not a test on itself but rather just a normal class.</p></li><li><p>We use another <code>xunit</code> way of sharing data: <code>IClassFixture</code>. This will inject our <code>WebApplicationFactory</code> into the test class&rsquo;s constructor and the same factory is shared for all tests <strong>in this class only</strong></p></li><li><p>Inside the test we use the factory to create the <code>HttpClient</code> which points to our app</p></li><li><p>Next, we issue a <code>POST</code> request to the blog controller to create our blog</p></li><li><p>Then, we issue a <code>GET</code> request using the <code>Id</code> returned</p></li><li><p>Finally, we compare both values to see if they match</p></li></ol><p>That&rsquo;s it! The integration test is succinct and easy to understand. All the inner works of creating/migrating the database and dropping it are hidden away by the Collection Fixture + WebApplicationFactory.</p><p>The only thing developers working on this project need to do before running the tests is to execute <code>docker-compose up</code> (Assuming Docker is already running).</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this post we looked at several things so let&rsquo;s recap a bit:</p><ol><li><p>Created our <code>docker-compose.yaml</code> file which contains our SQL Server container</p></li><li><p>Understood the lifetime of a test run in <code>xunit</code> and used a Collection Fixture to manage our database creation/migration/deletion</p></li><li><p>Used a in-memory configuration provider inside our <code>WebApplicationFactory</code> in order to override the connection string present in <code>appsettings.&lt;env>.json</code> and use the one connecting to our SQL Server running on Docker.</p></li><li><p>Created an integration test that <code>POST</code> and <code>GET</code> a blog from our SQL Server running on Docker</p></li></ol><p>This solution combines the power of Docker containers with techniques to share &ldquo;things&rdquo; across tests using <code>xunit</code> and <code>WebApplicationFactory</code>.</p><p>With the approach I presented in this post, your tests now match better your production environment, thus exposing <strong>possible bugs earlier</strong> and giving you <strong>more confidence</strong> when you are ready to deploy your apps.</p><p>Coming up next, I&rsquo;ll show you how you can run the same tests with Docker during your CI Build in Azure DevOps. Stay tuned!</p><p><a href=https://www.pexels.com/photo/aerial-photography-of-container-van-lot-3063470/>Photo by Tom Fisk from Pexels</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/.net-core/>.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/integration-tests/>integration-tests</a></li><li><a href=https://blog.joaograssi.com/tags/entity-framework-core/>entity-framework-core</a></li><li><a href=https://blog.joaograssi.com/tags/docker/>docker</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>