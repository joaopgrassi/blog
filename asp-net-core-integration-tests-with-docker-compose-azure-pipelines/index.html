<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ASP.NET Core integration tests with docker-compose on Azure Pipelines | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,azure-devops,integration-tests,docker,pipelines"><meta name=description content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on Azure Pipelines."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.5df15aa0fa69a07f461d7f7c1614ad5deed5c58a9894e3e7595bf68d9e7d3414.css integrity="sha256-XfFaoPppoH9GHX98FhStXe7VxYqYlOPnWVv2jZ59NBQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content="ASP.NET Core integration tests with docker-compose on Azure Pipelines"><meta property="og:description" content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on Azure Pipelines."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/"><meta property="og:image" content="https://blog.joaograssi.com/content/images/2020/08/asp-net-core-integration-tests-with-docker-compose-azure-pipelines.jpg"><meta property="article:published_time" content="2020-08-22T14:27:00+00:00"><meta property="article:modified_time" content="2020-08-22T14:27:00+00:00"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/"><meta property="og:see_also" content="https://blog.joaograssi.com/using-docker-compose-for-your-asp-net-ef-core-integration-tests/"><meta property="og:see_also" content="https://blog.joaograssi.com/limitations-ef-core-in-memory-database-providers/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/content/images/2020/08/asp-net-core-integration-tests-with-docker-compose-azure-pipelines.jpg"><meta name=twitter:title content="ASP.NET Core integration tests with docker-compose on Azure Pipelines"><meta name=twitter:description content="In this post I'll demonstrate how we can run the tests for our ASP.NET Core app using `docker-compose` on Azure Pipelines."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ASP.NET Core integration tests with docker-compose on Azure Pipelines","name":"ASP.NET Core integration tests with docker-compose on Azure Pipelines","description":"This is the third post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose for your ‚Ä¶","keywords":["asp.net-core","azure-devops","integration-tests","docker","pipelines"],"articleBody":"This is the third post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers\n  Part 2: Using docker-compose for your ASP.NET + EF Core integration tests\n  Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines (this post)\n  Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions\n  In the last post of the series we saw how to use SQL Server on Docker as the database for our integration tests during local development.\nIn this post, we‚Äôll be continuing with the same code but I‚Äôll demonstrate how we can run the tests using docker-compose on Azure Pipelines as part of our CI builds.\nTL;DR Go directly to the Azure Pipeline yaml\nThe full project on GitHub\nQuick recap on running the tests locally Before starting with our Azure pipeline, let‚Äôs remember the steps to run the tests locally. This will help us design our yaml file for our CI build:\n Start the SQL Container docker-compose up at the root of the repo Run the tests dotnet test   There‚Äôs a little caveat between the steps above. It takes a few seconds until the SQL Server container is ready to accept connections. We‚Äôll ignore this in this post, but there are several strategies to work around in case you face this issue. One is to use scripts that will ‚Äúwait‚Äù for the container to be ready. For example wait-for-it\n Now that we know the steps, let‚Äôs re-create them on Azure Pipelines.\nCreating our Azure Pipelines build This is how our final pipeline yaml file looks like:\nname: \"$(Date:yyyy).$(Date:MM).$(Rev:r)\" trigger: batch: true branches: include: - main - feat/* - bugs/* paths: include: - src/* - tests/* - az-devops/* - BlogApp.sln - Directory.Build.props pool: vmImage: ubuntu-16.04 variables: buildConfiguration: 'Release' appProjectDir: 'src/BlogApp.Api' jobs: - job: displayName: Build App steps: - task: DockerCompose@0 displayName: Start dependencies (docker-compose) inputs: containerregistrytype: Container Registry dockerComposeFile: docker-compose.yml dockerComposeCommand: 'up -d' - task: UseDotNet@2 displayName: Installing .NET SDK inputs: packageType: 'sdk' version: '3.1.x' - task: NuGetCommand@2 displayName: Restore NuGet packages inputs: restoreSolution: BlogApp.sln includeNuGetOrg: true - task: DotNetCoreCLI@2 displayName: Build inputs: command: build projects: $(appProjectDir)/BlogApp.Api.csproj arguments: '-c $(buildConfiguration) --no-restore' - task: DotNetCoreCLI@2 displayName: Test inputs: command: test projects: 'tests/**/*.csproj' arguments: '-c $(buildConfiguration) --collect:\"XPlat Code Coverage\"' The yaml pipeline can be quite daunting at first sight, but once you get the hang of it it‚Äôs not that bad. When I got started, this page YAML schema reference helped me a lot.\nLet‚Äôs review the steps:\nTrigger, pool and variables The trigger section tells the pipelines to run the build for the included branches, when changes occur on the configured paths.\nThe pool section tells on which pool our jobs will run. In this case, I‚Äôm using the Microsoft-hosted pool and telling it to run my jobs using an ubuntu image.\nIn the variables section I just set the build configuration and the path to the API to avoid typing it multiple times along the tasks. Nothing special.\nJobs We only have one job in our build. I recommend reading the page above to understand the hierarchy of things. For now, it‚Äôs enough to know that one job can have tasks.\nDocker compose task As we know, to run our tests we need to make sure we have our SQL Server running on Docker since our tests will expect a server on localhost,1433. For that, we use the DockerCompose@0 task.\nWe need to specify which container registry we want to use (containerregistrytype). The default is to use Azure ACR. Since the SQL Server image lives in the Docker public registry, we need to set the value to Container Registry. The link above has more details on it.\nThen we just need to instruct it where the docker-compose file is and the command to execute. This is the same when running locally, docker-compose up -d (-d for detached, because we don‚Äôt want to block the terminal)\nRestore, Build and Test The rest of the tasks are relatively self-explanatory and don‚Äôt deviate much from the commands you would normally run if you use the .NET Core CLI. But let‚Äôs review them anyway:\n  First, we make sure we have the proper .NET Core SDK installed (UseDotNet@2)\n  Next, we restore the packages for the whole solution (NuGetCommand@2) passing the .sln file to restoreSolution.\n  Then we use the DotNetCoreCLI@2 to issue commands against the .NET Core CLI. First starting with build passing the csproj of our API\n  Finally, we issue a test command passing a glob pattern to find all projects inside the tests folder.\n  That‚Äôs it! Now every time you push something to any of the branches configured in the trigger section, a build will run and our tests using Docker will be executed. See here a build run example.\nCreating the Pipeline on Azure DevOps The next step is to save the yaml file above at the root of your repo. I usually put them into an az-devops folder, but you can place it anywhere you want and name it how you prefer. You need to commit and push it to be able to set up the pipeline on Azure DevOps. Follow the steps below:\n  Go to Pipelines  New Pipeline (top-right button)\n  In ‚ÄúWhere is your code‚Äù select the Git provider you are using for your project\n  Select the git repository where you have your .yaml file\n  In ‚ÄúConfigure your pipeline‚Äù select the option ‚ÄúExisting Azure Pipelines YAML‚Äù\n  In the right menu select the branch and the the .yaml file. (If you pushed the file to a different branch other than the default, you need to change it)\n  Click on ‚ÄúContinue‚Äù\n  It shows a review of the file. Just click on Run to save and run the pipeline\n   The steps above expects that you already have a project and a connection to a Git provider (Azure Repos, GitHub or other) configured in your Azure DevOps organization.\n You should have your brand new pipeline now! Hopefully passing üòÖ\nExtras If you got this far, I have some extra stuff for you. Read on!\nCode coverage I tried to keep the pipeline above as simple as possible so it wouldn‚Äôt be too much to explain here. But if you head to the project on GitHub, you‚Äôll see how I set up code coverage. That way you also have the coverage report as part of each build directly on Azure DevOps:\nCode coverage report on Azure DevOps  Build tasks Another thing I‚Äôd like to discuss is the tasks in the build. What I showed here is roughly what I use for my projects, but there are so many other ways to do it.\nI use the NuGet task (NuGetCommand@2) to restore the packages. I could use the .NET CLI and simple dotnet restore and that would work as well. I use the NuGet task mostly because I have private NuGet feeds and I ran into several problems on Azure DevOps using the CLI. So after a lot of try and error that is what worked for me.\nThe test task also builds the projects again which is not great. That is necessary because in the build task I only build the API. If I would run the tests with test --no-build then it would fail because the test project was never built. You can decide what to do in your own projects. Maybe building the .sln instead is good enough.\nSummary In this post, I showed you how we can reproduce our local test run using SQL Server on Docker on Azure Pipelines. We saw the yaml file and we went through all the tasks that define it.\nAs a closing consideration, I wanted to point out that there‚Äôs no silver bullet pipeline, and what I presented here is just one way to do it. You could instead just write a PowerShell or Bash script that would do the same steps and your yaml file would just run that.\nIn your real-world apps, you need to consider what‚Äôs best for your development flow and what your team is most comfortable with.\nComing up next we‚Äôll see how to do the same using GitHub actions. Stay tuned and thanks for reading!\nPhoto by Pixabay from Pexels\n","wordCount":"1369","inLanguage":"en","image":"https://blog.joaograssi.com/content/images/2020/08/asp-net-core-integration-tests-with-docker-compose-azure-pipelines.jpg","datePublished":"2020-08-22T14:27:00Z","dateModified":"2020-08-22T14:27:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>ASP.NET Core integration tests with docker-compose on Azure Pipelines</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/content/images/2020/08/asp-net-core-integration-tests-with-docker-compose-azure-pipelines.jpg alt="View from stairs in black and white"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#quick-recap-on-running-the-tests-locally aria-label="Quick recap on running the tests locally">Quick recap on running the tests locally</a></li><li><a href=#pipeline-yaml aria-label="Creating our Azure Pipelines build">Creating our Azure Pipelines build</a><ul><li><a href=#trigger-pool-and-variables aria-label="Trigger, pool and variables">Trigger, pool and variables</a></li><li><a href=#jobs aria-label=Jobs>Jobs</a><ul><li><a href=#docker-compose-task aria-label="Docker compose task">Docker compose task</a></li><li><a href=#restore-build-and-test aria-label="Restore, Build and Test">Restore, Build and Test</a></li></ul></li></ul></li><li><a href=#creating-the-pipeline-on-azure-devops aria-label="Creating the Pipeline on Azure DevOps">Creating the Pipeline on Azure DevOps</a></li><li><a href=#extras aria-label=Extras>Extras</a><ul><li><a href=#code-coverage aria-label="Code coverage">Code coverage</a></li></ul></li><li><a href=#build-tasks aria-label="Build tasks">Build tasks</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></blockquote></details></div><div class=post-content><p>This is the third post in the <a href=/series/integration-tests-in-asp.net-core>Integration tests in ASP.NET Core</a> series.</p><ul><li><p><a href=/limitations-ef-core-in-memory-database-providers>Part 1: Limitations of the EF Core in-memory database providers</a></p></li><li><p><a href=/using-docker-compose-for-your-asp-net-ef-core-integration-tests>Part 2: Using docker-compose for your ASP.NET + EF Core integration tests</a></p></li><li><p><a href=/asp-net-core-integration-tests-with-docker-compose-azure-pipelines>Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines (this post)</a></p></li><li><p><a href=/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions>Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions</a></p></li></ul><p>In the last post of the series we saw how to use SQL Server on Docker as the database for our integration tests during local development.</p><p>In this post, we&rsquo;ll be continuing with the same code but I&rsquo;ll demonstrate how we can run the tests using <code>docker-compose</code> on Azure Pipelines as part of our CI builds.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p><a href=#pipeline-yaml>Go directly to the Azure Pipeline yaml</a></p><p><a href=https://github.com/joaopgrassi/dockercompose-azdevops>The full project on GitHub</a></p><h2 id=quick-recap-on-running-the-tests-locally>Quick recap on running the tests locally<a hidden class=anchor aria-hidden=true href=#quick-recap-on-running-the-tests-locally>#</a></h2><p>Before starting with our Azure pipeline, let&rsquo;s remember the steps to run the tests locally. This will help us design our <code>yaml</code> file for our CI build:</p><ol><li>Start the SQL Container <code>docker-compose up</code> at the root of the repo</li><li>Run the tests <code>dotnet test</code></li></ol><blockquote><p>There&rsquo;s a little caveat between the steps above. It takes a few seconds until the SQL Server container is ready to accept connections. We&rsquo;ll ignore this in this post, but there are several strategies to work around in case you face this issue. One is to use scripts that will &ldquo;wait&rdquo; for the container to be ready. For example <a href=https://github.com/vishnubob/wait-for-it>wait-for-it</a></p></blockquote><p>Now that we know the steps, let&rsquo;s re-create them on Azure Pipelines.</p><h2 id=pipeline-yaml>Creating our Azure Pipelines build<a hidden class=anchor aria-hidden=true href=#pipeline-yaml>#</a></h2><p>This is how our final pipeline yaml file looks like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;$(Date:yyyy).$(Date:MM).$(Rev:r)&#34;</span>

<span style=color:#f92672>trigger</span>:
  <span style=color:#f92672>batch</span>: <span style=color:#66d9ef>true</span>
  <span style=color:#f92672>branches</span>:
    <span style=color:#f92672>include</span>:
    - <span style=color:#ae81ff>main</span>
    - <span style=color:#ae81ff>feat/*</span>
    - <span style=color:#ae81ff>bugs/*</span>
  <span style=color:#f92672>paths</span>:
    <span style=color:#f92672>include</span>:
    - <span style=color:#ae81ff>src/*</span>
    - <span style=color:#ae81ff>tests/*</span>
    - <span style=color:#ae81ff>az-devops/*</span>
    - <span style=color:#ae81ff>BlogApp.sln</span>
    - <span style=color:#ae81ff>Directory.Build.props</span>

<span style=color:#f92672>pool</span>:
  <span style=color:#f92672>vmImage</span>: <span style=color:#ae81ff>ubuntu-16.04</span>

<span style=color:#f92672>variables</span>:
  <span style=color:#f92672>buildConfiguration</span>: <span style=color:#e6db74>&#39;Release&#39;</span>
  <span style=color:#f92672>appProjectDir</span>: <span style=color:#e6db74>&#39;src/BlogApp.Api&#39;</span>

<span style=color:#f92672>jobs</span>:
- <span style=color:#f92672>job</span>:
  <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Build App</span>
  <span style=color:#f92672>steps</span>:
  
  - <span style=color:#f92672>task</span>: <span style=color:#ae81ff>DockerCompose@0</span>
    <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Start dependencies (docker-compose)</span>
    <span style=color:#f92672>inputs</span>:
      <span style=color:#f92672>containerregistrytype</span>: <span style=color:#ae81ff>Container Registry</span>
      <span style=color:#f92672>dockerComposeFile</span>: <span style=color:#ae81ff>docker-compose.yml</span>
      <span style=color:#f92672>dockerComposeCommand</span>: <span style=color:#e6db74>&#39;up -d&#39;</span>
  
  - <span style=color:#f92672>task</span>: <span style=color:#ae81ff>UseDotNet@2</span>
    <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Installing .NET SDK</span>
    <span style=color:#f92672>inputs</span>:
      <span style=color:#f92672>packageType</span>: <span style=color:#e6db74>&#39;sdk&#39;</span>
      <span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3.1.x&#39;</span>

  - <span style=color:#f92672>task</span>: <span style=color:#ae81ff>NuGetCommand@2</span>
    <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Restore NuGet packages</span>
    <span style=color:#f92672>inputs</span>:
      <span style=color:#f92672>restoreSolution</span>: <span style=color:#ae81ff>BlogApp.sln</span>
      <span style=color:#f92672>includeNuGetOrg</span>: <span style=color:#66d9ef>true</span>

  - <span style=color:#f92672>task</span>: <span style=color:#ae81ff>DotNetCoreCLI@2</span>
    <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Build</span>
    <span style=color:#f92672>inputs</span>:
      <span style=color:#f92672>command</span>: <span style=color:#ae81ff>build</span>
      <span style=color:#f92672>projects</span>: <span style=color:#ae81ff>$(appProjectDir)/BlogApp.Api.csproj</span>
      <span style=color:#f92672>arguments</span>: <span style=color:#e6db74>&#39;-c $(buildConfiguration) --no-restore&#39;</span>

  - <span style=color:#f92672>task</span>: <span style=color:#ae81ff>DotNetCoreCLI@2</span>
    <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Test</span>
    <span style=color:#f92672>inputs</span>:
      <span style=color:#f92672>command</span>: <span style=color:#ae81ff>test</span>
      <span style=color:#f92672>projects</span>: <span style=color:#e6db74>&#39;tests/**/*.csproj&#39;</span>
      <span style=color:#f92672>arguments</span>: <span style=color:#e6db74>&#39;-c $(buildConfiguration) --collect:&#34;XPlat Code Coverage&#34;&#39;</span>
</code></pre></div><p>The yaml pipeline can be quite daunting at first sight, but once you get the hang of it it&rsquo;s not that bad. When I got started, this page <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema%2Cparameter-schema">YAML schema reference</a> helped me a lot.</p><p>Let&rsquo;s review the steps:</p><h3 id=trigger-pool-and-variables>Trigger, pool and variables<a hidden class=anchor aria-hidden=true href=#trigger-pool-and-variables>#</a></h3><p>The <strong>trigger</strong> section tells the pipelines to run the build for the <strong>included</strong> branches, when changes occur on the configured <strong>paths</strong>.</p><p>The <strong>pool</strong> section tells on which pool our jobs will run. In this case, I&rsquo;m using the Microsoft-hosted pool and telling it to run my jobs using an ubuntu image.</p><p>In the <strong>variables</strong> section I just set the build configuration and the path to the API to avoid typing it multiple times along the tasks. Nothing special.</p><h3 id=jobs>Jobs<a hidden class=anchor aria-hidden=true href=#jobs>#</a></h3><p>We only have one job in our build. I recommend reading the page above to understand the hierarchy of things. For now, it&rsquo;s enough to know that one job can have tasks.</p><h4 id=docker-compose-task>Docker compose task<a hidden class=anchor aria-hidden=true href=#docker-compose-task>#</a></h4><p>As we know, to run our tests we need to make sure we have our SQL Server running on Docker since our tests will expect a server on <code>localhost,1433</code>. For that, we use the <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker-compose?view=azure-devops">DockerCompose@0</a> task.</p><p>We need to specify which container registry we want to use (<code>containerregistrytype</code>). The default is to use Azure ACR. Since the SQL Server image lives in the Docker public registry, we need to set the value to <code>Container Registry</code>. The link above has more details on it.</p><p>Then we just need to instruct it where the <code>docker-compose</code> file is and the command to execute. This is the same when running locally, <code>docker-compose up -d</code> (-d for detached, because we don&rsquo;t want to block the terminal)</p><h4 id=restore-build-and-test>Restore, Build and Test<a hidden class=anchor aria-hidden=true href=#restore-build-and-test>#</a></h4><p>The rest of the tasks are relatively self-explanatory and don&rsquo;t deviate much from the commands you would normally run if you use the <a href=https://docs.microsoft.com/en-us/dotnet/core/tools/>.NET Core CLI</a>. But let&rsquo;s review them anyway:</p><ol><li><p>First, we make sure we have the proper .NET Core SDK installed (<code>UseDotNet@2</code>)</p></li><li><p>Next, we restore the packages for the whole solution (<code>NuGetCommand@2</code>) passing the <code>.sln</code> file to <code>restoreSolution</code>.</p></li><li><p>Then we use the <code>DotNetCoreCLI@2</code> to issue commands against the .NET Core CLI. First starting with <code>build</code> passing the <code>csproj</code> of our API</p></li><li><p>Finally, we issue a <code>test</code> command passing a glob pattern to find all projects inside the <code>tests</code> folder.</p></li></ol><p>That&rsquo;s it! Now every time you push something to any of the branches configured in the <code>trigger</code> section, a build will run and our tests using Docker will be executed. <a href="https://joaopgrassi.visualstudio.com/BlogApp/_build/results?buildId=46&view=logs&j=011e1ec8-6569-5e69-4f06-baf193d1351e">See here a build run example</a>.</p><h2 id=creating-the-pipeline-on-azure-devops>Creating the Pipeline on Azure DevOps<a hidden class=anchor aria-hidden=true href=#creating-the-pipeline-on-azure-devops>#</a></h2><p>The next step is to save the yaml file above at the root of your repo. I usually put them into an <code>az-devops</code> folder, but you can place it anywhere you want and name it how you prefer. You need to commit and push it to be able to set up the pipeline on Azure DevOps. Follow the steps below:</p><ol><li><p>Go to Pipelines > New Pipeline (top-right button)</p></li><li><p>In &ldquo;Where is your code&rdquo; select the Git provider you are using for your project</p></li><li><p>Select the git repository where you have your <code>.yaml</code> file</p></li><li><p>In &ldquo;Configure your pipeline&rdquo; select the option &ldquo;Existing Azure Pipelines YAML&rdquo;</p></li><li><p>In the right menu select the branch and the the <code>.yaml</code> file. (If you pushed the file to a different branch other than the default, you need to change it)</p></li><li><p>Click on &ldquo;Continue&rdquo;</p></li><li><p>It shows a review of the file. Just click on Run to save and run the pipeline</p></li></ol><blockquote><p>The steps above expects that you already have a project and a connection to a Git provider (Azure Repos, GitHub or other) configured in your Azure DevOps organization.</p></blockquote><p>You should have your brand new pipeline now! Hopefully passing üòÖ</p><h2 id=extras>Extras<a hidden class=anchor aria-hidden=true href=#extras>#</a></h2><p>If you got this far, I have some extra stuff for you. Read on!</p><h3 id=code-coverage>Code coverage<a hidden class=anchor aria-hidden=true href=#code-coverage>#</a></h3><p>I tried to keep the pipeline above as simple as possible so it wouldn&rsquo;t be too much to explain here. But if you head to the project on <a href=https://github.com/joaopgrassi/dockercompose-azdevops>GitHub</a>, you&rsquo;ll see how I set up <code>code coverage</code>. That way you also have the coverage report as part of each build directly on Azure DevOps:</p><figure class=figure-border><img class=img-center src=/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/code_coverage_example.png alt="Code coverage report on Azure DevOps" loading=lazy><figcaption class=img-caption>Code coverage report on Azure DevOps</figcaption></figure><h2 id=build-tasks>Build tasks<a hidden class=anchor aria-hidden=true href=#build-tasks>#</a></h2><p>Another thing I&rsquo;d like to discuss is the tasks in the build. What I showed here is roughly what I use for my projects, but there are so many other ways to do it.</p><p>I use the NuGet task (<code>NuGetCommand@2</code>) to restore the packages. I could use the .NET CLI and simple <code>dotnet restore</code> and that would work as well. I use the NuGet task mostly because I have private NuGet feeds and I ran into several problems on Azure DevOps using the CLI. So after a lot of try and error that is what worked for me.</p><p>The <code>test</code> task also builds the projects again which is not great. That is necessary because in the <code>build</code> task I only build the API. If I would run the tests with <code>test --no-build</code> then it would fail because the test project was never built. You can decide what to do in your own projects. Maybe building the <code>.sln</code> instead is good enough.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this post, I showed you how we can reproduce our local test run using SQL Server on Docker on Azure Pipelines. We saw the <code>yaml</code> file and we went through all the tasks that define it.</p><p>As a closing consideration, I wanted to point out that there&rsquo;s no <em>silver bullet</em> pipeline, and what I presented here is just one way to do it. You could instead just write a PowerShell or Bash script that would do the same steps and your <code>yaml</code> file would just run that.</p><p>In your real-world apps, you need to consider what&rsquo;s best for your development flow and what your team is most comfortable with.</p><p>Coming up next we&rsquo;ll see how to do the same using GitHub actions. Stay tuned and thanks for reading!</p><p><a href=https://www.pexels.com/photo/contemporary-gradient-handrails-perspective-434645/>Photo by Pixabay from Pexels</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/azure-devops/>azure-devops</a></li><li><a href=https://blog.joaograssi.com/tags/integration-tests/>integration-tests</a></li><li><a href=https://blog.joaograssi.com/tags/docker/>docker</a></li><li><a href=https://blog.joaograssi.com/tags/pipelines/>pipelines</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>