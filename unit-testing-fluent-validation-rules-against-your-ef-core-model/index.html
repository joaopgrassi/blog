<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unit testing Fluent Validation rules against EF Core entity configuration | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,.net-core,entity-framework-core,fluentvalidation"><meta name=description content="When creating apps with EF Core and Fluent Validation, the validators can get out of sync with the entity configuration. Can we find out when they do? Yes!"><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/unit-testing-fluent-validation-rules-against-your-ef-core-model/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.ad3c9feff2635cbeec1afaf551499579aea970ed57152b4b8eb70d9e0c002bbd.css integrity="sha256-rTyf7/JjXL7sGvr1UUmVea6pcO1XFStLjrcNngwAK70=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><meta property="og:title" content="Unit testing Fluent Validation rules against EF Core entity configuration"><meta property="og:description" content="When creating apps with EF Core and Fluent Validation, the validators can get out of sync with the entity configuration. Can we find out when they do? Yes!"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/unit-testing-fluent-validation-rules-against-your-ef-core-model/"><meta property="og:image" content="https://blog.joaograssi.com/content/images/2019/12/fluent-validation-ef-core-blog-post-header-twitter.png"><meta property="article:published_time" content="2019-12-31T13:46:00+00:00"><meta property="article:modified_time" content="2019-12-31T13:46:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/content/images/2019/12/fluent-validation-ef-core-blog-post-header-twitter.png"><meta name=twitter:title content="Unit testing Fluent Validation rules against EF Core entity configuration"><meta name=twitter:description content="When creating apps with EF Core and Fluent Validation, the validators can get out of sync with the entity configuration. Can we find out when they do? Yes!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unit testing Fluent Validation rules against EF Core entity configuration","name":"Unit testing Fluent Validation rules against EF Core entity configuration","description":"In this post, I will share with you a solution to a problem that I see often when developing ASP.NET Core apps that use both Fluent Validation and Entity Framework (Core). ‚Ä¶","keywords":["asp.net-core",".net-core","entity-framework-core","fluentvalidation"],"articleBody":"In this post, I will share with you a solution to a problem that I see often when developing ASP.NET Core apps that use both Fluent Validation and Entity Framework (Core). I‚Äôll first set the scene: Show the EF Core Entity + Configuration + Fluent Validation we‚Äôll be working on. Next, I‚Äôll show the actual problem that emerges with this approach and in the end how can it be improved/solved.\nTL;DR:\nWhen creating apps with EF Core and Fluent Validation, the validators can get out of sync with the entity configuration (field length, required and so on). I wanted an automatic way to find out when they do and the way I achieve it was by adding unit tests for the Validators.\nYou can find the whole code over on GitHub. The interesting bits are CustomerValidatorTests.cs and TestExtensions.cs.\nAside: Fluent Validation is a well-known library in the .NET community for building strongly-typed validation rules. It‚Äôs very common to see it being used in ASP.NET applications since it integrates quite nicely into the model-binding infrastructure. In case you are not familiar with Fluent Validation, I recommend you take a look at their documentation to learn more and come back later üòâ\nSetting the scene In this section, I‚Äôll walk you through a simple example of building a Customer entity for our app. I‚Äôll show the POCO entity, it‚Äôs EF Core configuration and finally the Fluent Validator for it.\nThe Domain/DB side of things Let‚Äôs consider the following Customer entity as our main source of example:\npublic class Customer { public int Id { get; set; } public string Surname { get; set; } public string Forename { get; set; } public string Address { get; set; } } Just a POCO class. When using EF Core we need to ‚Äúmap‚Äù this entity to an actual table. EF Core does a good job of mapping our entity to actual database columns/types via its built-in conventions. For example, it will create a PK, auto-increment for our Id field without us doing anything.\nAlthough this is handy, I often like to have more control over these things. Since EF Core 2, we can define the entity‚Äôs individual configuration in a EntityTypeConfiguration file. So, for our Customer entity above, we could have this:\nusing Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; using Shop.Data.Entities; namespace Shop.Data { public class CustomerEntityTypeConfiguration : IEntityTypeConfiguration { public void Configure(EntityTypeBuilder builder) { builder.HasKey(c = c.Id); builder.Property(c = c.Surname).IsRequired().HasMaxLength(255); builder.Property(c = c.Forename).IsRequired().HasMaxLength(255); builder.Property(c = c.Address).HasMaxLength(250); } } } The class above tells EF explicitly how we want the entity fields to be configured in our DB. The relevant part for this post is the HasMaxLength(x) method. This will create in our database a VARCHAR(255) column type. If we haven‚Äôt done this, the column would be created with VARCHAR(MAX) which may not be what you initially wanted.\n NOTE: I‚Äôll skip all the migration generation/apply in this post since it‚Äôs not the focus of it.\n The Validation side of things Now that we have modeled and configured our Entity on the DB side, it‚Äôs time to use it. Imagine that we built an ASP.NET Core API and we have a POST endpoint which accepts the Customer model in the request body:\n[HttpPost] public async Task CreateCustomer( Customer newCustomer, CancellationToken cancellationToken) { _shopDbContext.Add(newCustomer); await _shopDbContext.SaveChangesAsync(cancellationToken); return CreatedAtRoute( nameof(GetById), new { id = newCustomer.Id }, newCustomer); } We want to be good developers and don‚Äôt accept bad values for our Customer. For instance, we stated in our CustomerEntityTypeConfiguration that both Surname and Forename are Required. The way it is now, I could create a customer with the name \"\". Not cool. Let‚Äôs now use Fluent Validation and create a rule for it:\nusing FluentValidation; using Shop.Data.Entities; namespace Shop.API.Controllers { public class CustomerValidator : AbstractValidator { public CustomerValidator() { RuleFor(x = x.Surname) .NotEmpty() .MaximumLength(255) .WithMessage(\"Please specify a last name\"); RuleFor(x = x.Forename) .NotEmpty() .MaximumLength(255) .WithMessage(\"Please specify a first name\"); RuleFor(x = x.Address).Length(20, 250); } } } Done! Now our API does not accept invalid values anymore for our Customer fields.\n Warning: Although I used the Customer entity as the parameter/response type in my POST method above, this is not a good practice in real world apps. Make sure to use DTO‚Äôs/ViewModels and keep your EF entities separated. Using DTO‚Äôs or ViewModels will not change the rest of the post but I chose to do this way to make it simpler.\n The actual problem The CustomerValidator pretty much defines the same ‚Äúconstraints‚Äù as in the CustomerEntityTypeConfiguration. We defined the Required fields and the MaxLength they have. This is important because if the API receives a Forename with 256 characters, the INSERT statement will fail and we don‚Äôt want to make a DB round-trip to discover that. The Fluent Validator enables us to short-circuit the request as soon as possible which is perfect.\nBut this creates a new problem. The validator is tightly coupled with our entity configuration. What if later on, another developer goes and changes the Forename in the CustomerEntityTypeConfiguration to be 200 characters long instead of 255? Suddenly requests that were ‚Äúallowed‚Äù will start to fail.\nThis is not just regarding the MaxLength side of things. For instance, Address is not Required on both sides, but what if the same developer makes it Required on the EF Core side? Again, failed DB inserts statements all over.\nSee the issue? Our Fluent Validator can become out of sync when new changes are introduced to our Domain/EF Core. It‚Äôs quite normal during the app lifetime that things change so this will be a thing that can happen.\nCan we do something about it?\nA proposed solution - Unit Tests! I ran into this issue myself a while ago. I could just: ‚ÄúI will remember to always go back and change the Fluent Validator when I change my EF Core model configuration. It‚Äôs gonna be OKAY‚Äù. NOPE, it‚Äôs not. I‚Äôll forget about it and I don‚Äôt want to rely on my memory. Remember, never trust yourself when it comes to these things!\nI enjoy writing tests. More even when they take the ‚Äúburden‚Äù of having to remember these type of things.\nSo I thought: Wouldn‚Äôt it be nice if I could write a test which would compare my EF Core model against the validator for my entity and break if they don‚Äôt match? Turns out we can!\nCreating our test This part involved me pooking around the source code (and tests) of both Fluent Validation and EF Core. Let‚Äôs start on how can we access the configuration from CustomerEntityTypeConfiguration.\nObtaining EntityTypeBuilder When we configure our entity inside CustomerEntityTypeConfiguration, we work with EntityTypeBuilder. During our test, we need to somehow get the builder so we can access its metadata where we can ‚Äúlearn‚Äù about its properties.\nI went down the rabbit hole of understanding how all these things work. In a nutshel, to get an instance of EntityTypeBuilder, we need first a ModelBuilder. If you have some experience with EF you might remember of working with it here:\nprotected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity() .Property(b = b.Url) .IsRequired(); } But it turns out to create a ModelBuilder I needed a bunch of other stuff. First, I needed an instance of my DbContext. For that I also needed an instance of DbContextOptionsBuilder and ConventionSet(which tells EF how to apply its conventions). Phew!. It might sound complicated but it‚Äôs not so bad. After some trial and error, I managed to get it working. Here‚Äôs the code that does all of this and returns and instance of EntityTypeBuilder:\nusing Microsoft.Data.Sqlite; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; using Microsoft.EntityFrameworkCore.Metadata.Conventions; private EntityTypeBuilder GetCustomerEntityConfigurationMetadata() { // Construct the optionsBuilder using InMemory SqlLite  var options = new DbContextOptionsBuilder() .UseSqlite(new SqliteConnection(\"DataSource=:memory:\")) .Options; var sut = new ShopDbContext(options); // Get the convention set for this db  var conventionSet = ConventionSet.CreateConventionSet(sut); // Now create the ModelBuilder  var modelBuilder = new ModelBuilder(conventionSet); // Get the EntityTypeBuilder for Customer  var entityTypeBuilder = modelBuilder.Entity(); // Apply the EntityConfiguration to our entityTypeBuilder  var customerEntityConfiguration = new CustomerEntityTypeConfiguration(); customerEntityConfiguration.Configure(entityTypeBuilder); return entityTypeBuilder; } I‚Äôll not go into too much detail here because this alone is a post for itself, but I left comments and hopefully they help explain it. The important part is: In the end, we have an instance of EntityTypeBuilder with our configurations applied. Now we can do something like this:\n// Get the forename property from the builder var foreNameProperty = entityTypeBuilder.Metadata .FindDeclaredProperty(nameof(Customer.Forename)); // access individual metadata of the property var maxLength = foreNameProperty.GetMaxLength(); var isNullable = foreNameProperty.IsColumnNullable(); Obtaining each IPropertyValidator With the EF part out of our way, we need to somehow get the metadata about our CustomerValidator. I browsed the source code of Fluent Validation on GitHub and turns out there‚Äôs already something I could use to get going. This was my ‚Äúsource of inspiration‚Äù ValidatorDescriptor.\nIn short, the way it works is: Inside our CustomerValidator we add rules for our properties. When we add things like: NotEmpty(), MaximumLength(255) we are adding validators for the property. All property validators implement the IPropertyValidator interface from Fluent Validation. In our validator, we have used the NotEmptyValidator, LengthValidator and MaximumLengthValidator.\nContinuing, once we have an instance of our CustomerValidator we can get all of its IPropertyValidator for a given field. Once we have an instance of an IPropertyValidator we can access its configured value.\nHere‚Äôs a generic extension method I wrote which returns all IPropertyValidators of a given member (property):\nusing FluentValidation; using FluentValidation.Internal; using FluentValidation.Validators; using System; using System.Linq; using System.Linq.Expressions; public static IPropertyValidator[] GetValidatorsForMember( this IValidator validator, Expression expression) { var descriptor = validator.CreateDescriptor(); var expressionMemberName = expression.GetMember()?.Name; return descriptor.GetValidatorsForMember(expressionMemberName).ToArray(); } Now we can do this:\n// Get the LengthValidator for the ForeName property of the validator var validator = new CustomerValidator(); // GetValidatorsForMember returns an array but we are interested only in // the LengthValidator, so I used Linq's OfType to filter the array var foreNameLengthValidator = validator.GetValidatorsForMember(t = t.Forename) .OfType().First(); // We can inspect the max value now! foreNameLengthValidator.Max; The actual test Okay - We have everything we need and can write our tests. Let‚Äôs create one that will check if our CustomerValidator is implementing the correct rules for the Forename property in our Customer entity:\n[Fact] public void ForenameRule_ShouldMatchEFModelConfiguration() { var validator = new CustomerValidator(); // Get the rules for the Forename field in the CustomerValidator  var foreNameLengthValidator = validator.GetValidatorsForMember(t = t.Forename) .OfType().First(); var foreNameNotEmptyValidator = validator.GetValidatorsForMember(t = t.Forename) .OfType().FirstOrDefault(); // Get the EF EntityTypeBuilder for our Customer entity  var entityTypeBuilder = GetCustomerEntityConfigurationMetadata(); var foreNameDbProperty = entityTypeBuilder.Metadata .FindDeclaredProperty(nameof(Customer.Forename)); // Rule Should have the same length as EF Configuration  Assert.Equal(foreNameDbProperty.GetMaxLength(), foreNameLengthValidator.Max); // If the Column is required (NOTNULL) in the EF configuration  // the the foreNameNotEmptyValidator should not be null  if (!foreNameDbProperty.IsColumnNullable()) Assert.NotNull(foreNameNotEmptyValidator); else Assert.Null(foreNameNotEmptyValidator); } Nice! Now if I go to my CustomerValidator and change the rules of Forename to the code below, the test should fail:\nRuleFor(x = x.Surname) .NotEmpty() .MaximumLength(256) // 1 character longer than the allowed  .WithMessage(\"Please specify a last name\"); And indeed it does! Customer Validator out-of-sync with EF Model \nConclusion With this approach, we can be sure that if something changes regarding either our EF Model or our validation our tests will let us know.\nFor what I needed this solved the problem pretty well. I didn‚Äôt dig much into all of the Validators available and more complex validations (like lists and conditions). It might require a bit more investigation, but at least the base is there and can be improved.\n It can get a bit tedious to write all of this though, so read on in case you want to see another version which makes it a bit better.\n That‚Äôs it. I hope this was useful and until next year (Sorry, I couldn‚Äôt let this one slip üòÖ)\nBonus - Improving things a bit I implemented this test in 2 classes and it turned out it was quite a lot of code. Having to get each field twice (from EF Config and Fluent Validation) is very tedious. I managed to work the methods a bit and now I think things are a bit better.\nLet‚Äôs say you want to test a validator which contains several LengthValidator rules at once. With the improved version of the extension methods we can do this:\n[Fact] public void Validator_MaxLengthRules_ShouldHaveSameLengthAsEfEntity() { var propertiesToValidate = new string[] { nameof(Customer.Surname), nameof(Customer.Forename), nameof(Customer.Address), }; var entityBuilder = TestExtensions .GetEntityTypeBuilder(); // Get the validators for the fields above  Dictionarystring, LengthValidator validatorsDict = propertiesToValidate .Select(p = new { Key = p, Validator = _sut.GetValidatorsForMember(p).OfType().First() }) .ToDictionary(key = key.Key, value = value.Validator); // Get the database metadata for each field as configured in EF Core  Dictionarystring, IMutableProperty expectedDbProperties = propertiesToValidate .Select(p = new { Key = p, FieldMetadata = entityBuilder.Metadata.FindDeclaredProperty(p) }) .ToDictionary(key = key.Key, value = value.FieldMetadata); foreach (var propValidator in validatorsDict) { // grab the db metadata by the field name  var expectedDbMetadata = expectedDbProperties[propValidator.Key]; // Validator Length and Db should have the same values  Assert.Equal(expectedDbMetadata.GetMaxLength(), propValidator.Value.Max); } } Now with a single test we can test all the LengthValidator rules of a given entity!\nPhoto by Nick Karvounis on Unsplash\n","wordCount":"2177","inLanguage":"en","image":"https://blog.joaograssi.com/content/images/2019/12/fluent-validation-ef-core-blog-post-header-twitter.png","datePublished":"2019-12-31T13:46:00Z","dateModified":"2019-12-31T13:46:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/unit-testing-fluent-validation-rules-against-your-ef-core-model/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Unit testing Fluent Validation rules against EF Core entity configuration</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/content/images/2019/12/fluent-validation-ef-core-blog-post-header-twitter.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#setting-the-scene aria-label="Setting the scene">Setting the scene</a><ul><li><a href=#the-domaindb-side-of-things aria-label="The Domain/DB side of things">The Domain/DB side of things</a></li><li><a href=#the-validation-side-of-things aria-label="The Validation side of things">The Validation side of things</a></li></ul></li><li><a href=#the-actual-problem aria-label="The actual problem">The actual problem</a></li><li><a href=#a-proposed-solution---unit-tests aria-label="A proposed solution - Unit Tests!">A proposed solution - Unit Tests!</a></li><li><a href=#creating-our-test aria-label="Creating our test">Creating our test</a></li><li><a href=#obtaining-entitytypebuildert aria-label="Obtaining EntityTypeBuilder&amp;lt;T&amp;gt;">Obtaining <code>EntityTypeBuilder&lt;T></code></a></li><li><a href=#obtaining-each-ipropertyvalidator aria-label="Obtaining each IPropertyValidator">Obtaining each <code>IPropertyValidator</code></a></li><li><a href=#the-actual-test aria-label="The actual test">The actual test</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#bonus---improving-things-a-bit aria-label="Bonus - Improving things a bit">Bonus - Improving things a bit</a></li></ul></blockquote></details></div><div class=post-content><p>In this post, I will share with you a solution to a problem that I see often when developing ASP.NET Core apps that use both <a href=https://fluentvalidation.net/>Fluent Validation</a> and <a href=https://github.com/aspnet/EntityFrameworkCore>Entity Framework (Core)</a>. I&rsquo;ll first set the scene: Show the EF Core Entity + Configuration + Fluent Validation we&rsquo;ll be working on. Next, I&rsquo;ll show the actual problem that emerges with this approach and in the end how can it be improved/solved.</p><p><strong>TL;DR</strong>:</p><p>When creating apps with EF Core and Fluent Validation, the validators can get out of sync with the entity configuration (field length, required and so on). I wanted an automatic way to find out when they do and the way I achieve it was by adding unit tests for the Validators.</p><p>You can find the whole code over on <a href=https://github.com/joaopgrassi/fluentvalidation-efcore-ruletesting>GitHub</a>. The interesting bits are <a href=https://github.com/joaopgrassi/fluentvalidation-efcore-ruletesting/blob/main/tests/Shop.API.Tests/CustomerValidatorTests.cs>CustomerValidatorTests.cs</a> and <a href=https://github.com/joaopgrassi/fluentvalidation-efcore-ruletesting/blob/main/tests/Shop.API.Tests/TestExtensions.cs>TestExtensions.cs</a>.</p><p><strong>Aside</strong>: Fluent Validation is a well-known library in the .NET community for building strongly-typed validation rules. It&rsquo;s very common to see it being used in ASP.NET applications since it integrates quite nicely into the model-binding infrastructure. In case you are not familiar with Fluent Validation, I recommend you take a look at their <a href=https://fluentvalidation.net/start>documentation</a> to learn more and come back later üòâ</p><h2 id=setting-the-scene>Setting the scene<a hidden class=anchor aria-hidden=true href=#setting-the-scene>#</a></h2><p>In this section, I&rsquo;ll walk you through a simple example of building a <code>Customer</code> entity for our app. I&rsquo;ll show the POCO entity, it&rsquo;s EF Core configuration and finally the Fluent Validator for it.</p><h3 id=the-domaindb-side-of-things>The Domain/DB side of things<a hidden class=anchor aria-hidden=true href=#the-domaindb-side-of-things>#</a></h3><p>Let&rsquo;s consider the following <code>Customer</code> entity as our main source of example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Customer</span>
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Id { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Surname { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Forename { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
}
</code></pre></div><p>Just a <a href=https://en.wikipedia.org/wiki/Plain_old_CLR_object>POCO</a> class. When using EF Core we need to &ldquo;map&rdquo; this entity to an actual table. EF Core does a good job of mapping our entity to actual database columns/types via its <a href=https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/conventions/built-in>built-in conventions</a>. For example, it will create a PK, auto-increment for our <code>Id</code> field without us doing anything.</p><p>Although this is handy, I often like to have more control over these things. Since EF Core 2, we can define the entity&rsquo;s individual configuration in a <a href=http://anthonygiretti.com/2018/01/11/entity-framework-core-2-entity-type-configuration/>EntityTypeConfiguration</a> file. So, for our <code>Customer</code> entity above, we could have this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore;
<span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore.Metadata.Builders;
<span style=color:#66d9ef>using</span> Shop.Data.Entities;

<span style=color:#66d9ef>namespace</span> Shop.Data
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomerEntityTypeConfiguration</span> : IEntityTypeConfiguration&lt;Customer&gt;
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Configure(EntityTypeBuilder&lt;Customer&gt; builder)
        {
            builder.HasKey(c =&gt; c.Id);
            builder.Property(c =&gt; c.Surname).IsRequired().HasMaxLength(<span style=color:#ae81ff>255</span>);
            builder.Property(c =&gt; c.Forename).IsRequired().HasMaxLength(<span style=color:#ae81ff>255</span>);
            builder.Property(c =&gt; c.Address).HasMaxLength(<span style=color:#ae81ff>250</span>);
        }
    }
}
</code></pre></div><p>The class above tells EF explicitly how we want the entity fields to be configured in our DB. The relevant part for this post is the <code>HasMaxLength(x)</code> method. This will create in our database a <code>VARCHAR(255)</code> column type. If we haven&rsquo;t done this, the column would be created with <code>VARCHAR(MAX)</code> which may not be what you initially wanted.</p><blockquote><p>NOTE: I&rsquo;ll skip all the migration generation/apply in this post since it&rsquo;s not the focus of it.</p></blockquote><h3 id=the-validation-side-of-things>The Validation side of things<a hidden class=anchor aria-hidden=true href=#the-validation-side-of-things>#</a></h3><p>Now that we have modeled and configured our Entity on the DB side, it&rsquo;s time to use it. Imagine that we built an ASP.NET Core API and we have a <code>POST</code> endpoint which accepts the <code>Customer</code> model in the request body:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[HttpPost]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; CreateCustomer(
    Customer newCustomer, CancellationToken cancellationToken)
{
    _shopDbContext.Add(newCustomer);
    <span style=color:#66d9ef>await</span> _shopDbContext.SaveChangesAsync(cancellationToken);

    <span style=color:#66d9ef>return</span> CreatedAtRoute(
        nameof(GetById),
        <span style=color:#66d9ef>new</span> { id = newCustomer.Id }, newCustomer);
}
</code></pre></div><p>We want to be good developers and don&rsquo;t accept bad values for our <code>Customer</code>. For instance, we stated in our <code>CustomerEntityTypeConfiguration</code> that both <code>Surname</code> and <code>Forename</code> are <code>Required</code>. The way it is now, I could create a customer with the name <code>""</code>. Not cool. Let&rsquo;s now use Fluent Validation and create a rule for it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> FluentValidation;
<span style=color:#66d9ef>using</span> Shop.Data.Entities;

<span style=color:#66d9ef>namespace</span> Shop.API.Controllers
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomerValidator</span> : AbstractValidator&lt;Customer&gt;
    {
        <span style=color:#66d9ef>public</span> CustomerValidator()
        {
            RuleFor(x =&gt; x.Surname)
                .NotEmpty()
                .MaximumLength(<span style=color:#ae81ff>255</span>)
                .WithMessage(<span style=color:#e6db74>&#34;Please specify a last name&#34;</span>);

            RuleFor(x =&gt; x.Forename)
                .NotEmpty()
                .MaximumLength(<span style=color:#ae81ff>255</span>)
                .WithMessage(<span style=color:#e6db74>&#34;Please specify a first name&#34;</span>);

            RuleFor(x =&gt; x.Address).Length(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>250</span>);
        }
    }
}
</code></pre></div><p>Done! Now our API does not accept invalid values anymore for our <code>Customer</code> fields.</p><blockquote><p><strong>Warning</strong>: Although I used the <code>Customer</code> entity as the parameter/response type in my POST method above, this is not a good practice in real world apps. Make sure to use DTO&rsquo;s/ViewModels and keep your EF entities separated. Using DTO&rsquo;s or ViewModels will not change the rest of the post but I chose to do this way to make it simpler.</p></blockquote><h2 id=the-actual-problem>The actual problem<a hidden class=anchor aria-hidden=true href=#the-actual-problem>#</a></h2><p>The <code>CustomerValidator</code> pretty much defines the same &ldquo;constraints&rdquo; as in the <code>CustomerEntityTypeConfiguration</code>. We defined the <code>Required</code> fields and the <code>MaxLength</code> they have. This is important because if the API receives a <code>Forename</code> with <code>256</code> characters, the <code>INSERT</code> statement will fail and we don&rsquo;t want to make a DB round-trip to discover that. The Fluent Validator enables us to short-circuit the request as soon as possible which is perfect.</p><p>But this creates a new problem. The validator is tightly coupled with our entity configuration. What if later on, another developer goes and changes the <code>Forename</code> in the <code>CustomerEntityTypeConfiguration</code> to be <code>200</code> characters long instead of <code>255</code>? Suddenly requests that were &ldquo;allowed&rdquo; will start to fail.</p><p>This is not just regarding the <code>MaxLength</code> side of things. For instance, <code>Address</code> is not <code>Required</code> on both sides, but what if the same developer makes it <code>Required</code> on the EF Core side? Again, failed DB inserts statements all over.</p><p>See the issue? Our Fluent Validator can become out of sync when new changes are introduced to our Domain/EF Core. It&rsquo;s quite normal during the app lifetime that things change so this <strong>will</strong> be a thing that can happen.</p><p>Can we do something about it?</p><h2 id=a-proposed-solution---unit-tests>A proposed solution - Unit Tests!<a hidden class=anchor aria-hidden=true href=#a-proposed-solution---unit-tests>#</a></h2><p>I ran into this issue myself a while ago. I could just: &ldquo;I will remember to always go back and change the Fluent Validator when I change my EF Core model configuration. It&rsquo;s gonna be OKAY&rdquo;. <strong>NOPE</strong>, it&rsquo;s not. I&rsquo;ll forget about it and I don&rsquo;t want to rely on my memory. Remember, never trust yourself when it comes to these things!</p><p>I enjoy writing tests. More even when they take the &ldquo;burden&rdquo; of having to remember these type of things.</p><p>So I thought: Wouldn&rsquo;t it be nice if I could write a test which would compare my EF Core model against the validator for my entity and break if they don&rsquo;t match? Turns out we can!</p><h2 id=creating-our-test>Creating our test<a hidden class=anchor aria-hidden=true href=#creating-our-test>#</a></h2><p>This part involved me pooking around the source code (and tests) of both Fluent Validation and EF Core. Let&rsquo;s start on how can we access the configuration from <code>CustomerEntityTypeConfiguration</code>.</p><h2 id=obtaining-entitytypebuildert>Obtaining <code>EntityTypeBuilder&lt;T></code><a hidden class=anchor aria-hidden=true href=#obtaining-entitytypebuildert>#</a></h2><p>When we configure our entity inside <code>CustomerEntityTypeConfiguration</code>, we work with <code>EntityTypeBuilder&lt;Customer></code>. During our test, we need to somehow get the builder so we can access its metadata where we can &ldquo;learn&rdquo; about its properties.</p><p>I went down the rabbit hole of understanding how all these things work. In a nutshel, to get an instance of <code>EntityTypeBuilder&lt;Customer></code>, we need first a <code>ModelBuilder</code>. If you have some experience with EF you might remember of working with it here:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Blog&gt;()
        .Property(b =&gt; b.Url)
        .IsRequired();
}
</code></pre></div><p>But it turns out to create a <code>ModelBuilder</code> I needed a bunch of other stuff. First, I needed an instance of my <code>DbContext</code>. For that I also needed an instance of <code>DbContextOptionsBuilder</code> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.conventions.conventionset?view=efcore-3.1"><code>ConventionSet</code></a>(which tells EF how to apply its conventions). Phew!. It might sound complicated but it&rsquo;s not so bad. After some trial and error, I managed to get it working. Here&rsquo;s the code that does all of this and returns and instance of <code>EntityTypeBuilder&lt;Customer></code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> Microsoft.Data.Sqlite;
<span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore;
<span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore.Metadata.Builders;
<span style=color:#66d9ef>using</span> Microsoft.EntityFrameworkCore.Metadata.Conventions;

<span style=color:#66d9ef>private</span> EntityTypeBuilder&lt;Customer&gt; GetCustomerEntityConfigurationMetadata()
{
    <span style=color:#75715e>// Construct the optionsBuilder using InMemory SqlLite
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> options = <span style=color:#66d9ef>new</span> DbContextOptionsBuilder&lt;ShopDbContext&gt;()
            .UseSqlite(<span style=color:#66d9ef>new</span> SqliteConnection(<span style=color:#e6db74>&#34;DataSource=:memory:&#34;</span>))
            .Options;

    <span style=color:#66d9ef>var</span> sut = <span style=color:#66d9ef>new</span> ShopDbContext(options);

    <span style=color:#75715e>// Get the convention set for this db
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> conventionSet = ConventionSet.CreateConventionSet(sut);

    <span style=color:#75715e>// Now create the ModelBuilder
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> modelBuilder = <span style=color:#66d9ef>new</span> ModelBuilder(conventionSet);

    <span style=color:#75715e>// Get the EntityTypeBuilder for Customer
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> entityTypeBuilder = modelBuilder.Entity&lt;Customer&gt;();

    <span style=color:#75715e>// Apply the EntityConfiguration to our entityTypeBuilder
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> customerEntityConfiguration = <span style=color:#66d9ef>new</span> CustomerEntityTypeConfiguration();
    customerEntityConfiguration.Configure(entityTypeBuilder);

    <span style=color:#66d9ef>return</span> entityTypeBuilder;
}
</code></pre></div><p>I&rsquo;ll not go into too much detail here because this alone is a post for itself, but I left comments and hopefully they help explain it. The important part is: In the end, we have an instance of <code>EntityTypeBuilder</code> with our configurations applied. Now we can do something like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Get the forename property from the builder
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> foreNameProperty = entityTypeBuilder.Metadata
    .FindDeclaredProperty(nameof(Customer.Forename));

<span style=color:#75715e>// access individual metadata of the property
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> maxLength = foreNameProperty.GetMaxLength();
<span style=color:#66d9ef>var</span> isNullable = foreNameProperty.IsColumnNullable();
</code></pre></div><h2 id=obtaining-each-ipropertyvalidator>Obtaining each <code>IPropertyValidator</code><a hidden class=anchor aria-hidden=true href=#obtaining-each-ipropertyvalidator>#</a></h2><p>With the EF part out of our way, we need to somehow get the metadata about our <code>CustomerValidator</code>. I browsed the source code of Fluent Validation on GitHub and turns out there&rsquo;s already something I could use to get going. This was my &ldquo;source of inspiration&rdquo; <a href=https://sourcegraph.com/github.com/JeremySkinner/FluentValidation/-/blob/src/FluentValidation/ValidatorDescriptor.cs#L74:1-74:23>ValidatorDescriptor</a>.</p><p>In short, the way it works is: Inside our <code>CustomerValidator</code> we add rules for our properties. When we add things like: <code>NotEmpty()</code>, <code>MaximumLength(255)</code> we are adding validators for the property. All property validators implement the <code>IPropertyValidator</code> interface from Fluent Validation. In our validator, we have used the <code>NotEmptyValidator</code>, <code>LengthValidator</code> and <code>MaximumLengthValidator</code>.</p><p>Continuing, once we have an instance of our <code>CustomerValidator</code> we can get all of its <code>IPropertyValidator</code> for a given field. Once we have an instance of an <code>IPropertyValidator</code> we can access its configured value.</p><p>Here&rsquo;s a generic extension method I wrote which returns all <code>IPropertyValidator</code>s of a given member (property):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> FluentValidation;
<span style=color:#66d9ef>using</span> FluentValidation.Internal;
<span style=color:#66d9ef>using</span> FluentValidation.Validators;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Linq;
<span style=color:#66d9ef>using</span> System.Linq.Expressions;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IPropertyValidator[] GetValidatorsForMember&lt;T, TProperty&gt;(
    <span style=color:#66d9ef>this</span> IValidator&lt;T&gt; validator, Expression&lt;Func&lt;T, TProperty&gt;&gt; expression)
{
    <span style=color:#66d9ef>var</span> descriptor = validator.CreateDescriptor();
    <span style=color:#66d9ef>var</span> expressionMemberName = expression.GetMember()?.Name;

    <span style=color:#66d9ef>return</span> descriptor.GetValidatorsForMember(expressionMemberName).ToArray();
}

</code></pre></div><p>Now we can do this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Get the LengthValidator for the ForeName property of the validator
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> validator = <span style=color:#66d9ef>new</span> CustomerValidator();

<span style=color:#75715e>// GetValidatorsForMember returns an array but we are interested only in
</span><span style=color:#75715e>// the LengthValidator, so I used Linq&#39;s OfType to filter the array
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> foreNameLengthValidator = validator.GetValidatorsForMember(t =&gt; t.Forename)
    .OfType&lt;MaximumLengthValidator&gt;().First();

<span style=color:#75715e>// We can inspect the max value now!
</span><span style=color:#75715e></span>foreNameLengthValidator.Max;
</code></pre></div><h2 id=the-actual-test>The actual test<a hidden class=anchor aria-hidden=true href=#the-actual-test>#</a></h2><p>Okay - We have everything we need and can write our tests. Let&rsquo;s create one that will check if our <code>CustomerValidator</code> is implementing the correct rules for the <code>Forename</code> property in our <code>Customer</code> entity:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[Fact]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ForenameRule_ShouldMatchEFModelConfiguration()
{
    <span style=color:#66d9ef>var</span> validator = <span style=color:#66d9ef>new</span> CustomerValidator();

    <span style=color:#75715e>// Get the rules for the Forename field in the CustomerValidator
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> foreNameLengthValidator = validator.GetValidatorsForMember(t =&gt; t.Forename)
        .OfType&lt;MaximumLengthValidator&gt;().First();

    <span style=color:#66d9ef>var</span> foreNameNotEmptyValidator = validator.GetValidatorsForMember(t =&gt; t.Forename)
        .OfType&lt;NotEmptyValidator&gt;().FirstOrDefault();

    <span style=color:#75715e>// Get the EF EntityTypeBuilder&lt;T&gt; for our Customer entity
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> entityTypeBuilder = GetCustomerEntityConfigurationMetadata();

    <span style=color:#66d9ef>var</span> foreNameDbProperty = entityTypeBuilder.Metadata
        .FindDeclaredProperty(nameof(Customer.Forename));

    <span style=color:#75715e>// Rule Should have the same length as EF Configuration
</span><span style=color:#75715e></span>    Assert.Equal(foreNameDbProperty.GetMaxLength(), foreNameLengthValidator.Max);

    <span style=color:#75715e>// If the Column is required (NOTNULL) in the EF configuration
</span><span style=color:#75715e></span>    <span style=color:#75715e>// the the foreNameNotEmptyValidator should not be null
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (!foreNameDbProperty.IsColumnNullable())
        Assert.NotNull(foreNameNotEmptyValidator);
    <span style=color:#66d9ef>else</span>
        Assert.Null(foreNameNotEmptyValidator);
}
</code></pre></div><p>Nice! Now if I go to my <code>CustomerValidator</code> and change the rules of <code>Forename</code> to the code below, the test should fail:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>RuleFor(x =&gt; x.Surname)
 .NotEmpty()
 .MaximumLength(<span style=color:#ae81ff>256</span>) <span style=color:#75715e>// 1 character longer than the allowed
</span><span style=color:#75715e></span> .WithMessage(<span style=color:#e6db74>&#34;Please specify a last name&#34;</span>);
</code></pre></div><p>And indeed it does!<figure class=figure-border><img class=img-center src=/unit-testing-fluent-validation-rules-against-your-ef-core-model/assert-validator-outofsync.png alt="Customer Validator out-of-sync with EF Model" loading=lazy><figcaption class=img-caption>Customer Validator out-of-sync with EF Model</figcaption></figure></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>With this approach, we can be sure that if something changes regarding either our EF Model or our validation our tests will let us know.</p><p>For what I needed this solved the problem pretty well. I didn&rsquo;t dig much into all of the Validators available and more complex validations (like lists and conditions). It might require a bit more investigation, but at least the base is there and can be improved.</p><blockquote><p>It can get a bit tedious to write all of this though, so read on in case you want to see another version which makes it <em>a bit</em> better.</p></blockquote><p>That&rsquo;s it. I hope this was useful and until next year (Sorry, I couldn&rsquo;t let this one slip üòÖ)</p><h2 id=bonus---improving-things-a-bit>Bonus - Improving things a bit<a hidden class=anchor aria-hidden=true href=#bonus---improving-things-a-bit>#</a></h2><p>I implemented this test in 2 classes and it turned out it was quite a lot of code. Having to get each field twice (from EF Config and Fluent Validation) is very tedious. I managed to work the methods a bit and now I think things are a bit better.</p><p>Let&rsquo;s say you want to test a validator which contains several <code>LengthValidator</code> rules at once. With the improved version of the extension methods we can do this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>
</span><span style=color:#a6e22e>[Fact]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Validator_MaxLengthRules_ShouldHaveSameLengthAsEfEntity()
{
    <span style=color:#66d9ef>var</span> propertiesToValidate = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[]
    {
        nameof(Customer.Surname),
        nameof(Customer.Forename),
        nameof(Customer.Address),
    };

    <span style=color:#66d9ef>var</span> entityBuilder = TestExtensions
        .GetEntityTypeBuilder&lt;Customer, CustomerEntityTypeConfiguration&gt;();

    <span style=color:#75715e>// Get the validators for the fields above
</span><span style=color:#75715e></span>    Dictionary&lt;<span style=color:#66d9ef>string</span>, LengthValidator&gt; validatorsDict = propertiesToValidate
        .Select(p =&gt; <span style=color:#66d9ef>new</span> { Key = p, Validator = _sut.GetValidatorsForMember(p).OfType&lt;LengthValidator&gt;().First() })
        .ToDictionary(key =&gt; key.Key, <span style=color:#66d9ef>value</span> =&gt; <span style=color:#66d9ef>value</span>.Validator);

    <span style=color:#75715e>// Get the database metadata for each field as configured in EF Core
</span><span style=color:#75715e></span>    Dictionary&lt;<span style=color:#66d9ef>string</span>, IMutableProperty&gt; expectedDbProperties = propertiesToValidate
        .Select(p =&gt; <span style=color:#66d9ef>new</span> { Key = p, FieldMetadata = entityBuilder.Metadata.FindDeclaredProperty(p) })
        .ToDictionary(key =&gt; key.Key, <span style=color:#66d9ef>value</span> =&gt; <span style=color:#66d9ef>value</span>.FieldMetadata);

    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> propValidator <span style=color:#66d9ef>in</span> validatorsDict)
    {
        <span style=color:#75715e>// grab the db metadata by the field name
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> expectedDbMetadata = expectedDbProperties[propValidator.Key];

        <span style=color:#75715e>// Validator Length and Db should have the same values
</span><span style=color:#75715e></span>        Assert.Equal(expectedDbMetadata.GetMaxLength(), propValidator.Value.Max);
    }
}
</code></pre></div><p>Now with a single test we can test all the <code>LengthValidator</code> rules of a given entity!</p><p>Photo by <a href="https://unsplash.com/@nickkarvounis?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Nick Karvounis</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/.net-core/>.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/entity-framework-core/>entity-framework-core</a></li><li><a href=https://blog.joaograssi.com/tags/fluentvalidation/>fluentvalidation</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>