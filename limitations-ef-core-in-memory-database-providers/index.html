<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Limitations of the EF Core in-memory database providers | Joao Grassi's blog</title><meta name=keywords content="asp.net-core,.net-core,integration-tests,entity-framework-core,SQL"><meta name=description content="In this post we'll be looking at some of the limitations you may encounter while using the EF Core in-memory database providers for your ASP.NET Core integration tests."><meta name=author content="Joao Grassi"><link rel=canonical href=https://blog.joaograssi.com/limitations-ef-core-in-memory-database-providers/><link href=https://blog.joaograssi.com/assets/css/stylesheet.min.5df15aa0fa69a07f461d7f7c1614ad5deed5c58a9894e3e7595bf68d9e7d3414.css integrity="sha256-XfFaoPppoH9GHX98FhStXe7VxYqYlOPnWVv2jZ59NBQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.joaograssi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.joaograssi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.joaograssi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.joaograssi.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.joaograssi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content="Limitations of the EF Core in-memory database providers"><meta property="og:description" content="In this post we'll be looking at some of the limitations you may encounter while using the EF Core in-memory database providers for your ASP.NET Core integration tests."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.joaograssi.com/limitations-ef-core-in-memory-database-providers/"><meta property="og:image" content="https://blog.joaograssi.com/content/images/2020/08/limitations-ef-core-in-memory-database-providers-1.png"><meta property="article:published_time" content="2020-08-09T13:08:00+00:00"><meta property="article:modified_time" content="2020-08-09T13:08:00+00:00"><meta property="og:see_also" content="https://blog.joaograssi.com/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions/"><meta property="og:see_also" content="https://blog.joaograssi.com/asp-net-core-integration-tests-with-docker-compose-azure-pipelines/"><meta property="og:see_also" content="https://blog.joaograssi.com/using-docker-compose-for-your-asp-net-ef-core-integration-tests/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.joaograssi.com/content/images/2020/08/limitations-ef-core-in-memory-database-providers-1.png"><meta name=twitter:title content="Limitations of the EF Core in-memory database providers"><meta name=twitter:description content="In this post we'll be looking at some of the limitations you may encounter while using the EF Core in-memory database providers for your ASP.NET Core integration tests."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Limitations of the EF Core in-memory database providers","name":"Limitations of the EF Core in-memory database providers","description":"This is the first post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers (this post)\n  Part 2: Using docker-compose …","keywords":["asp.net-core",".net-core","integration-tests","entity-framework-core","SQL"],"articleBody":"This is the first post in the Integration tests in ASP.NET Core series.\n  Part 1: Limitations of the EF Core in-memory database providers (this post)\n  Part 2: Using docker-compose for your ASP.NET + EF Core integration tests\n  Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines\n  Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions\n  In this post we’ll be looking at some of the limitations you may encounter while using the EF Core in-memory database providers for your ASP.NET Core integration tests. I’ll share some real-world problems I faced while working on production ASP.NET Core apps and how I worked around them so far.\nIntroduction Writing integration tests in ASP.NET Core is a breeze. Even in cases where the app is complex (authentication, authorization, and so on) because the whole ASP.NET Core pipeline is very extensible, those things are relatively easy to circumvent and adapt during your tests.\nIntegration tests make it easy to test the whole app. With a single test, you can go as far down as to your app’s persistence layer, ensuring your code works. I find this very valuable and I believe it brings a high level of confidence that things are working the way they should.\nTesting code that uses EF Core is also very easy thanks to the different database providers it offers. There’s an in-memory database and also SQLite. They work great, are very fast and easy to use. But when your app starts to get more serious these providers start to show their limitations.\nThis page Testing code that uses EF Core in the EF Core docs provides great insights about the challenges of testing code that depends on EF. I recommend reading it. Below I’ll share problems that I had while working on production apps using EF Core.\nReal-world limitations with the in-memory providers Database schemas If you use database schemas with EF Core and use the SQLite provider for your tests this kinda work. SQLite does not support multiple schemas as SQL Server does, but if you use EF Core to access/manipulate your tables, meaning you don’t use raw SQL you are covered. Probably under the hood things are managed for you, since here it says the migration command EnsureSchema is a no-op. If you use schemas in Debug mode you can see these warnings:\nMicrosoft.EntityFrameworkCore.Model.Validation: Warning: The entity type 'Blog' is configured to use schema 'app'. SQLite does not support schemas. This configuration will be ignored by the SQLite provider. But if you do execute raw sql commands/queries in your app, for example:\ndbContext.Database.ExecuteSqlInterpolated( $\"UPDATE [app].[Blogs] SET Title = {title} WHERE Id = {id}); This will fail with Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'no such table: app.Blogs'.\nThe way I worked-around these cases is simply checking the database provider and removing the schema from the SQL string. Something like this:\nvar schema = \"[app].\"; if (Database.ProviderName == \"Microsoft.EntityFrameworkCore.Sqlite\") schema = string.Empty; dbContext.Database.ExecuteSqlInterpolated( $\"UPDATE {schema}[Blogs] SET Title = {title} WHERE Id = {id}); I only have this in one place, so it’s not a big deal but still not great.\nMigrations If your app is simple then I’d say most of the things will work regarding migrations. EF Core does a good job of rebuilding things SQLite does not support. But if your app starts to grow more complicated and especially if you write custom migrations (maybe to move data around and so on), then you’ll mostly hit the limitations. This page does a great job talking about them: SQLite EF Core Database Provider Limitations.\nComplex queries and other things In tutorials on the web, you see only simple CRUDs. Everything works and it’s wonderful. But in real production apps, things are almost always more complicated.\nI can take a wild guess that if you are reading this you had to write at least once in your developer career a recursive query in SQL. Yes, that CTE thingy that you always have to google on how to do it (thanks Pinal for saving my ass multiple times! You are a legend).\nSQLite supports recursive queries but the syntax is different from SQL Server, so if you run in prod with SQL Server and your tests in SQLite you’ll need to maintain two versions of your CTE query.\nMoreover, how do you know the CTE query works on SQL Server? (Assuming SQL Server is your production database, of course)\nOkay you are a diligent developer and you tested it in a SQL Server you have somewhere during development but what if someone changes the query later? Are you 100% sure that they will always run the query on a full SQL Server? To me, that’s kinda scary.\nAnother point: If you use things like OData there’s also a great chance (depending on what you do in your tests) that you’ll run into troubles as well. You can argue that: One shouldn’t test implementations details such as OData, but if my API serves a front-end which relies heavily on an OData query, I for sure want to have that exact query in an integration test to see if it works as we expect. That’s the whole point of having integration tests.\nI recently stumbled upon this question on Stack Overflow: How to test an Entity Framework Core database as InMemory with insert functionality for a large number of rows\nThe OP was asking how could they run the integration tests using some set of predefined data, derived from their production database.\nFor sure inserting manually is an option, but when you need a lot of data which was the OP’s case having manual inserts starts to become not so nice. It simply boils down to the fact that in-memory providers are not meant for this use case in my opinion.\nWrapping up In this post, I presented you with some of the limitations I faced while writing integration tests for production ASP.NET + EF Core apps. I also presented what others are facing and some documentation pages that also talk about in great detail, so you can build your conclusion about it and not just rely on my biased opinion.\nI’d like to point out that I still use the in-memory database providers for my integration tests. They offer a great value between feature-set and speed and work great for most use cases, but in certain scenarios, they are simply not the correct tool for the job.\nIn critical parts of an app that uses data, I believe our tests must match the production environment as close as possible, for us to have confidence that when the code gets deployed things will work as predicted otherwise, we’ll get phone calls during the night and… we probably don’t want that 😅\nComing up next I’ll show you how we can use a full SQL Server for our integration tests. Stay tuned!\nPhoto by Aleksandar Pasaric from Pexels\n","wordCount":"1149","inLanguage":"en","image":"https://blog.joaograssi.com/content/images/2020/08/limitations-ef-core-in-memory-database-providers-1.png","datePublished":"2020-08-09T13:08:00Z","dateModified":"2020-08-09T13:08:00Z","author":{"@type":"Person","name":"Joao Grassi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaograssi.com/limitations-ef-core-in-memory-database-providers/"},"publisher":{"@type":"Organization","name":"Joao Grassi's blog","logo":{"@type":"ImageObject","url":"https://blog.joaograssi.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.joaograssi.com accesskey=h title="Joao Grassi's blog (Alt + H)">Joao Grassi's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.joaograssi.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.joaograssi.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.joaograssi.com/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Limitations of the EF Core in-memory database providers</h1></header><figure class=entry-cover><img src=https://blog.joaograssi.com/content/images/2020/08/limitations-ef-core-in-memory-database-providers-1.png alt="Road with speed limits printed"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#real-world-limitations-with-the-in-memory-providers aria-label="Real-world limitations with the in-memory providers">Real-world limitations with the in-memory providers</a><ul><li><a href=#database-schemas aria-label="Database schemas">Database schemas</a></li><li><a href=#migrations aria-label=Migrations>Migrations</a></li><li><a href=#complex-queries-and-other-things aria-label="Complex queries and other things">Complex queries and other things</a></li></ul></li><li><a href=#wrapping-up aria-label="Wrapping up">Wrapping up</a></li></ul></blockquote></details></div><div class=post-content><p>This is the first post in the <a href=/series/integration-tests-in-asp.net-core>Integration tests in ASP.NET Core</a> series.</p><ul><li><p><a href=/limitations-ef-core-in-memory-database-providers>Part 1: Limitations of the EF Core in-memory database providers (this post)</a></p></li><li><p><a href=/using-docker-compose-for-your-asp-net-ef-core-integration-tests>Part 2: Using docker-compose for your ASP.NET + EF Core integration tests</a></p></li><li><p><a href=/asp-net-core-integration-tests-with-docker-compose-azure-pipelines>Part 3: ASP.NET Core integration tests with docker-compose on Azure Pipelines</a></p></li><li><p><a href=/posts/2020/asp-net-core-integration-tests-with-docker-compose-github-actions>Part 4: ASP.NET Core integration tests with docker-compose on GitHub Actions</a></p></li></ul><p>In this post we&rsquo;ll be looking at some of the limitations you may encounter while using the EF Core in-memory database providers for your ASP.NET Core integration tests. I&rsquo;ll share some real-world problems I faced while working on production ASP.NET Core apps and how I worked around them so far.</p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Writing integration tests in ASP.NET Core is a breeze. Even in cases where the app is complex (authentication, authorization, and so on) because the whole ASP.NET Core pipeline is very extensible, those things are relatively easy to circumvent and adapt during your tests.</p><p>Integration tests make it easy to test the whole app. With a single test, you can go as far down as to your app&rsquo;s persistence layer, ensuring your code works. I find this very valuable and I believe it brings a high level of confidence that things are working the way they should.</p><p>Testing code that uses EF Core is also very easy thanks to the different database providers it offers. There&rsquo;s an in-memory database and also SQLite. They work great, are very fast and easy to use. But when your app starts to get more serious these providers start to show their limitations.</p><p>This page <a href=https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing>Testing code that uses EF Core</a> in the EF Core docs provides great insights about the challenges of testing code that depends on EF. I recommend reading it. Below I&rsquo;ll share problems that I had while working on production apps using EF Core.</p><h2 id=real-world-limitations-with-the-in-memory-providers>Real-world limitations with the in-memory providers<a hidden class=anchor aria-hidden=true href=#real-world-limitations-with-the-in-memory-providers>#</a></h2><h3 id=database-schemas>Database schemas<a hidden class=anchor aria-hidden=true href=#database-schemas>#</a></h3><p>If you use database schemas with EF Core and use the SQLite provider for your tests this <em>kinda</em> work. SQLite does not support multiple schemas as SQL Server does, but if you use EF Core to access/manipulate your tables, meaning you don&rsquo;t use raw SQL you are covered. Probably under the hood things are managed for you, since <a href=https://docs.microsoft.com/en-us/ef/core/providers/sqlite/limitations>here</a> it says the migration command <code>EnsureSchema</code> is a no-op. If you use schemas in Debug mode you can see these warnings:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Microsoft.EntityFrameworkCore.Model.Validation: Warning: The entity type <span style=color:#e6db74>&#39;Blog&#39;</span> 
is configured to use schema <span style=color:#e6db74>&#39;app&#39;</span>. SQLite does not support schemas. 
This configuration will be ignored by the SQLite provider.
</code></pre></div><p>But if you <strong>do</strong> execute raw sql commands/queries in your app, for example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>dbContext.Database.ExecuteSqlInterpolated(
    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#e6db74>&#34;UPDATE [app].[Blogs] SET Title = {title} WHERE Id = {id});
</span></code></pre></div><p>This will fail with <code>Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'no such table: app.Blogs'</code>.</p><p>The way I worked-around these cases is simply checking the database provider and removing the schema from the SQL string. Something like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> schema = <span style=color:#e6db74>&#34;[app].&#34;</span>;

<span style=color:#66d9ef>if</span> (Database.ProviderName == <span style=color:#e6db74>&#34;Microsoft.EntityFrameworkCore.Sqlite&#34;</span>)
    schema = <span style=color:#66d9ef>string</span>.Empty;

dbContext.Database.ExecuteSqlInterpolated(
    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#e6db74>&#34;UPDATE {schema}[Blogs] SET Title = {title} WHERE Id = {id});
</span></code></pre></div><p>I only have this in one place, so it&rsquo;s not a big deal but still not great.</p><h3 id=migrations>Migrations<a hidden class=anchor aria-hidden=true href=#migrations>#</a></h3><p>If your app is simple then I&rsquo;d say most of the things will work regarding migrations. EF Core does a good job of rebuilding things SQLite does not support. But if your app starts to grow more complicated and especially if you write custom migrations (maybe to move data around and so on), then you&rsquo;ll mostly hit the limitations. This page does a great job talking about them: <a href=https://docs.microsoft.com/en-us/ef/core/providers/sqlite/limitations>SQLite EF Core Database Provider Limitations</a>.</p><h3 id=complex-queries-and-other-things>Complex queries and other things<a hidden class=anchor aria-hidden=true href=#complex-queries-and-other-things>#</a></h3><p>In tutorials on the web, you see only simple CRUDs. Everything works and it&rsquo;s wonderful. But in real production apps, things are almost always more complicated.</p><p>I can take a wild guess that if you are reading this you had to write at least once in your developer career a recursive query in SQL. Yes, that <a href=https://blog.sqlauthority.com/2008/07/28/sql-server-simple-example-of-recursive-cte/>CTE thingy</a> that you always have to google on how to do it (thanks Pinal for saving my ass multiple times! You are a legend).</p><p>SQLite <a href=https://stackoverflow.com/questions/7456957/basic-recursive-query-on-sqlite3>supports recursive queries</a> but the syntax is different from SQL Server, so if you run in prod with SQL Server and your tests in SQLite you&rsquo;ll need to maintain two versions of your CTE query.</p><p>Moreover, how do you know the CTE query works on SQL Server? (Assuming SQL Server is your production database, of course)</p><p>Okay you are a diligent developer and you tested it in a SQL Server you have somewhere during development but what if someone changes the query later? Are you 100% sure that they will always run the query on a full SQL Server? To me, that&rsquo;s kinda scary.</p><p>Another point: If you use things like <strong>OData</strong> there&rsquo;s also a great chance (depending on what you do in your tests) that you&rsquo;ll run into troubles as well. You can argue that: One shouldn&rsquo;t test implementations details such as OData, but if my API serves a front-end which relies heavily on an OData query, I for sure want to have that exact query in an integration test to see if it works as we expect. That&rsquo;s the whole point of having integration tests.</p><p>I recently stumbled upon this question on Stack Overflow: <a href=https://stackoverflow.com/questions/62278499/how-to-test-an-entity-framework-core-database-as-inmemory-with-insert-functional>How to test an Entity Framework Core database as InMemory with insert functionality for a large number of rows</a></p><p>The OP was asking how could they run the integration tests using some set of predefined data, derived from their production database.</p><p>For sure inserting manually is an option, but when you need a lot of data which was the OP&rsquo;s case having manual inserts starts to become not so nice. It simply boils down to the fact that in-memory providers are not meant for this use case in my opinion.</p><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>In this post, I presented you with some of the limitations I faced while writing integration tests for production ASP.NET + EF Core apps. I also presented what others are facing and some documentation pages that also talk about in great detail, so you can build your conclusion about it and not just rely on my biased opinion.</p><p>I&rsquo;d like to point out that I still use the in-memory database providers for my integration tests. They offer a great value between feature-set and speed and work great for most use cases, but in certain scenarios, they are simply not the correct tool for the job.</p><p>In critical parts of an app that uses data, I believe our tests must match the production environment as close as possible, for us to have confidence that when the code gets deployed things will work as predicted otherwise, we&rsquo;ll get phone calls during the night and&mldr; we probably don&rsquo;t want that 😅</p><p>Coming up next I&rsquo;ll show you how we can use a full SQL Server for our integration tests. Stay tuned!</p><p><a href=https://www.pexels.com/photo/red-light-streaks-3312216/>Photo by Aleksandar Pasaric from Pexels</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.joaograssi.com/tags/asp.net-core/>asp.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/.net-core/>.net-core</a></li><li><a href=https://blog.joaograssi.com/tags/integration-tests/>integration-tests</a></li><li><a href=https://blog.joaograssi.com/tags/entity-framework-core/>entity-framework-core</a></li><li><a href=https://blog.joaograssi.com/tags/sql/>SQL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.joaograssi.com>Joao Grassi's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.joaograssi.com/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>